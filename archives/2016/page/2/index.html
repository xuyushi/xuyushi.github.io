<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="google-site-verification" content="o97_geJ8Rz-PdvGXQ3H64C2krv2YSDEYxiyUnAZ3buY" />
  
  <title>Archives: 2016 | Xu Yushi&#39;&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  

  <meta name="description" content="安卓 | xuyushi | 许雨石 | Android | java | developer">
<meta property="og:type" content="website">
<meta property="og:title" content="Xu Yushi''s Blog">
<meta property="og:url" content="http://yoursite.com/archives/2016/page/2/index.html">
<meta property="og:site_name" content="Xu Yushi''s Blog">
<meta property="og:description" content="安卓 | xuyushi | 许雨石 | Android | java | developer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xu Yushi''s Blog">
<meta name="twitter:description" content="安卓 | xuyushi | 许雨石 | Android | java | developer">
  
  

  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '[object Object]', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  

	<link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
</head>

<body>
	<!-- header -->
  
<header class="md-header md-header--half">
  <div class="md-header__wrapper">
		<div class="md-header__toolbar">
			<h1 class="md-header__logo">
				<a class="md-touch-target" href="/"></a>
			</h1>
			<div class="md-header__search-bar">
				<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="index.search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
			</div>
			<div class="md-header__menu-button-wrapper">
				<button id="md-header__menu-button">
					<i class="fa fa-bars"></i>
				</button> 
				<ul id="md-header__navigations">
						<li><a href="/">index.home</a></li>
						<li><a href="/about">index.about</a></li>
						<li><a href="/categories/android">index.android</a></li>
			</ul>
			</div>
		</div>
		<div class="md-header__toolbar-spacer md-header__toolbar-spacer--hide"></div>
		<div class="md-header__details">
			<h1 class="md-header__title ">archives: 2016</h1>
				<h2 class="md-header__subtitle md-header__subtitle--hide">
						<p class="subtitle">低调、务实、自驱、反思</p>
					</h2>
	</div>
	</div>
</header>

  
  <!-- main -->
  <div class="md-content__wrapper">
	  <!-- main -->
	  <main class="md-main">
	    

				<section class="md-posts__wrapper">
					<h1 class="md-posts__year">
						<a href="/archives/2016"><i class="icon fa fa-calendar-o"></i>2016</a>
					</h1>
					<div class="md-board display-animation">

			 	<article class="md-tile md-tile--small md-tile--deep-purple md-ripple__effect">
			<a href="/2016/02/21/抽象工厂模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">抽象工厂模式 Abstract Factory Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-21T14:26:00.000Z" itemprop="datePublished">Feb 21 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="抽象工厂模式_Abstract_Factory_Pattern">抽象工厂模式 Abstract Factory Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>抽象工厂模式 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="/media/14560648848499.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--small md-tile--light-green md-ripple__effect">
			<a href="/2016/02/21/工厂方法模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">工厂方法模式 Factory Method Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-21T13:46:00.000Z" itemprop="datePublished">Feb 21 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="工厂方法模式_Factory_Method_Pattern">工厂方法模式 Factory Method Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即<strong>通过工厂子类来确定究竟应该实例化哪一个具体产品类</strong>（并不是指子类本身在运行时做决定，而是编写者在创建类时，不需要知道实际的创建产品的类型，选择了使用哪个子类自然决定了实际的创建产品类型）。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务 给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="/media/14560634114616.png" alt=""></p>
<p>Product：抽象产品<br>ConcreteProduct：具体产品<br>Factory：抽象工厂<br>ConcreteFactory：具体工厂，实现了实际造出产品的方法</p></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--large md-tile--light-green md-ripple__effect">
			<a href="/2016/02/21/工厂模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">工厂模式 Factory  Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-21T13:10:00.000Z" itemprop="datePublished">Feb 21 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="简单工厂模式">简单工厂模式</h1><h2 id="定义">定义</h2><blockquote>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560604563955.png" alt=""></p>
<p>Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑</p>
<p>Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>
<p>ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--small md-tile--indigo md-ripple__effect">
			<a href="/2016/02/21/装饰者模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">装饰者模式 Decorator Design Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-21T02:23:55.000Z" itemprop="datePublished">Feb 21 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="装饰者模式_Decorator_Design_Pattern">装饰者模式 Decorator Design Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p><strong>装饰者模式</strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更具有弹性的替代方案，其别名也可以称为包装器(Wrapper） </p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560246781613.png" alt=""></p>
<p>Component: 抽象构件<br>ConcreteComponent: 具体构件<br>Decorator: 抽象装饰类<br>ConcreteDecorator: 具体装饰类</p></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--small md-tile--amber md-ripple__effect">
			<a href="/2016/02/20/观察者模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">观察者模式 Observer Design Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-20T14:07:55.000Z" itemprop="datePublished">Feb 20 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="观察者模式_Observer_Design_Pattern">观察者模式 Observer Design Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会受到通知并自动更新</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ol>
<li>对象之间的一对多依赖。一个对象状态的更新时，其他对象需要自动更新，而且其他对象的数量动态可变。（注册、反注册） </li>
<li>对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。 (解耦)</li>
<li>MVC 中的 View 层实现</li>
</ol>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14559766489224.png" alt=""></p></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--large md-tile--yellow md-ripple__effect">
			<a href="/2016/02/17/策略模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">策略模式 Strategy Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-17T13:26:55.000Z" itemprop="datePublished">Feb 17 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="策略模式_Strategy_Pattern">策略模式 Strategy Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p><strong>策略模式</strong>定义了算法簇，分别封装起来，让它们之间可以互相替代，此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象多个子类，而又需要使用if-else 或者 switch-case来选择时。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14557164239727.png" alt=""></p>
<ul>
<li>Context：用来操作策略的上下文环境。</li>
<li>Strategy : 策略的抽象</li>
<li>ImplementationOne、ImplementationTwo：具体策略的实现</li>
</ul></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--large md-tile--brown md-ripple__effect">
			<a href="/2016/02/04/2015summarize/" class="md-touch-target"></a>
			<h2 class="md-tile__title">2015小结</h2>     
			<span class="md-tile__date"><time datetime="2016-02-04T15:22:55.000Z" itemprop="datePublished">Feb 04 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]<br>I</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=1141940&auto=1&height=66"></iframe>

<h1 id="2015小结">2015小结</h1><p>　　2015算是自己人生中又一个分水岭，过了除夕才是过完中国的一年，赶在除夕之前整理下自己的2015。</p>
<h2 id="工作">工作</h2><p>　　在学校做硬件 -&gt; 实习做驱动 -&gt; 离开了校园 -&gt; 迈入职场-&gt; Android APP 开发<br>　　<br>　　这一年在技术上的成长自己还是很满意的</p>
<h3 id="流水账">流水账</h3><p>　　2015年初，从美团实习完回学校之后就发觉对 Android 有浓厚的兴趣，考虑到后续工作可能接触到 Android 相关的工作，2015年出开始自学 Java 和 Android，抱着『第一行代码』走了一遍，对 Android 有了初步的认识。之后忙毕业一直到了6月。</p>
<p>　　6月正式入职之后，最初是被分配在了 MTK 平台那边，并不和 Android 相关，主动找了桥哥和栋哥商量，调到了 Android 开发，美团这一点还是挺人性的，尊重员工的意愿。还好有申燊同学带着，一步一步开始了 Android 之旅。</p>
<p>　　第一个项目是做的小美接单，当样机拼装完成，成功打印的那一刻还是挺有成就感的。<br>　　<br></div>
			<div class="md-tile__tags">
				<a href="/tags/日记/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						日记
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--small md-tile--deep-purple md-ripple__effect">
			<a href="/2016/02/02/状态模式/" class="md-touch-target"></a>
			<h2 class="md-tile__title">状态模式State Design Pattern</h2>     
			<span class="md-tile__date"><time datetime="2016-02-02T15:22:55.000Z" itemprop="datePublished">Feb 02 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="状态模式_State_Design_Pattern">状态模式 State Design Pattern</h1><h2 id="定义">定义</h2><h2 id="目的">目的</h2><ul>
<li>根据不同的状态，采取不同的行为</li>
<li>允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样</li>
</ul>
<h2 id="优点">优点</h2><ul>
<li>减少了 if else，switch 语句的复杂程度 </li>
<li>增加新的状态和逻辑时，便于修改</li>
</ul>
<h2 id="缺点">缺点</h2><ul>
<li>类的种类增加<br>*</li>
</ul>
<h2 id="步骤">步骤</h2><ol>
<li>定义一个 <code>context</code> 类，来给外接提供一个接口</li>
<li>定义一个 <code>state</code> 基类</li>
<li>根据<code>state</code> 状态，派生定义其他的不同状态类</li>
<li>在派生<code>state</code> 中，定义不同的行为</li>
<li>在<code>context</code>中持有一个当前 <code>state</code>的变量</li>
<li>改变<code>context</code>中的<code>state</code>状态</li>
</ol></div>
			<div class="md-tile__tags">
				<a href="/tags/Pattern/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						Pattern
					</a>
				<a href="/tags/设计模式/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						设计模式
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--small md-tile--orange md-ripple__effect">
			<a href="/2016/02/01/注解/" class="md-touch-target"></a>
			<h2 class="md-tile__title">Java注解</h2>     
			<span class="md-tile__date"><time datetime="2016-02-01T07:12:00.000Z" itemprop="datePublished">Feb 01 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="注解">注解</h1><h2 id="注解目的">注解目的</h2><ol>
<li>生成文档 ，如 @see @param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
<li>在编译时进行格式检查。如@override </li>
</ol>
<h2 id="注解基础">注解基础</h2><p>最基础的注解如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br></pre></td></tr></table></figure>
<p>@ 表示这是一个注解，之后的字母表示这个注解的名字，以上例子的注解名字为 <code>Entity</code></p></div>
			<div class="md-tile__tags">
				<a href="/tags/java/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						java
					</a>
				<a href="/tags/注解/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						注解
					</a>
			</div>
	</article>



			 	<article class="md-tile md-tile--large md-tile--purple md-ripple__effect">
			<a href="/2016/01/14/内存泄露/" class="md-touch-target"></a>
			<h2 class="md-tile__title">Android 内存泄露</h2>     
			<span class="md-tile__date"><time datetime="2016-01-14T09:27:00.000Z" itemprop="datePublished">Jan 14 2016</time></span>
			<div class="md-tile__excerpt"><p>[TOC]</p>
<h1 id="内存泄露">内存泄露</h1><blockquote>
<p>内存泄露的定义:<br>当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放(Remove,移除)他们.</p>
</blockquote>
<h2 id="产生的原因：">产生的原因：</h2><p>内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）</p>
<p><em>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</em></p></div>
			<div class="md-tile__tags">
				<a href="/tags/GC/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						GC
					</a>
				<a href="/tags/内存泄露/" class="md-tile__tag">
						<i class="material-icons">lens</i> 
						内存泄露
					</a>
			</div>
	</article>


		</div></section>
	<nav class="md-posts__paginator">
			<a class="extend prev" rel="prev" href="/archives/2016/">&laquo;</a><a class="page-number" href="/archives/2016/">1</a><span class="page-number current">2</span><a class="page-number" href="/archives/2016/page/3/">3</a><a class="extend next" rel="next" href="/archives/2016/page/3/">&raquo;</a>
		</nav>



	  </main>
  </div>
  
  <!-- js scripts -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/drawer.js" type="text/javascript"></script>
<script src="/js/tiles.js" type="text/javascript"></script>

</body>
</html>
