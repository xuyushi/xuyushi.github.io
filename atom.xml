<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Xu Yushi''s Blog]]></title>
  <subtitle><![CDATA[低调、务实、自驱、反思]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2016-02-28T07:18:43.000Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[Xu Yushi]]></name>
    <email><![CDATA[xmy166@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android 中的MVP 模式]]></title>
    <link href="http://yoursite.com/2016/02/28/MVP/"/>
    <id>http://yoursite.com/2016/02/28/MVP/</id>
    <published>2016-02-28T01:10:00.000Z</published>
    <updated>2016-02-28T07:18:43.000Z</updated>
    <content type="html"><![CDATA[<p>MVP模式的核心思想：</p>
<blockquote>
<p>MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成功接口，Model类还是原来的Model。</p>
</blockquote>
<h2 id="MVC">MVC</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14566254770300.png" alt=""></p>
<ul>
<li>其中View层其实就是程序的UI界面，用于向用户展示数据以及接收用户的输入</li>
<li>而Model层就是JavaBean实体类，用于保存实例数据</li>
<li>Controller控制器用于更新UI界面和数据实例</li>
</ul>
<p>View层接受用户的输入，然后通过Controller修改对应的Model实例；同时，当Model实例的数据发生变化的时候，需要修改UI界面，可以通过Controller更新界面。View层也可以直接更新Model实例的数据，而不用每次都通过Controller，这样对于一些简单的数据更新工作会变得方便许多。</p>
<h2 id="MVP">MVP</h2><p>MVP与MVC最不同的一点是<strong>M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层</strong><br><a id="more"></a></p>
<h3 id="Model">Model</h3><p>Model 是用户界面需要显示数据的抽象，也可以理解为从业务数据（结果）那里到用户界面的抽象（Business rule, data access, model classes）</p>
<h3 id="View">View</h3><p>视图这一层体现的很轻薄，负责显示数据、提供友好界面跟用户交互就行。MVP下Activity和Fragment体现在了这一层，Activity一般也就做加载UI视图、设置监听再交由Presenter处理的一些工作，所以也就需要持有相应Presenter的引用。例如，Activity上滚动列表时隐藏或者显示Acionbar（Toolbar），这样的UI逻辑时也应该在这一层。另外在View上输入的数据做一些判断时，例如，EditText的输入数据，假如是简单的非空判断则可以作为View层的逻辑，而当需要对EditText的数据进行更复杂的比较时，如从数据库获取本地数据进行判断时明显需要经过Model层才能返回了，所以这些细节需要自己掂量。</p>
<h3 id="Presenter">Presenter</h3><p>Presenter这一层处理着程序各种逻辑的分发，收到View层UI上的反馈命令、定时命令、系统命令等指令后分发处理逻辑交由业务层做具体的业务操作，然后将得到的 Model 给 View 显示。</p>
<p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14543967788503.png" alt=""></p>
<p>这就是MVP模式，现在这样的话，Activity的工作的简单了，只用来响应生命周期，其他工作都丢到Presenter中去完成。从上图可以看出，<strong>Presenter是Model和View之间的桥梁</strong>，为了让结构变得更加简单，<strong>View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处</strong>。</p>
<h3 id="优点">优点</h3><ul>
<li>分离了视图逻辑和业务逻辑，降低了耦合</li>
<li>Activity只处理生命周期的任务，代码变得更加简洁</li>
<li>视图逻辑和业务逻辑分别抽象到了<strong>View和Presenter的接口</strong>中去，提高代码的可阅读性</li>
<li>Presenter被抽象成接口，可以有多种具体的实现，所以方便进行单元测试</li>
<li>把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起内存泄露和OOM</li>
</ul>
<h3 id="代码变得更加简洁">代码变得更加简洁</h3><p>使用MVP之后，Activity就能瘦身许多了，基本上只有FindView、SetListener以及Init的代码。其他的就是对Presenter的调用，还有对View接口的实现。这种情形下阅读代码就容易多了，而且你只要看Presenter的接口，就能明白这个模块都有哪些业务，很快就能定位到具体代码。Activity变得容易看懂，容易维护，以后要调整业务、删减功能也就变得简单许多。</p>
<h3 id="方便进行单元测试">方便进行单元测试</h3><p>MVP中，由于业务逻辑都在Presenter里，我们完全可以写一个PresenterTest的实现类继承Presenter的接口，现在只要在Activity里把Presenter的创建换成PresenterTest，就能进行单元测试了，测试完再换回来即可。万一发现还得进行测试，那就再换成PresenterTest吧。</p>
<h3 id="避免内存泄露">避免内存泄露</h3><p>Android APP 发生OOM的最大原因就是出现内存泄露造成APP的内存不够用，而造成内存泄露的两大原因之一就是Activity泄露（Activity Leak）（另一个原因是Bitmap泄露（Bitmap Leak））</p>
<blockquote>
<p>Java一个强大的功能就是其虚拟机的内存回收机制，这个功能使得Java用户在设计代码的时候，不用像C++用户那样考虑对象的回收问题。然而，Java用户总是喜欢随便写一大堆对象，然后幻想着虚拟机能帮他们处理好内存的回收工作。可是虚拟机在回收内存的时候，只会回收那些没有被引用的对象，被引用着的对象因为还可能会被调用，所以不能回收。</p>
</blockquote>
<p>Activity是有生命周期的，用户随时可能切换Activity，当APP的内存不够用的时候，系统会回收处于后台的Activity的资源以避免OOM。</p>
<p>采用传统的MV模式，一大堆异步任务和对UI的操作都放在Activity里面，比如你可能从网络下载一张图片，在下载成功的回调里把图片加载到 Activity 的 ImageView 里面，所以异步任务保留着对Activity的引用。这样一来，即使Activity已经被切换到后台（onDestroy已经执行），这些异步任务仍然保留着对Activity实例的引用，所以系统就无法回收这个Activity实例了，结果就是Activity Leak。Android的组件中，Activity对象往往是在堆（Java Heap）里占最多内存的，所以系统会优先回收Activity对象，如果有Activity Leak，APP很容易因为内存不够而OOM。</p>
<p>采用MVP模式，只要在当前的Activity的onDestroy里，分离异步任务对Activity的引用，就能避免 Activity Leak。</p>
<h2 id="MVP_使用">MVP 使用</h2><p>MVP的主要特点就是把Activity里的许多逻辑都抽离到View和Presenter接口中去，并由具体的实现类来完成。</p>
<p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14543977053469.png" alt=""></p>
<ol>
<li>创建IPresenter接口，把所有业务逻辑的接口都放在这里，并创建它的实现PresenterCompl（在这里可以方便地查看业务功能，由于接口可以有多种实现所以也方便写单元测试），IPresenter持有 IView,调用 IView 中的方法</li>
<li>创建IView接口，把所有视图逻辑的接口都放在这里，其实现类是当前的Activity/Fragment</li>
<li>由UML图可以看出，<strong>Activity里包含了一个IPresenter，而PresenterCompl里又包含了一个IView并且依赖了Model</strong>。Activity里只保留对IPresenter的调用，其它工作全部留到PresenterCompl中实现</li>
<li>Model并不是必须有的，但是一定会有View和Presenter</li>
</ol>
<h2 id="DMEO">DMEO</h2><p>简单的登陆界面的例子<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14566421975499.gif" alt=""></p>
<ul>
<li>登陆 view 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.androidmvpdemo.Login.view;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/28.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoginView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEditText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showProgress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideProgress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUsernameError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPasswordError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginSuccess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登陆Presenter接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.androidmvpdemo.Login.presenter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/28.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoginPresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doLogin</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Presenter接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.androidmvpdemo.Login.presenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.xuyushi.androidmvpdemo.Login.model.User;</span><br><span class="line"><span class="keyword">import</span> io.github.xuyushi.androidmvpdemo.Login.view.ILoginView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/28.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> <span class="keyword">implements</span> <span class="title">ILoginPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ILoginView mLoginView;</span><br><span class="line">    <span class="keyword">private</span> User mUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginPresenter</span><span class="params">(ILoginView loginView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoginView = loginView;</span><br><span class="line">        initUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mUser = <span class="keyword">new</span> User(mLoginView.getUsername(), mLoginView.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLogin</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        mLoginView.showProgress();</span><br><span class="line">        <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mLoginView.hideProgress();</span><br><span class="line">                <span class="keyword">int</span> code = mUser.checkUserValidity(mLoginView.getUsername(), mLoginView.getPassword());</span><br><span class="line">                <span class="keyword">if</span> (code == -<span class="number">1</span>) &#123;</span><br><span class="line">                    mLoginView.setPasswordError();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">                    mLoginView.loginSuccess();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLoginView.clearEditText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLoginView = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义model</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.androidmvpdemo.Login.model;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/28.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkUserValidity</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="keyword">null</span> || password == <span class="keyword">null</span> ||</span><br><span class="line">                username.isEmpty() ||</span><br><span class="line">                password.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Activity 中实现 view接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.androidmvpdemo.Login.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.ProgressBar;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> butterknife.Bind;</span><br><span class="line"><span class="keyword">import</span> butterknife.ButterKnife;</span><br><span class="line"><span class="keyword">import</span> io.github.xuyushi.androidmvpdemo.Login.presenter.ILoginPresenter;</span><br><span class="line"><span class="keyword">import</span> io.github.xuyushi.androidmvpdemo.Login.presenter.LoginPresenter;</span><br><span class="line"><span class="keyword">import</span> io.github.xuyushi.androidmvpdemo.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">ILoginView</span>, <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ILoginPresenter mLoginPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.et_username)</span><br><span class="line">    EditText etUsername;</span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.et_passwrod)</span><br><span class="line">    EditText etPasswrod;</span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.bt_enter)</span><br><span class="line">    Button btEnter;</span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.bt_clear)</span><br><span class="line">    Button btClear;</span><br><span class="line">    <span class="annotation">@Bind</span>(R.id.progress)</span><br><span class="line">    ProgressBar progress;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">        mLoginPresenter = <span class="keyword">new</span> LoginPresenter(<span class="keyword">this</span>);</span><br><span class="line">        btEnter.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btClear.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearEditText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        etPasswrod.setText(<span class="string">""</span>);</span><br><span class="line">        etUsername.setText(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        progress.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        progress.setVisibility(View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsernameError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        etUsername.setError(<span class="string">"username error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswordError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        etPasswrod.setError(<span class="string">"password error"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> etUsername.getText().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> etPasswrod.getText().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//start act Main</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"login success"</span>, Toast.LENGTH_SHORT);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.bt_clear:</span><br><span class="line">                mLoginPresenter.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.bt_enter:</span><br><span class="line">                mLoginPresenter.doLogin(etUsername.getText().toString(),</span><br><span class="line">                        etPasswrod.getText().toString());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLoginPresenter.onDestroy();</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码地址<br><a href="https://github.com/xuyushi/AndroidMVPDemo" target="_blank" rel="external">https://github.com/xuyushi/AndroidMVPDemo</a></p>
<h1 id="参考">参考</h1><blockquote>
<ul>
<li><a href="https://segmentfault.com/a/1190000003927200" target="_blank" rel="external">https://segmentfault.com/a/1190000003927200</a></li>
<li><a href="http://www.jianshu.com/p/8ca27934c6e6" target="_blank" rel="external">http://www.jianshu.com/p/8ca27934c6e6</a></li>
<li><a href="http://rocko.xyz/2015/02/06/Android中的MVP/" target="_blank" rel="external">http://rocko.xyz/2015/02/06/Android中的MVP/</a></li>
<li><a href="http://antonioleiva.com/mvp-android/" target="_blank" rel="external">http://antonioleiva.com/mvp-android/</a></li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>MVP模式的核心思想：</p>
<blockquote>
<p>MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成功接口，Model类还是原来的Model。</p>
</blockquote>
<h2 id="MVC">MVC</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14566254770300.png" alt=""></p>
<ul>
<li>其中View层其实就是程序的UI界面，用于向用户展示数据以及接收用户的输入</li>
<li>而Model层就是JavaBean实体类，用于保存实例数据</li>
<li>Controller控制器用于更新UI界面和数据实例</li>
</ul>
<p>View层接受用户的输入，然后通过Controller修改对应的Model实例；同时，当Model实例的数据发生变化的时候，需要修改UI界面，可以通过Controller更新界面。View层也可以直接更新Model实例的数据，而不用每次都通过Controller，这样对于一些简单的数据更新工作会变得方便许多。</p>
<h2 id="MVP">MVP</h2><p>MVP与MVC最不同的一点是<strong>M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层</strong><br>]]>
    
    </summary>
    
      <category term="MVP" scheme="http://yoursite.com/tags/MVP/"/>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代理模式 Proxy Pattern]]></title>
    <link href="http://yoursite.com/2016/02/23/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/23/代理模式/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-28T07:05:05.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="代理模式_Proxy_Pattern">代理模式 Proxy Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。</p>
<h2 id="使用场景">使用场景</h2></blockquote>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562373472577.png" alt=""></p>
<p>Subject: 抽象主题角色<br>Proxy: 代理主题角色<br>RealSubject: 真实主题角色</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(RealSubject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();</span><br><span class="line">        afterRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Proxy afterRequest"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Proxy preRequest"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProxyMain RUNNING</span><br><span class="line">Proxy preRequest</span><br><span class="line">RealSubject request</span><br><span class="line">Proxy afterRequest</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562381345397.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li>
<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对真实对象的使用权限。</li>
</ul>
</li>
<li>缺点<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象 真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li>
<li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/proxy.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/proxy.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="代理模式_Proxy_Pattern">代理模式 Proxy Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。</p>
<h2 id="使用场景">使用场景</h2></blockquote>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562373472577.png" alt=""></p>
<p>Subject: 抽象主题角色<br>Proxy: 代理主题角色<br>RealSubject: 真实主题角色</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[组合模式 Composite Pattern]]></title>
    <link href="http://yoursite.com/2016/02/23/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/23/组合模式/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-28T07:04:42.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="组合模式_Composite_Pattern">组合模式 Composite Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。</p>
<h2 id="使用场景">使用场景</h2></blockquote>
<ul>
<li>需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li>
<li>让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562390427827.png" alt=""></p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"no add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"no remove"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"no getChild"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafOne</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LeafOne operation"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTwo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LeafTwo operation"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(List&lt;Component&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Component component:list) &#123;</span><br><span class="line">            component.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        list.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        list.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CompositeMain RUNNING"</span>);</span><br><span class="line">        Component leafOne = <span class="keyword">new</span> LeafOne();</span><br><span class="line">        Component leafTwo = <span class="keyword">new</span> LeafTwo();</span><br><span class="line">        Component composite = <span class="keyword">new</span> Composite(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        composite.add(leafOne);</span><br><span class="line">        composite.add(leafTwo);</span><br><span class="line">        Component root = <span class="keyword">new</span> Composite(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        root.add(leafOne);</span><br><span class="line">        root.add(leafTwo);</span><br><span class="line">        root.add(composite);</span><br><span class="line">        root.operation();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompositeMain RUNNING</span><br><span class="line">LeafOne operation</span><br><span class="line">LeafTwo operation</span><br><span class="line">LeafOne operation</span><br><span class="line">LeafTwo operation</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562406905352.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</li>
<li>客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</li>
<li>定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</li>
<li>更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</li>
</ul>
</li>
<li>缺点<ul>
<li>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</li>
<li>组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。</li>
<li>组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。</li>
<li><h2 id="参考">参考</h2><blockquote>
<p><a href="http://blog.csdn.net/hguisu/article/details/7530783" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7530783</a><br><a href="http://www.cnblogs.com/chenssy/p/3299719.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/3299719.html</a><br>『head first 设计模式』</p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="组合模式_Composite_Pattern">组合模式 Composite Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。</p>
<h2 id="使用场景">使用场景</h2></blockquote>
<ul>
<li>需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li>
<li>让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562390427827.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[迭代器模式 Iterator Pattern]]></title>
    <link href="http://yoursite.com/2016/02/23/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/23/迭代器模式/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-28T07:05:24.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="迭代器模式_Iterator_Pattern">迭代器模式 Iterator Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>迭代器模式 Iterator Pattern 提供一个方法顺序访问一个聚合对象中的个个元素，而不是暴露其内部的表示</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>需要为聚合对象提供多种遍历方式。</li>
<li>为遍历不同的聚合结构提供一个统一的接口。<h2 id="UML_图">UML 图</h2><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562354344010.jpg" alt=""></li>
</ul>
<p>迭代器角色(Iterator)：迭代器角色负责定义访问和遍历元素的接口。<br>具体迭代器角色(Concrete Iterator)：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。<br>容器角色(Container)：容器角色负责提供创建具体迭代器角色的接口。<br>具体容器角色(Concrete Container)：具体容器角色实现创建具体迭代器角色的接口。这个具体迭代器角色与该容器的结构相关。<br><a id="more"></a></p>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>创建产品抽象类</li>
<li>创建产品族</li>
<li>创建抽象工厂方法，返回产品族</li>
<li>创建具体抽象方法</li>
<li>客户端调用</li>
</ol>
<h4 id="例子">例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = <span class="keyword">this</span>.list.get(cursor++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor == list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj)</span></span>;</span><br><span class="line">     <span class="function">Iterator&lt;T&gt; <span class="title">creatIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">creatIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;T&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"IteratorMain RUN"</span>);</span><br><span class="line">        ConcreteContainer concreteContainer = <span class="keyword">new</span> ConcreteContainer&lt;String&gt;();</span><br><span class="line">        concreteContainer.add(<span class="string">"one"</span>);</span><br><span class="line">        concreteContainer.add(<span class="string">"two"</span>);</span><br><span class="line">        concreteContainer.add(<span class="string">"three"</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = concreteContainer.creatIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String string = iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IteratorMain RUN</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562368813165.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>它支持以不同的方式遍历一个聚合对象。</li>
<li>迭代器简化了聚合类。</li>
<li>在同一个聚合上可以有多个遍历。</li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
</ul>
</li>
<li>缺点<ul>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>迭代器模式提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。</li>
<li>将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。</li>
<li>当使用迭代器的时候，我们依赖聚合提供遍历。</li>
<li>迭代器提供了一个通用的接口，让我们遍历聚合的项，放我们编码使用聚合项时，就可以使用多态机制。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://www.cnblogs.com/chenssy/p/3250409.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/3250409.html</a><br><a href="http://tianli.blog.51cto.com/190322/37644/" target="_blank" rel="external">http://tianli.blog.51cto.com/190322/37644/</a><br><a href="https://sourcemaking.com/design_patterns/iterator" target="_blank" rel="external">https://sourcemaking.com/design_patterns/iterator</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="迭代器模式_Iterator_Pattern">迭代器模式 Iterator Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>迭代器模式 Iterator Pattern 提供一个方法顺序访问一个聚合对象中的个个元素，而不是暴露其内部的表示</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>需要为聚合对象提供多种遍历方式。</li>
<li>为遍历不同的聚合结构提供一个统一的接口。<h2 id="UML_图">UML 图</h2><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562354344010.jpg" alt=""></li>
</ul>
<p>迭代器角色(Iterator)：迭代器角色负责定义访问和遍历元素的接口。<br>具体迭代器角色(Concrete Iterator)：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。<br>容器角色(Container)：容器角色负责提供创建具体迭代器角色的接口。<br>具体容器角色(Concrete Container)：具体容器角色实现创建具体迭代器角色的接口。这个具体迭代器角色与该容器的结构相关。<br>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[模板方法模式 Template Method Pattern]]></title>
    <link href="http://yoursite.com/2016/02/23/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/23/模板方法模式/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-28T07:05:48.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="模板方法模式_Template_Method_Pattern">模板方法模式 Template Method Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>模板方法模式定义了一个算法的步骤，并允许次类别为一个或多个步骤提供其实践方式。让次类别在不改变算法架构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一次性实现一个算法的不变部分，把变化部分留给子类去实现。</li>
<li>各子类间的共同行为需要被提取并集中到一个共同的类中来避免代码的重复。你首先识别出这些现有代码的不同之处，然后把这些不同之处分离到新的操作中。最后，你用一个模板方法调用这些新操作之一来替代原有那些不同的代码。</li>
<li>控制子类扩展。你能定义一个只在特定点调用 hook 操作的模板方法，以此只允许子类在这些点扩展。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562265059090.jpg" alt=""></p>
<p>AbstractTemplate：抽象模板</p>
<ul>
<li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li>
<li>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
</ul>
<p>ConcreteTemplate：具体实现</p>
<ul>
<li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li>
<li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">temlateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abstractMethod();</span><br><span class="line">        <span class="keyword">if</span> (hoodMethod()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"hook"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"unhook"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        concreteMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">concreteMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AbstractTemplate concreteMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hoodMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteTemplate abstractMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hoodMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TemplateMethodMain RUNNING"</span>);</span><br><span class="line">        ConcreteTemplate concreteTemplate = <span class="keyword">new</span> ConcreteTemplate();</span><br><span class="line">        concreteTemplate.temlateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemplateMethodMain RUNNING</span><br><span class="line">ConcreteTemplate abstractMethod</span><br><span class="line">hook</span><br><span class="line">AbstractTemplate concreteMethod</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562265190124.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>实现了代码复用</li>
<li>能够灵活应对子步骤的变化，符合开放-封闭原则</li>
</ul>
</li>
<li>缺点<ul>
<li>因为引入了一个抽象类，如果具体实现过多的话，需要用户或开发人员需要花更多的时间去理清类之间的关系    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>封装不变部分，扩展可变部分。把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。</li>
<li>提取公共部分代码，便于维护</li>
<li>基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。<ul>
<li>抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。<ul>
<li>具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。</li>
</ul>
</li>
<li>钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。</li>
</ul>
</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/模板方法" target="_blank" rel="external">https://zh.wikipedia.org/wiki/模板方法</a><br><a href="http://dreamrunner.org/blog/2014/05/04/浅谈设计模式10/" target="_blank" rel="external">http://dreamrunner.org/blog/2014/05/04/浅谈设计模式10/</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="模板方法模式_Template_Method_Pattern">模板方法模式 Template Method Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>模板方法模式定义了一个算法的步骤，并允许次类别为一个或多个步骤提供其实践方式。让次类别在不改变算法架构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一次性实现一个算法的不变部分，把变化部分留给子类去实现。</li>
<li>各子类间的共同行为需要被提取并集中到一个共同的类中来避免代码的重复。你首先识别出这些现有代码的不同之处，然后把这些不同之处分离到新的操作中。最后，你用一个模板方法调用这些新操作之一来替代原有那些不同的代码。</li>
<li>控制子类扩展。你能定义一个只在特定点调用 hook 操作的模板方法，以此只允许子类在这些点扩展。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14562265059090.jpg" alt=""></p>
<p>AbstractTemplate：抽象模板</p>
<ul>
<li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li>
<li>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
</ul>
<p>ConcreteTemplate：具体实现</p>
<ul>
<li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li>
<li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[命令模式 Command Pattern]]></title>
    <link href="http://yoursite.com/2016/02/22/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/22/命令模式/</id>
    <published>2016-02-22T14:26:00.000Z</published>
    <updated>2016-02-28T07:06:57.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="命令模式_Command_Pattern">命令模式 Command Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
<li>系统需要将一组操作组合在一起，即支持宏命令</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561465850883.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tunOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Light tun On"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tunOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Light tun Off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.tunOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.tunOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command.excute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommandMain RUNNING"</span>);</span><br><span class="line">        System.out.println(<span class="string">"----"</span>);</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        Command commandOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(commandOn);</span><br><span class="line">        invoker.call();</span><br><span class="line">        System.out.println(<span class="string">"----"</span>);</span><br><span class="line">        Command commandOff = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line">        invoker.setCommand(commandOff);</span><br><span class="line">        invoker.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CommandMain RUNNING</span><br><span class="line">----</span><br><span class="line">Light tun On</span><br><span class="line">----</span><br><span class="line">Light tun Off</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561474668159.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>降低系统的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li>
<li>可以方便地实现对请求的Undo和Redo。</li>
</ul>
</li>
<li>缺点<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。<h2 id="总结">总结</h2></li>
</ul>
</li>
<li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li>
<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li>
<li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="https://sourcemaking.com/design_patterns/command" target="_blank" rel="external">https://sourcemaking.com/design_patterns/command</a><br><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="命令模式_Command_Pattern">命令模式 Command Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
<li>系统需要将一组操作组合在一起，即支持宏命令</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561465850883.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单例模式 Singleton Pattern]]></title>
    <link href="http://yoursite.com/2016/02/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/22/单例模式/</id>
    <published>2016-02-22T13:34:00.000Z</published>
    <updated>2016-02-22T12:57:46.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="单例模式_Singleton_Pattern">单例模式 Singleton Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li>
</ul>
<h2 id="简单实现">简单实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/22.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能</li>
</ul>
</li>
<li>缺点<ul>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；<strong>为了防止在外部对其实例化，将其构造函数设计为私有</strong>。</li>
<li>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</li>
<li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li>
<li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="单例模式_Singleton_Pattern">单例模式 Singleton Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>单例模式(Singleton Pattern)：单例模式确保某一个]]>
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[适配器模式 Adapter Pattern]]></title>
    <link href="http://yoursite.com/2016/02/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/22/适配器模式/</id>
    <published>2016-02-21T16:00:00.000Z</published>
    <updated>2016-02-28T07:06:44.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="适配器模式_Adapter_Pattern">适配器模式 Adapter Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h2 id="使用场景">使用场景</h2></blockquote>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561482662486.png" alt=""></p>
<p>Target：目标抽象类<br>Adapter：适配器类<br>Adaptee：适配者类<br>Client：客户类</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sepecialRequset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee SepecialRequset"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.sepecialRequset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AdapterMain RUNNING"</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AdapterMain RUNNING</span><br><span class="line">Adaptee SepecialRequset</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561492070442.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li><p>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
</li>
<li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li>
<li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li>
<li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</li>
<li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/adapter.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/adapter.html</a><br><a href="https://sourcemaking.com/design_patterns/adapter" target="_blank" rel="external">https://sourcemaking.com/design_patterns/adapter</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="适配器模式_Adapter_Pattern">适配器模式 Adapter Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h2 id="使用场景">使用场景</h2></blockquote>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561482662486.png" alt=""></p>
<p>Target：目标抽象类<br>Adapter：适配器类<br>Adaptee：适配者类<br>Client：客户类</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[外观模式 Facade Pattern]]></title>
    <link href="http://yoursite.com/2016/02/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/22/外观模式/</id>
    <published>2016-02-21T16:00:00.000Z</published>
    <updated>2016-02-28T07:06:09.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="外观模式_Facade_Pattern">外观模式 Facade Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li>
<li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561498047745.png" alt=""></p>
<p>Facade: 外观角色<br>SubSystem:子系统角色</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SystemA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SystemB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SystemC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SystemA systemA;</span><br><span class="line">    <span class="keyword">private</span> SystemB systemB;</span><br><span class="line">    <span class="keyword">private</span> SystemC systemC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">(SystemA systemA, SystemB systemB, SystemC systemC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.systemA = systemA;</span><br><span class="line">        <span class="keyword">this</span>.systemB = systemB;</span><br><span class="line">        <span class="keyword">this</span>.systemC = systemC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        systemA.operationA();</span><br><span class="line">        systemB.operationB();</span><br><span class="line">        systemC.operationC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FacadeMain RUNNING"</span>);</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade(<span class="keyword">new</span> SystemA(), <span class="keyword">new</span> SystemB(), <span class="keyword">new</span> SystemC());</span><br><span class="line">        facade.operation();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FacadeMain RUNNING</span><br><span class="line">SystemA</span><br><span class="line">SystemB</span><br><span class="line">SystemC</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561508985872.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li>
<li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li>
<li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
<li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li>
</ul>
</li>
<li>缺点<ul>
<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li>
<li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li>
<li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li>
<li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
<li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/facade.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/facade.html</a><br><a href="https://sourcemaking.com/design_patterns/facade" target="_blank" rel="external">https://sourcemaking.com/design_patterns/facade</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="外观模式_Facade_Pattern">外观模式 Facade Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li>
<li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14561498047745.png" alt=""></p>
<p>Facade: 外观角色<br>SubSystem:子系统角色</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抽象工厂模式 Abstract Factory Pattern]]></title>
    <link href="http://yoursite.com/2016/02/21/hello-world/"/>
    <id>http://yoursite.com/2016/02/21/hello-world/</id>
    <published>2016-02-21T14:26:00.000Z</published>
    <updated>2016-02-28T07:07:47.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="抽象工厂模式_Abstract_Factory_Pattern">抽象工厂模式 Abstract Factory Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>抽象工厂模式 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560648848499.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>创建产品抽象类</li>
<li>创建产品族</li>
<li>创建抽象工厂方法，返回产品族</li>
<li>创建具体抽象方法</li>
<li>客户端调用</li>
</ol>
<h4 id="例子">例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA1 useA1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA2 useA2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB1 useB1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB2 useB2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductA <span class="title">crateProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ProductB <span class="title">crateProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryOne</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">crateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">crateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTwo</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">crateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">crateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AbstractFactoryMain RUNNING"</span>);</span><br><span class="line"></span><br><span class="line">        AbstractFactory factory = <span class="keyword">new</span> FactoryOne();</span><br><span class="line">        factory.crateProductA().useA();</span><br><span class="line">        factory.crateProductB().useB();</span><br><span class="line">        System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">        factory = <span class="keyword">new</span> FactoryTwo();</span><br><span class="line">        factory.crateProductA().useA();</span><br><span class="line">        factory.crateProductB().useB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractFactoryMain RUNNING</span><br><span class="line">ProductA1 useA1</span><br><span class="line">ProductB1 useB1</span><br><span class="line">-------</span><br><span class="line">ProductA2 useA2</span><br><span class="line">ProductB2 useB2</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560664362988.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够<strong>保证客户端始终只使用同一个产品族中的对象</strong>。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
</li>
<li>缺点<ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
<li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</li>
<li>抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li>
<li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对<strong>多个产品等级结构</strong>。</li>
<li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
<li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="抽象工厂模式_Abstract_Factory_Pattern">抽象工厂模式 Abstract Factory Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>抽象工厂模式 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560648848499.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抽象工厂模式 Abstract Factory Pattern]]></title>
    <link href="http://yoursite.com/2016/02/21/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/21/抽象工厂模式/</id>
    <published>2016-02-21T14:26:00.000Z</published>
    <updated>2016-02-21T14:55:48.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="抽象工厂模式_Abstract_Factory_Pattern">抽象工厂模式 Abstract Factory Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>抽象工厂模式 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="/media/14560648848499.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>创建产品抽象类</li>
<li>创建产品族</li>
<li>创建抽象工厂方法，返回产品族</li>
<li>创建具体抽象方法</li>
<li>客户端调用</li>
</ol>
<h4 id="例子">例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA1 useA1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA2 useA2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB1 useB1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB2 useB2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductA <span class="title">crateProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ProductB <span class="title">crateProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryOne</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">crateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">crateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTwo</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">crateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">crateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AbstractFactoryMain RUNNING"</span>);</span><br><span class="line"></span><br><span class="line">        AbstractFactory factory = <span class="keyword">new</span> FactoryOne();</span><br><span class="line">        factory.crateProductA().useA();</span><br><span class="line">        factory.crateProductB().useB();</span><br><span class="line">        System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">        factory = <span class="keyword">new</span> FactoryTwo();</span><br><span class="line">        factory.crateProductA().useA();</span><br><span class="line">        factory.crateProductB().useB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractFactoryMain RUNNING</span><br><span class="line">ProductA1 useA1</span><br><span class="line">ProductB1 useB1</span><br><span class="line">-------</span><br><span class="line">ProductA2 useA2</span><br><span class="line">ProductB2 useB2</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="/media/14560664362988.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够<strong>保证客户端始终只使用同一个产品族中的对象</strong>。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
</li>
<li>缺点<ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
<li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。    <h2 id="总结">总结</h2></li>
</ul>
</li>
<li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</li>
<li>抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li>
<li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对<strong>多个产品等级结构</strong>。</li>
<li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
<li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/abstract_factory.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="抽象工厂模式_Abstract_Factory_Pattern">抽象工厂模式 Abstract Factory Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>抽象工厂模式 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="/media/14560648848499.png" alt=""></p>
<p>AbstractFactory：抽象工厂<br>ConcreteFactory：具体工厂<br>AbstractProduct：抽象产品<br>Product：具体产品</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[工厂方法模式 Factory Method Pattern]]></title>
    <link href="http://yoursite.com/2016/02/21/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/21/工厂方法模式/</id>
    <published>2016-02-21T13:46:00.000Z</published>
    <updated>2016-02-21T14:24:27.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="工厂方法模式_Factory_Method_Pattern">工厂方法模式 Factory Method Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即<strong>通过工厂子类来确定究竟应该实例化哪一个具体产品类</strong>（并不是指子类本身在运行时做决定，而是编写者在创建类时，不需要知道实际的创建产品的类型，选择了使用哪个子类自然决定了实际的创建产品类型）。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务 给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="/media/14560634114616.png" alt=""></p>
<p>Product：抽象产品<br>ConcreteProduct：具体产品<br>Factory：抽象工厂<br>ConcreteFactory：具体工厂，实现了实际造出产品的方法</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>定义 Product 抽象类 或者接口</li>
<li>实现具体Product</li>
<li>实现抽象 Factory </li>
<li>具体实现Factory</li>
<li>客户端调用Factory构造需要的对象</li>
</ol>
<h4 id="例子">例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> IProduct <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function">IProduct <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FactoryMethodMain RUNNING"</span>);</span><br><span class="line">        Factory factory = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        IProduct product = factory.createProduct();</span><br><span class="line">        product.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FactoryMethodMain RUNNING</span><br><span class="line">ProductA use</span><br></pre></td></tr></table></figure>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
</li>
<li>缺点<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。    </li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2><ul>
<li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li>
<li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li>
<li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li>
<li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
<li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。 </li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/factory_method.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/factory_method.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="工厂方法模式_Factory_Method_Pattern">工厂方法模式 Factory Method Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即<strong>通过工厂子类来确定究竟应该实例化哪一个具体产品类</strong>（并不是指子类本身在运行时做决定，而是编写者在创建类时，不需要知道实际的创建产品的类型，选择了使用哪个子类自然决定了实际的创建产品类型）。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务 给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="/media/14560634114616.png" alt=""></p>
<p>Product：抽象产品<br>ConcreteProduct：具体产品<br>Factory：抽象工厂<br>ConcreteFactory：具体工厂，实现了实际造出产品的方法</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[工厂模式 Factory  Pattern]]></title>
    <link href="http://yoursite.com/2016/02/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/21/工厂模式/</id>
    <published>2016-02-21T13:10:00.000Z</published>
    <updated>2016-02-28T07:09:17.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="简单工厂模式">简单工厂模式</h1><h2 id="定义">定义</h2><blockquote>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560604563955.png" alt=""></p>
<p>Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑</p>
<p>Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>
<p>ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>定义 Product 抽象类 或者接口</li>
<li>实现具体Product</li>
<li>实现 Factory ，根据传入的参数，创造不同的对象</li>
<li>客户端调用Factory构造需要的对象</li>
</ol>
<h4 id="例子">例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB use"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA use"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB use"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IProduct <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"B"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleFactoryMain RUNNING"</span>);</span><br><span class="line">        IProduct product = Factory.createProduct(<span class="string">"A"</span>);</span><br><span class="line">        product.use();</span><br><span class="line">        product = Factory.createProduct(<span class="string">"B"</span>);</span><br><span class="line">        product.use();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleFactoryMain RUNNING</span><br><span class="line">ProductA use</span><br><span class="line">ProductB use</span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560618582365.png" alt=""></p>
<h2 id="优缺点">优缺点</h2><ul>
<li>优点<ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
</li>
<li>缺点<ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。    </li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2><ul>
<li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li>
<li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li>
<li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>
<li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li>
<li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li>
<li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。 <h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/simple_factory.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/simple_factory.html</a><br><a href="https://sourcemaking.com/design_patterns/decorator" target="_blank" rel="external">https://sourcemaking.com/design_patterns/decorator</a><br>『head first 设计模式』</p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="简单工厂模式">简单工厂模式</h1><h2 id="定义">定义</h2><blockquote>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560604563955.png" alt=""></p>
<p>Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑</p>
<p>Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>
<p>ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[装饰者模式 Decorator Design Pattern]]></title>
    <link href="http://yoursite.com/2016/02/21/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/21/装饰者模式/</id>
    <published>2016-02-21T02:23:55.000Z</published>
    <updated>2016-02-28T07:09:49.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="装饰者模式_Decorator_Design_Pattern">装饰者模式 Decorator Design Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p><strong>装饰者模式</strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更具有弹性的替代方案，其别名也可以称为包装器(Wrapper） </p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560246781613.png" alt=""></p>
<p>Component: 抽象构件<br>ConcreteComponent: 具体构件<br>Decorator: 抽象装饰类<br>ConcreteDecorator: 具体装饰类</p>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>定义装饰的接口</li>
<li>实现抽象装饰类</li>
<li>实现具体装饰类</li>
<li>实现被装饰对象</li>
<li>客户端调用<ol>
<li>实例化被装饰对象</li>
<li>用装饰类装饰这个对象 </li>
</ol>
</li>
</ol>
<h3 id="例子">例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component inner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component inner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inner = inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inner.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorA</span><span class="params">(Component inner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doIt();</span><br><span class="line">        doA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Doit,DO A!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorB</span><span class="params">(Component inner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doB();</span><br><span class="line">        <span class="keyword">super</span>.doIt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Do it,DO B!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteComponent Doit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/21.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DecoratorMain RUNNING"</span>);</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        ConcreteComponent concreteComponent = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        DecoratorA decoratorA = <span class="keyword">new</span> DecoratorA(concreteComponent);</span><br><span class="line">        decoratorA.doIt();</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        DecoratorB decoratorB = <span class="keyword">new</span> DecoratorB(concreteComponent);</span><br><span class="line">        decoratorB.doIt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DecoratorMain RUNNING</span><br><span class="line">------------</span><br><span class="line">ConcreteComponent Doit</span><br><span class="line">After Doit,DO A!</span><br><span class="line">------------</span><br><span class="line">Before Do it,DO B!</span><br><span class="line">ConcreteComponent Doit</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="类图">类图</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560300740064.png" alt=""></p>
<h2 id="总结">总结</h2><ul>
<li>优点<ul>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li>
</ul>
</li>
<li>缺点<ul>
<li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li>
</ul>
</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/decorator.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/structural_patterns/decorator.html</a><br><a href="https://sourcemaking.com/design_patterns/decorator" target="_blank" rel="external">https://sourcemaking.com/design_patterns/decorator</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="装饰者模式_Decorator_Design_Pattern">装饰者模式 Decorator Design Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p><strong>装饰者模式</strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更具有弹性的替代方案，其别名也可以称为包装器(Wrapper） </p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-28-14560246781613.png" alt=""></p>
<p>Component: 抽象构件<br>ConcreteComponent: 具体构件<br>Decorator: 抽象装饰类<br>ConcreteDecorator: 具体装饰类</p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[观察者模式 Observer Design Pattern]]></title>
    <link href="http://yoursite.com/2016/02/20/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/20/观察者模式/</id>
    <published>2016-02-20T14:07:55.000Z</published>
    <updated>2016-02-20T14:22:00.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="观察者模式_Observer_Design_Pattern">观察者模式 Observer Design Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会受到通知并自动更新</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ol>
<li>对象之间的一对多依赖。一个对象状态的更新时，其他对象需要自动更新，而且其他对象的数量动态可变。（注册、反注册） </li>
<li>对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。 (解耦)</li>
<li>MVC 中的 View 层实现</li>
</ol>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14559766489224.png" alt=""></p>
<a id="more"></a>
<ul>
<li>Observable:<strong>抽象主题</strong>，抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</li>
<li>Message:具体被观察对象</li>
<li>Observer :<strong>抽象观察者</strong>,为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</li>
<li>是接口，MailA/MailB 分布实现了这个接口，Observable中持有 Observer，当数据发生变化时，调用 update()接口</li>
</ul>
<h2 id="简单实现">简单实现</h2><h3 id="步骤">步骤</h3><ol>
<li>定义Observer接口</li>
<li>具体类实现Observer接口</li>
<li>定义 Observable 接口，其中定义增加和删除观察者、通知观察者等接口</li>
<li>在需要被观察对象中实现Subject接口</li>
<li>客户端使用时 需要注册观察者</li>
</ol>
<h3 id="例子">例子</h3><p>定义Observer接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 15/11/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体类实现Observer接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 15/11/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailA</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mail A receive:"</span> + message.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MailA</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        message.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.xuyushi.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 15/11/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailB</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mail B receive:"</span>+ message.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MailB</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        message.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 Observable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 15/11/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要被观察对象中实现Subject接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 15/11/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(observer);</span><br><span class="line">        observers.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.updata();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 15/11/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ObserverMain RUN"</span>);</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        MailA mailA = <span class="keyword">new</span> MailA(message);</span><br><span class="line">        MailB mailB = <span class="keyword">new</span> MailB(message);</span><br><span class="line">        message.setMsg(<span class="string">"new message"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"unregistered MailB"</span>);</span><br><span class="line">        message.deleteObserver(mailB);</span><br><span class="line">        message.setMsg(<span class="string">"after unregistered MailB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObserverMain RUN</span><br><span class="line">Mail A receive:new message</span><br><span class="line">Mail B receive:new message</span><br><span class="line">unregistered MailB</span><br><span class="line">Mail A receive:after unregistered MailB</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><ul>
<li>观察者模式的优点： <ol>
<li>Subject和Observer之间是松偶合的，分别可以各自独立改变。 </li>
<li>Subject在发送广播通知的时候，无须指定具体的Observer，Observer可以自己决定是否要订阅Subject的通知。 </li>
<li>遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。 </li>
</ol>
</li>
<li>观察者模式的缺陷： <ol>
<li>松偶合导致代码关系不明显，有时可能难以理解。(废话) </li>
<li>如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。（毕竟只是简单的遍历） </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ol>
</li>
<li>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="https://sourcemaking.com/design_patterns/observer" target="_blank" rel="external">https://sourcemaking.com/design_patterns/observer</a><br><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a><br><a href="http://design-patterns.readthedocs.org/zh_CN/latest/behavioral_patterns/observer.html" target="_blank" rel="external">http://design-patterns.readthedocs.org/zh_CN/latest/behavioral_patterns/observer.html</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="观察者模式_Observer_Design_Pattern">观察者模式 Observer Design Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会受到通知并自动更新</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ol>
<li>对象之间的一对多依赖。一个对象状态的更新时，其他对象需要自动更新，而且其他对象的数量动态可变。（注册、反注册） </li>
<li>对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。 (解耦)</li>
<li>MVC 中的 View 层实现</li>
</ol>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14559766489224.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[策略模式 Strategy Pattern]]></title>
    <link href="http://yoursite.com/2016/02/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/17/策略模式/</id>
    <published>2016-02-17T13:26:55.000Z</published>
    <updated>2016-02-20T14:22:01.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="策略模式_Strategy_Pattern">策略模式 Strategy Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p><strong>策略模式</strong>定义了算法簇，分别封装起来，让它们之间可以互相替代，此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象多个子类，而又需要使用if-else 或者 switch-case来选择时。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14557164239727.png" alt=""></p>
<ul>
<li>Context：用来操作策略的上下文环境。</li>
<li>Strategy : 策略的抽象</li>
<li>ImplementationOne、ImplementationTwo：具体策略的实现</li>
</ul>
<a id="more"></a>
<h2 id="简单实现">简单实现</h2><p>通常如果一个问题有多个解决方案或者稍有区别的操作时，最简单的方式就是利用if-else or switch-case方式来解决，对于简单的解决方案这样做无疑是比较简单、方便、快捷的，但是如果解决方案中包括大量的处理逻辑需要封装，或者处理方式变动较大的时候则就显得混乱、复杂，而策略模式则很好的解决了这样的问题，它将各种方案分离开来，让操作者根据具体的需求来动态的选择不同的策略方案。</p>
<h3 id="步骤">步骤</h3><ol>
<li>定义Strategy接口</li>
<li>具体的算法 实现Strategy接口</li>
<li>客户端调用Strategy接口</li>
</ol>
<h3 id="例子">例子</h3><p>定义Strategy接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的算法 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is StrategyA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        wrapper.setState(<span class="keyword">new</span> StateC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        wrapper.setState(<span class="keyword">new</span> StateA());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 context</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/2/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">strategyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StateMain RUNNING"</span>);</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        context.doStrategy();</span><br><span class="line">        context.setStrategy(<span class="keyword">new</span> StrategyB());</span><br><span class="line">        context.doStrategy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StateMain RUNNING</span><br><span class="line">This is StrategyA</span><br><span class="line">This is StrategyB</span><br></pre></td></tr></table></figure>
<p>例子的 UML 图 </p>
<p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14557189438038.png" alt=""></p>
<h2 id="总结">总结</h2><p>策略模式主要用来分离算法，根据相同的行为抽象来做不同的具体策略实现。<br>通过以上也可以看出策略模式的优缺点：<br><strong>优点：</strong></p>
<ul>
<li>结构清晰明了、使用简单直观。</li>
<li>耦合度相对而言较低，扩展方便。</li>
<li>操作封装也更为彻底，数据更为安全。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>随着策略的增加，子类也会变得繁多。</li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p><a href="https://sourcemaking.com/design_patterns/strategy" target="_blank" rel="external">https://sourcemaking.com/design_patterns/strategy</a><br><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/strategy/gkerison" target="_blank" rel="external">https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/strategy/gkerison</a><br>『head first 设计模式』</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="策略模式_Strategy_Pattern">策略模式 Strategy Pattern</h1><h2 id="定义">定义</h2><blockquote>
<p><strong>策略模式</strong>定义了算法簇，分别封装起来，让它们之间可以互相替代，此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<h2 id="使用场景">使用场景</h2><ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象多个子类，而又需要使用if-else 或者 switch-case来选择时。</li>
</ul>
<h2 id="UML_图">UML 图</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-20-14557164239727.png" alt=""></p>
<ul>
<li>Context：用来操作策略的上下文环境。</li>
<li>Strategy : 策略的抽象</li>
<li>ImplementationOne、ImplementationTwo：具体策略的实现</li>
</ul>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015小结]]></title>
    <link href="http://yoursite.com/2016/02/04/2015summarize/"/>
    <id>http://yoursite.com/2016/02/04/2015summarize/</id>
    <published>2016-02-04T15:22:55.000Z</published>
    <updated>2016-02-06T05:34:07.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]<br>I</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=1141940&auto=1&height=66"></iframe>

<h1 id="2015小结">2015小结</h1><p>　　2015算是自己人生中又一个分水岭，过了除夕才是过完中国的一年，赶在除夕之前整理下自己的2015。</p>
<h2 id="工作">工作</h2><p>　　在学校做硬件 -&gt; 实习做驱动 -&gt; 离开了校园 -&gt; 迈入职场-&gt; Android APP 开发<br>　　<br>　　这一年在技术上的成长自己还是很满意的</p>
<h3 id="流水账">流水账</h3><p>　　2015年初，从美团实习完回学校之后就发觉对 Android 有浓厚的兴趣，考虑到后续工作可能接触到 Android 相关的工作，2015年出开始自学 Java 和 Android，抱着『第一行代码』走了一遍，对 Android 有了初步的认识。之后忙毕业一直到了6月。</p>
<p>　　6月正式入职之后，最初是被分配在了 MTK 平台那边，并不和 Android 相关，主动找了桥哥和栋哥商量，调到了 Android 开发，美团这一点还是挺人性的，尊重员工的意愿。还好有申燊同学带着，一步一步开始了 Android 之旅。</p>
<p>　　第一个项目是做的小美接单，当样机拼装完成，成功打印的那一刻还是挺有成就感的。<br>　　<br>　　　<a id="more"></a></p>
<p>　　之后部门变动，有两个选择，1. 和以前的同事一起去望京 SOHO 继续在硬件组做 Android 相关的开发。 2. 留在外卖，去B端开发 。 对于一个处女座来说真的很难抉择。感谢少鹏哥和国良哥此时给我的建议,最终留在了外卖，目前看来这对于希望在 Android 方向上发展无疑是个更好的决定</p>
<p>　　在来 B端之前，基本上是和申燊两人在摸黑开发，代码毫无规范可言，写完之后一堆 bug，两个应届生没有人指导。来了 B 端这边才见到了正规军。ヾ(｡｀Д´｡) 原来 git 是这么耍的！原来编程要考虑这么多细节！原来代码还需要 review！原来产品发布还有个叫灰度的过程！<br>　　<br>　　感谢广伟哥的指导，在 Android 的路上逐渐步入正轨<br>　　<br>　　…..
　　</p>
<h3 id="新技能_get">新技能 get</h3><ul>
<li><p>经过被 git 坑过几次之后，静下来把 git 好好整了一遍，发现 git 真是神器啊。有了 git 就不会出现这样的情况了<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546022908172.jpg" alt=""></p>
</li>
<li><p><strong>Android 基础知识</strong>。阅读了几本入门书籍，磕磕盼盼的看完了官方文档，阅读了大牛的博客，Android 的基本知识点大部分都过了一遍</p>
</li>
<li><strong>java 基础知识</strong>。最开始开始把 java 当 c 来写，没有建立起面向对象的编程思想。直到阅读了『first head 设计模式』，读完之后感慨，原来 Java 是这么玩的，我以前写的是shi么？？</li>
<li><strong>设计模式</strong> 。其实我之前是拒绝的，但是现在对此着了魔似得。设计模式确实对项目的整体结构，和之后的扩展有很大的好处，把常用的模式全部阅读了一遍，也在项目中用到了几个。准备后续将知识点继续总结一遍</li>
<li><strong>Android 开源框架</strong> volley 、 eventbus、Gson… 在使用阶段，未对项目源码进一步分析</li>
<li><strong>自定义view </strong> 一直觉得自定义 view 很神奇，但是项目中却一直没有机会实战用到，自己写了几个自定义view，并在后期的项目中重构了 FlowLayout，初步了掌握了自定义 view</li>
<li><strong>Android 性能优化</strong><ol>
<li>内存：get ，整理了一篇博文，目前最满意的一篇博文</li>
<li>电量：no</li>
<li>view：no</li>
</ol>
</li>
<li><strong>java 高级用法</strong><ol>
<li><strong>注解</strong>。 3.5版 重构数据库中用到了注解，很神奇的玩意，<strong>新技能 get</strong></li>
<li><strong>反射</strong> 当一些系统 framework 接口没有暴露出来的时候，可以使用反射，百试不爽，<strong>新技能 get</strong></li>
</ol>
</li>
<li><strong>Android 源码阅读</strong>。阅读了view 事件传递 和 message 、handler 的源码，阅读的过程中还是比较吃力的，需要借助一些大牛的博客来阅读</li>
</ul>
<h3 id="发现的不足">发现的不足</h3><ol>
<li>光看书看博文是效果不大的，很容易忘记，没有融入到自己的的知识体系中。要多实践多实践多实践、把看过的东西运行在项目中，项目中用不到的自己最好写个 demo，并整理到 wiki，方便下次快速拾起</li>
<li>切勿眼高手低，觉得挺简单的事情，做起来发现和想象并不是一回事</li>
<li>切勿吃着碗里的看着锅里的，想学的太多，囫囵吞枣，什么都看了一圈，到头来发现什么都没学会，一定要沉下心来</li>
<li>之前学习整理过的知识点，长时间不用也会忘记。定期对整理过的知识点复习</li>
<li>从6月到现在，学习曲线越来越缓。从最开始每天都觉得可以学到很多很多，到现在需要自己主动去发现才能get 到新技能</li>
<li>阅读了官方文档之后才发现在国内的一些博客中会有一些错误，尽量阅读官方文档，和国内外大牛的博客</li>
<li>总结能力不够。 写出来的东西总不能把想法有条理性的全部表达出来</li>
</ol>
<h3 id="展望">展望</h3><ol>
<li>学习过的知识点全部做记录整理，并定期对已学习的知识点回顾，吸收进自己的知识体系</li>
<li>Android 性能优化的学习</li>
<li>java 的后续学习</li>
<li>Android 属性动画、进程间通信、四大组件源码、view 源码的学习</li>
<li>设计模式的学习</li>
<li>算法</li>
<li>React Native 探索</li>
<li>MVP MVVC 学习</li>
</ol>
<h2 id="读书">读书</h2><p>2015年大部分书籍都是专业相关的 ，猿类的气息太浓厚， ╮(╯▽╰)╭ 啥时候能提高一下文艺范</p>
<h3 id="第一行代码">第一行代码</h3><p>推荐指数 ★★★★<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546365237468.png" alt=""></p>
<p>郭林大神的良心之作，作为我的第一本 Android 启蒙教材，写的很详细，完全从一个初级小白的视角切入。</p>
<h3 id="Java从入门到精通">Java从入门到精通</h3><p>推荐指数 ★★<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546366872019.png" alt=""></p>
<p>快速的翻了一遍，介绍的是 java 的基本知识点。例子比较详细，但是都讲的不深</p>
<h3 id="Thinking_in_java">Thinking in java</h3><p>推荐指数 ★★★★★<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546382992597.jpg" alt=""></p>
<p>买这本书的时候比较早，觉得难懂，觉得每一节都有不明白的点，而且内容太多。但是12月再回头看这一本书的时候却发现了很多惊喜点。但是里面有很多内容并不用得上，个人觉得这本书更适合作为一个工具书，遇到不明白的点再回去查询。纯啃完这本书难度还是很大的</p>
<h3 id="clean_code">clean code</h3><p>推荐指数 ★★★<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546369003469.png" alt=""></p>
<p>书本身是不错的，翻译实在是呵呵哒了，在阅读这本书之前，脑子里是没有什么代码规范可言的，想怎么写怎么写。相比于这本书我更推荐下面这本</p>
<h3 id="重构:改善既有代码的设计">重构:改善既有代码的设计</h3><p>推荐指数 ★★★★★<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546374965168.png" alt=""></p>
<p>未读完。神作，现在的 IDE 已经可以很好的辅助重构了，现在我们所需要做的就是，具体只需要了解什么样的 code 是 bad smell，以及如何把这一坨代码重构好。</p>
<h3 id="Head_First_设计模式">Head First 设计模式</h3><p>推荐指数 ★★★★★<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546385126690.jpg" alt=""></p>
<p>作为我的面向对象编程思想的启蒙读物，一边读一遍感叹，原来 java 是这么玩的，之前一直是那写 C 的那些思想在写 java。面向接口编程、对扩展开放对修改关闭、依赖抽象不依赖具体等等面向对象的思想已深入我心</p>
<h3 id="android开发艺术探索">android开发艺术探索</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546388108444.png" alt=""></p>
<p>未读完。良心大作。作为 Android 的进阶读物，作者介绍的全是开发过程中遇到的干货，并从源码的角度来剖析问题。16年会细啃这本书</p>
<h3 id="穷查理宝典：查理·芒格的智慧箴言录">穷查理宝典：查理·芒格的智慧箴言录</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546394300282.jpg" alt=""></p>
<p>投资要素：独立、谦虚、分析、配置、耐心、改变、专注..</p>
<p>不仅仅是关于投资的一本书，改变了我的价值观和思维方式，值得读第二遍</p>
<h3 id="时间的朋友">时间的朋友</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546396393326.jpg" alt=""></p>
<p>罗振宇在2015年底，在水立方进行了一次长达4小时的演讲，拨开迷雾，挖掘表象之后的逻辑。互联网 、资本寒冬、创业、微信、淘宝、妖股….感觉给我打开了一扇窗，重新认识周围的世界</p>
<h2 id="理财">理财</h2><p>私密</p>
<h2 id="爱情？">爱情？</h2><p><strong>汪！汪！汪！</strong></p>
<p>虽然依旧单身，心态却和以前不一样</p>
<ol>
<li><strong>学会了独处</strong>。以前一个人总会觉得无聊、寂寞。现在却很享受一个人的时间，一个人可以看书、可以看电影、可以跑步。完全没有必要因为一个人而孤独寂寞。</li>
<li><strong>知道了自己喜欢的类型</strong></li>
<li><strong>心态</strong> 好多同学都结婚了，有的娃都打酱油了，曾经有一段时间是比较着急的。现在看待这事很淡然。</li>
<li>泡妞技能点已清空，伪学霸技能点加满</li>
</ol>
<h2 id="健身">健身</h2><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546402409879.jpg" alt=""></p>
<p>从2015年6月开始跑步，已经跑了有7个月了，第一次跑步练1km 都没跑下来，到现在能一口气跑半马了。一开始是一想到改跑步了浑身不舒服，现在是几天没跑步了浑身不舒服。</p>
<h3 id="跑步之后的改变">跑步之后的改变</h3><ol>
<li><strong>身体</strong>。肚子前的一小坨肉不见了，身体变得有轮廓了。心肺功能比以前强太多，跑上5km 基本都不怎么喘气。从去年6月跑步都现在没生病过</li>
<li><strong>饮食</strong>。以前从来不会注重吃的健康不健康，只分好吃不好吃。自从跑步之后，无意识的规范了自己的饮食健康，油炸食品和碳酸类音量基本不沾了。每天早点都吃的很丰盛。</li>
<li><strong>自信</strong>。感觉比以前自信了</li>
<li><strong>心情</strong>。每次跑完都特别 high，再多的烦恼没有跑10k 不能解决的</li>
<li><strong>意志力</strong>。意志力得到提升。</li>
</ol>
<h3 id="展望-1">展望</h3><ol>
<li>马甲线已显露，but 并不明显，2016希望身材能练好一点</li>
<li>完成人生第一个马拉松</li>
<li>跑量到1500km（够北京回家的路了）</li>
</ol>
<h2 id="Game">Game</h2><p>炉石上了前300，希望16年有机会去黄金联赛转转<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-test.png" alt=""></p>
<h2 id="电影">电影</h2><p>作为一个不怎么资深的伪影迷，15年看了约30到40部电影，不懂专业的电影姿势，仅从一个普通观影者的角度谈谈15年看过的那些好电影。</p>
<p>2015年是国产良心片井喷的一年，14年之前，很少去影院看国产电影</p>
<h3 id="西游记之大圣归来">西游记之大圣归来</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546417470537.jpg" alt=""></p>
<p>西游记题材的电影、继星爷的『大话西游』之后又一步成功的电影。良心大作啊 ，看到了国产动画的希望。</p>
<h3 id="侏罗纪世界">侏罗纪世界</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546418487025.jpg" alt=""></p>
<p>作为『侏罗纪公园』的忠粉。虽然故事中规中矩，丝毫不影响在我心目中的地位</p>
<h3 id="老炮儿">老炮儿</h3><p>感触最深的一个镜头是冯导和儿子上出租车后，带上墨镜一个人默默的流泪。<br>看完电影一直有两个疑问 1. 六爷的儿子回来后，按照六爷的脾气为啥没有去应岔架 2. 六爷和儿子关系恢复的有点太突然 </p>
<p>原来电影有一堆片段被删节了，万恶的广电总局<br><a href="http://www.bilibili.com/video/av3504936/" target="_blank" rel="external">http://www.bilibili.com/video/av3504936/</a><br>看完这些删节片段 ，才是完整的『老炮儿』</p>
<h3 id="师傅">师傅</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546429443003.jpg" alt=""></p>
<p>我就是喜欢认真的电影！认真的台词，认真的格斗。<br>好久没看过这么好的动作片了</p>
<h3 id="超能陆战队">超能陆战队</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546427454865.jpg" alt=""></p>
<p>wow ~ 大白</p>
<h3 id="烈日灼心">烈日灼心</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546427890205.jpg" alt=""></p>
<p>邓超老师的演技让我折服</p>
<h3 id="火星救援">火星救援</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546426220685.jpg" alt=""></p>
<p>不错的科幻片，但是依然没有撼动『星际穿越』no1的地位</p>
<h3 id="心迷宫">心迷宫</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546430832606.jpg" alt=""></p>
<p>乡会玩系列。小成本的小众电影，但是非常值得一看，剧情紧凑，故事情节环环相扣 ，多角度 穿插式的叙事情节，最后带你一步步抽丝剥茧带你找到故事真相， 只有中国能拍出这样的悬疑片</p>
<h2 id="博客">博客</h2><p>15年用 hexo 搭建了<a href="http://xuyushi.github.io" target="_blank" rel="external">自己的博客</a>，中间断断续续的记录了一些学习的知识点，很零碎，希望2016年能保持记录总结的习惯</p>
<h2 id="2015年剁手的那些超值单品">2015年剁手的那些超值单品</h2><p>喜闻乐见的安利环节，细数15年剁手的那些超值单品</p>
<h3 id="电动牙刷（飞利浦（Philips）_HX6730/02）">电动牙刷（飞利浦（Philips） HX6730/02）</h3><p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546494508858.jpg" alt=""></p>
<p>没的说，懒人必备啊，像我这样天天不认真刷牙的买了这个就是买对了，之后给家里也买了一个。</p>
<h3 id="kindle_paperwhite3">kindle paperwhite3</h3><p>6寸 触摸屏，300ppi，背光<br>阅读利器，除了专业书籍，其他所有的长篇阅读都放在 kindle 中，包括一些微信公众号的长篇文章，也全推送都 kindle<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546496360250.jpg" alt=""></p>
<h3 id="MacBook">MacBook</h3><p>公司发的，颠覆了我对电脑的认识，再也还不回 windows，彻底沦为苹果脑残粉</p>
<h3 id="MWeb">MWeb</h3><p>Markdown 深度使用者，所有的笔记，todo 都是用 Markdown 记录，而MWeb是我迄今为止用过最好用的软件<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546497563955.png" alt=""></p>
<h3 id="K21跑鞋">K21跑鞋</h3><p>对于一个跑步爱好者来说，一双好的跑鞋是必不可少的，以前要是花800买双鞋我是打死也不愿意的，当我穿上之后，一切都觉得很值~<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-05-14546499506815.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]<br>I</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=1141940&auto=1&height=66"></iframe>

<h1 id="2015小结">2015小结</h1><p>　　2015算是自己人生中又一个分水岭，过了除夕才是过完中国的一年，赶在除夕之前整理下自己的2015。</p>
<h2 id="工作">工作</h2><p>　　在学校做硬件 -&gt; 实习做驱动 -&gt; 离开了校园 -&gt; 迈入职场-&gt; Android APP 开发<br>　　<br>　　这一年在技术上的成长自己还是很满意的</p>
<h3 id="流水账">流水账</h3><p>　　2015年初，从美团实习完回学校之后就发觉对 Android 有浓厚的兴趣，考虑到后续工作可能接触到 Android 相关的工作，2015年出开始自学 Java 和 Android，抱着『第一行代码』走了一遍，对 Android 有了初步的认识。之后忙毕业一直到了6月。</p>
<p>　　6月正式入职之后，最初是被分配在了 MTK 平台那边，并不和 Android 相关，主动找了桥哥和栋哥商量，调到了 Android 开发，美团这一点还是挺人性的，尊重员工的意愿。还好有申燊同学带着，一步一步开始了 Android 之旅。</p>
<p>　　第一个项目是做的小美接单，当样机拼装完成，成功打印的那一刻还是挺有成就感的。<br>　　<br>]]>
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[状态模式State Design Pattern]]></title>
    <link href="http://yoursite.com/2016/02/02/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/02/状态模式/</id>
    <published>2016-02-02T15:22:55.000Z</published>
    <updated>2016-02-03T07:53:42.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="状态模式_State_Design_Pattern">状态模式 State Design Pattern</h1><h2 id="定义">定义</h2><h2 id="目的">目的</h2><ul>
<li>根据不同的状态，采取不同的行为</li>
<li>允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样</li>
</ul>
<h2 id="优点">优点</h2><ul>
<li>减少了 if else，switch 语句的复杂程度 </li>
<li>增加新的状态和逻辑时，便于修改</li>
</ul>
<h2 id="缺点">缺点</h2><ul>
<li>类的种类增加<br>*</li>
</ul>
<h2 id="步骤">步骤</h2><ol>
<li>定义一个 <code>context</code> 类，来给外接提供一个接口</li>
<li>定义一个 <code>state</code> 基类</li>
<li>根据<code>state</code> 状态，派生定义其他的不同状态类</li>
<li>在派生<code>state</code> 中，定义不同的行为</li>
<li>在<code>context</code>中持有一个当前 <code>state</code>的变量</li>
<li>改变<code>context</code>中的<code>state</code>状态</li>
</ol>
<a id="more"></a>
<h2 id="适用场景">适用场景</h2><ol>
<li>对象的行为取决于当前的状态</li>
<li>代码中包含大量的与对象状态有关的条件语句。状态模式将每一个条件分支放入一个独立的<code>state</code>类中。</li>
</ol>
<h2 id="结构">结构</h2><ul>
<li><code>context</code>中定义客户端所感兴趣的接口，并持有一个状态类的实例，表示类当前的状态</li>
<li><code>state</code>中定义一个接口，用以封装<code>context</code>中对象的一个特定的状态所对应的行为</li>
<li>具体状态实现了<code>state</code>中所需要动作的具体行为（可以不实现，那么那个行为保持<code>state</code>中的行为）</li>
</ul>
<p><strong>UML 图</strong></p>
<p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14543092051479.png" alt=""></p>
<h2 id="例子">例子</h2><h3 id="context_类">context 类</h3><ul>
<li>其中定义了两个方法 <code>goNext</code> <code>goPre</code>，分别调用当前状态中的<code>next</code> <code>pre</code>方法</li>
<li>复写了<code>toString</code>方法，便于观察结果</li>
<li>在构造函数中初始化当前的<code>state</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.next(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.pre(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now state is "</span>+ state.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="state_基类">state 基类</h3><ul>
<li>定义了<code>next</code> <code>pre</code>方法，子类可以不用复写全部的方法，所以在父类中要做相应的处理，也可以抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"error"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"error"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 具体实现类</span><br><span class="line">* A 状态只复写 next 方法</span><br><span class="line">* B 状态复写 next 和 pre方法</span><br><span class="line">* C 状态只复写 pre 方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateA</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        wrapper.setState(<span class="keyword">new</span> StateB());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        wrapper.setState(<span class="keyword">new</span> StateC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        wrapper.setState(<span class="keyword">new</span> StateA());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateC</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Wrapper wrapper)</span> </span>&#123;</span><br><span class="line">        wrapper.setState(<span class="keyword">new</span> StateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端使用">客户端使用</h3><p>每次改变状态之后打印当前状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.xuyushi.state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by xuyushi on 16/1/29.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StateMain RUNNING"</span>);</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Wrapper wrapper = <span class="keyword">new</span> Wrapper(<span class="keyword">new</span> StateA());</span><br><span class="line">        System.out.println(wrapper.toString());</span><br><span class="line">        wrapper.goPre();</span><br><span class="line">        System.out.println(wrapper.toString());</span><br><span class="line">        wrapper.goNext();</span><br><span class="line">        System.out.println(wrapper.toString());</span><br><span class="line">        wrapper.goNext();</span><br><span class="line">        System.out.println(wrapper.toString());</span><br><span class="line">        wrapper.goNext();</span><br><span class="line">        System.out.println(wrapper.toString());</span><br><span class="line">        wrapper.goNext();</span><br><span class="line">        System.out.println(wrapper.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>log</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StateMain RUNNING</span><br><span class="line">now state is io.github.xuyushi.state.StateA</span><br><span class="line">error</span><br><span class="line">now state is io.github.xuyushi.state.StateA</span><br><span class="line">now state is io.github.xuyushi.state.StateB</span><br><span class="line">now state is io.github.xuyushi.state.StateC</span><br><span class="line">error</span><br><span class="line">now state is io.github.xuyushi.state.StateC</span><br><span class="line">error</span><br><span class="line">now state is io.github.xuyushi.state.StateC</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1><blockquote>
<ul>
<li>『first head 设计模式』 </li>
<li><a href="https://sourcemaking.com/design_patterns/state" target="_blank" rel="external">https://sourcemaking.com/design_patterns/state</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7557252" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7557252</a></li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="状态模式_State_Design_Pattern">状态模式 State Design Pattern</h1><h2 id="定义">定义</h2><h2 id="目的">目的</h2><ul>
<li>根据不同的状态，采取不同的行为</li>
<li>允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样</li>
</ul>
<h2 id="优点">优点</h2><ul>
<li>减少了 if else，switch 语句的复杂程度 </li>
<li>增加新的状态和逻辑时，便于修改</li>
</ul>
<h2 id="缺点">缺点</h2><ul>
<li>类的种类增加<br>*</li>
</ul>
<h2 id="步骤">步骤</h2><ol>
<li>定义一个 <code>context</code> 类，来给外接提供一个接口</li>
<li>定义一个 <code>state</code> 基类</li>
<li>根据<code>state</code> 状态，派生定义其他的不同状态类</li>
<li>在派生<code>state</code> 中，定义不同的行为</li>
<li>在<code>context</code>中持有一个当前 <code>state</code>的变量</li>
<li>改变<code>context</code>中的<code>state</code>状态</li>
</ol>]]>
    
    </summary>
    
      <category term="Pattern" scheme="http://yoursite.com/tags/Pattern/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java注解]]></title>
    <link href="http://yoursite.com/2016/02/01/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/02/01/注解/</id>
    <published>2016-02-01T07:12:00.000Z</published>
    <updated>2016-02-28T04:11:22.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="注解">注解</h1><h2 id="注解目的">注解目的</h2><ol>
<li>生成文档 ，如 @see @param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
<li>在编译时进行格式检查。如@override </li>
</ol>
<h2 id="注解基础">注解基础</h2><p>最基础的注解如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br></pre></td></tr></table></figure>
<p>@ 表示这是一个注解，之后的字母表示这个注解的名字，以上例子的注解名字为 <code>Entity</code></p>
<a id="more"></a>
<h3 id="注解元素">注解元素</h3><p>Java 注解中有一些元素，并且可以设置他们的值，举个🌰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span>(tableName = <span class="string">"vehicles"</span>)</span><br></pre></td></tr></table></figure>
<p>注解<code>Entity</code>中含有一个<code>tableName</code>元素，并且把这个元素赋值为vehicles。</p>
<p>一个注解也可以同时含有多个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span>(tableName = <span class="string">"vehicles"</span>, primaryKey = <span class="string">"id"</span>)</span><br></pre></td></tr></table></figure>
<p>当一个注解只含有一个元素时，赋值可以写成以下形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@InsertNew</span>(<span class="string">"yes"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="注解的种类">注解的种类</h2><p>注解可以修饰 类、接口、方法、参数、域、本地变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Persistent</span></span><br><span class="line">    <span class="keyword">protected</span> String vehicleName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVehicleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.vehicleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVehicleName</span><span class="params">(@Optional vehicleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vehicleName = vehicleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">addVehicleNameToList</span><span class="params">(List names)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Optional</span></span><br><span class="line">        List localNames = names;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(localNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            localNames = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        localNames.add(getVehicleName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> localNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java_内置的注解">Java 内置的注解</h2><p>Java 内置了三种指导编译的注解，分别为</p>
<ul>
<li>@Deprecated</li>
<li>@Override</li>
<li>@SuppressWarnings</li>
</ul>
<h3 id="@Deprecated">@Deprecated</h3><blockquote>
<p>Annotation type used to mark program elements that should no longer be used by programmers. Compilers produce a warning if a deprecated program element is used.</p>
</blockquote>
<p>可以修饰 类、方法、域。表示之后不会被使用了。如果代码中使用到了注解为@Deprecated 的代码，编译器会产生警告</p>
<h3 id="@Override">@Override</h3><blockquote>
<p>Annotation type used to mark methods that override a method declaration in a superclass. Compilers produce an error if a method annotated with @Override does not actually override a method in a superclass.</p>
</blockquote>
<p>修饰方法，表示此方法复现了父类的方法，如果在父类中没有相应的方法编译器会报错</p>
<p>@Override 并不是必须的，但是在子类中复写父类的方法中最好使用，以防复写的时候名字和父类的方法名不一致而产生一些问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do the thing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span> <span class="keyword">extends</span> <span class="title">MySuperClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTheThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do it differently"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="@SuppressWarnings">@SuppressWarnings</h3><blockquote>
<p> Annotation type used to indicate that the compiler should not issue the specified warnings for the marked program element. Warnings are not only suppressed for the annotated element but also for all program elements contained in that element.</p>
</blockquote>
<p> It is recommended that programmers always use this annotation on the most deeply nested element where it is actually needed.</p>
<p>使编译器不产生对此方法的警告信息。</p>
<h2 id="自定义注解">自定义注解</h2><p>注解的定义和类、接口的定义类似。举个🌰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String   <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String   <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    String[] newNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 @interface 关键字表示定义的是一个注解。其中的每一个方法实际上是声明了一个配置参数。<strong>方法的名称就是参数的名称，返回值类型就是参数的类型。</strong>，元素只支持原始的数据类型。<br>使用上述的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MyAnnotation</span>(</span><br><span class="line">    value=<span class="string">"123"</span>,</span><br><span class="line">    name=<span class="string">"Jakob"</span>,</span><br><span class="line">    age=<span class="number">37</span>,</span><br><span class="line">    newNames=&#123;<span class="string">"Jenkov"</span>, <span class="string">"Peterson"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元素默认值">元素默认值</h3><p>在定义注解时可以设置默认值，举个🌰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String   <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String   <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    String[] newNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元素<code>value</code>在使用时可以不赋值，当不赋值时，默认采用定义时的默认值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MyAnnotation</span>(</span><br><span class="line">    name=<span class="string">"Jakob"</span>,</span><br><span class="line">    age=<span class="number">37</span>,</span><br><span class="line">    newNames=&#123;<span class="string">"Jenkov"</span>, <span class="string">"Peterson"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="@Retention">@Retention</h3><ul>
<li>用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE这三种，分别表示注解保存在类文件、JVM运行时刻和源代码中。</li>
<li>只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。</li>
<li>RetentionPolicy.SOURCE 注解将被编译器丢弃 </li>
<li>RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 </li>
<li>RetentionPolicy.RUNTIME VM将在运行期也保留注释，<strong>因此可以通过反射机制读取注解的信息。</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"></span><br><span class="line"><span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String   <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时可以使用反射的方法得到注解中的信息</p>
<h4 id="反射得到注解信息">反射得到注解信息</h4><h5 id="类注解">类注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法1：可以直接得到所有的注解，在里面寻找MyAnnotation</span></span><br><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//法2：可以直接得到MyAnnotation注解</span></span><br><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation annotation = aClass.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法注解">方法注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method method = ... <span class="comment">//obtain method object</span></span><br><span class="line">Annotation[] annotations = method.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样</span></span><br><span class="line">Method method = ... <span class="comment">// obtain method object</span></span><br><span class="line">Annotation annotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="域、参数注解同理">域、参数注解同理</h5><h3 id="@Target">@Target</h3><p>用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String   <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>🌰表示这个注解只能修饰方法</p>
<p><strong>表示该注解用于什么地方</strong>，可能的值在枚举类 ElemenetType 中，包括： </p>
<ul>
<li>ElemenetType.CONSTRUCTOR 构造器声明 </li>
<li>ElemenetType.FIELD 域声明（包括 enum 实例） </li>
<li>ElemenetType.LOCAL_VARIABLE 局部变量声明 </li>
<li>ElemenetType.METHOD 方法声明 </li>
<li>ElemenetType.PACKAGE 包声明 </li>
<li>ElemenetType.PARAMETER 参数声明 </li>
<li>ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 </li>
</ul>
<h3 id="@Inherited">@Inherited</h3><p>允许子类继承父类中的注解，举个🌰 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.annotation.Inherited</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MyAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySuperClass</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span> <span class="keyword">extends</span> <span class="title">MySuperClass</span> </span>&#123;... &#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，因为<code>MySubClass</code>继承了<code>MySuperClass</code>，并且<code>MySuperClass</code>被注解<code>@MyAnnotation</code>修饰了，所以类<code>MySubClass</code>继承了<code>@MyAnnotation</code>注解</p>
<h3 id="@Documented">@Documented</h3><p>@Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。<br>举个🌰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MyAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySuperClass</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1><blockquote>
<p><a href="http://blog.csdn.net/tigerdsh/article/details/8848890" target="_blank" rel="external">http://blog.csdn.net/tigerdsh/article/details/8848890</a><br><a href="http://tutorials.jenkov.com/java/annotations.html" target="_blank" rel="external">http://tutorials.jenkov.com/java/annotations.html</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="注解">注解</h1><h2 id="注解目的">注解目的</h2><ol>
<li>生成文档 ，如 @see @param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
<li>在编译时进行格式检查。如@override </li>
</ol>
<h2 id="注解基础">注解基础</h2><p>最基础的注解如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br></pre></td></tr></table></figure>
<p>@ 表示这是一个注解，之后的字母表示这个注解的名字，以上例子的注解名字为 <code>Entity</code></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 内存泄露]]></title>
    <link href="http://yoursite.com/2016/01/14/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2016/01/14/内存泄露/</id>
    <published>2016-01-14T09:27:00.000Z</published>
    <updated>2016-02-03T03:36:53.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="内存泄露">内存泄露</h1><blockquote>
<p>内存泄露的定义:<br>当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放(Remove,移除)他们.</p>
</blockquote>
<h2 id="产生的原因：">产生的原因：</h2><p>内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）</p>
<p><em>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</em></p>
<a id="more"></a>
<h3 id="常见的内存泄漏">常见的内存泄漏</h3><h4 id="非静态内部类的静态实例容易造成内存泄漏">非静态内部类的静态实例容易造成内存泄漏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityextends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">static</span> Demo sInstance = <span class="keyword">null</span>;  </span><br><span class="line">          </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(BundlesavedInstanceState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           sInstance= <span class="keyword">new</span> Demo();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;  </span><br><span class="line">    voiddoSomething()  &#123;  </span><br><span class="line">               System.out.print(<span class="string">"dosth."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中的sInstance实例类型为静态实例，在第一个MainActivity act1实例创建时，sInstance会获得并一直持有act1的引用。当MainAcitivity销毁后重建，因为sInstance持有act1的引用，所以act1是无法被GC回收的，进程中会存在2个MainActivity实例（act1和重建后的MainActivity实例），这个act1对象就是一个无用的但一直占用内存的对象，即无法回收的垃圾对象。所以，对于lauchMode不是singleInstance的Activity， 应该避免在activity里面实例化其非静态内部类的静态实例。</p>
<h4 id="activity使用静态成员">activity使用静态成员</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;    </span><br><span class="line"><span class="annotation">@Override</span>    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">super</span>.onCreate(state);    </span><br><span class="line">    </span><br><span class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);    </span><br><span class="line">    label.setText(<span class="string">"Leaks are bad"</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;    </span><br><span class="line">        sBackground = getDrawable(R.drawable.large_bitmap);    </span><br><span class="line">    &#125;    </span><br><span class="line">    label.setBackgroundDrawable(sBackground);    </span><br><span class="line">    </span><br><span class="line">    setContentView(label);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于用静态成员sBackground 缓存了drawable对象，所以activity加载速度会加快，但是这样做是错误的。因为在android 2.3系统上，它会导致activity销毁后无法被系统回收。</p>
<p>label .setBackgroundDrawable函数调用会将label赋值给sBackground的成员变量mCallback。</p>
<p>上面代码意味着：sBackground（GC Root）会持有TextView对象，而TextView持有Activity对象。所以导致Activity对象无法被系统回收。</p>
<p>下面看看android4.0为了避免上述问题所做的改进。</p>
<p>先看看android 2.3的Drawable.Java对setCallback的实现：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback cb)</span></span>{

    mCallback = cb;
</code></pre><p>}</p>
<p>再看看android 4.0的Drawable.Java对setCallback的实现：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback cb)</span></span>{

    mCallback = newWeakReference&lt;Callback&gt; (cb);
</code></pre><p>}</p>
<p>在android 2.3中要避免内存泄漏也是可以做到的, 在activity的onDestroy时调用</p>
<p>sBackgroundDrawable.setCallback(null)。</p>
<p>以上2个例子的内存泄漏都是因为Activity的引用的生命周期超越了activity对象的生命周期。也就是常说的Context泄漏，因为activity就是context。</p>
<p>想要避免context相关的内存泄漏，需要注意以下几点：</p>
<ul>
<li>不要对activity的context长期引用(一个activity的引用的生存周期应该和activity的生命周期相同)</li>
<li>如果可以的话，尽量使用关于application的context来替代和activity相关的context</li>
<li>如果一个acitivity的非静态内部类的生命周期不受控制，那么避免使用它；正确的方法是使用一个静态的内部类，并且对它的外部类有一WeakReference，就像在ViewRootImpl中内部类W所做的那样。</li>
</ul>
<h4 id="使用handler时的内存问题">使用handler时的内存问题</h4><p>我们知道，Handler通过发送Message与其他线程交互，Message发出之后是存储在目标线程的MessageQueue中的，而有时候Message也不是马上就被处理的，可能会驻留比较久的时间。在Message类中存在一个成员变量 target，它强引用了handler实例，如果Message在Queue中一直存在，就会导致handler实例无法被回收，如果handler对应的类是非静态内部类 ，则会导致外部类实例（Activity或者Service）不会被回收，这就造成了外部类实例的泄露。 所以正确处理Handler等之类的内部类，应该将自己的Handler定义为静态内部类，并且在类中增加一个成员变量，用来弱引用外部类实例，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutterClass</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>  </span><br><span class="line">        </span>&#123;  </span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;OutterClass&gt; mOutterClassInstance;  </span><br><span class="line">            ......  </span><br><span class="line">            ......  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android lint 会产生一个警告 </p>
<blockquote>
<p>This Handler class should be static or leaks might occur (com.example.ta.MainActivity.1)<br>Issue: Ensures that Handler classes do not hold on to a reference to an outer class<br>Id: HandlerLeak<br>In Android, Handler classes should be static or leaks might occur. Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class.</p>
</blockquote>
<p>原因是：<br>当Android应用启动的时候，会先创建一个应用主线程的Looper对象，Looper实现了一个简单的消息队列，一个一个的处理里面的Message对象。主线程Looper对象在整个应用生命周期中存在。<br>当在主线程中初始化Handler时，该Handler和Looper的消息队列关联。发送到消息队列的Message会引用发送该消息的Handler对象，这样系统可以调用 Handler#handleMessage(Message) 来分发处理该消息。<br>在Java中，非静态(匿名)内部类会引用外部类对象。而静态内部类不会引用外部类对象。<br>如果外部类是Activity，则会引起Activity泄露 。<br>当Activity finish后，延时消息会继续存在主线程消息队列中1分钟，然后处理消息。而该消息引用了Activity的Handler对象，然后这个Handler又引用了这个Activity。这些引用对象会保持到该消息被处理完，这样就导致该Activity对象无法被回收，从而导致了上面说的 Activity泄露。<br>要修改该问题，只需要按照Lint提示的那样，把Handler类定义为静态即可，然后通过WeakReference 来保持外部的Activity对象。 </p>
<h4 id="注册某个对象后未反注册">注册某个对象后未反注册</h4><h4 id="集合中对象没清理造成的内存泄露">集合中对象没清理造成的内存泄露</h4><h4 id="资源对象没关闭造成的内存泄露">资源对象没关闭造成的内存泄露</h4><p>比如 cursor 、file</p>
<h2 id="GC_机制">GC 机制</h2><p>如上图所示，GC会选择一些它了解还存活的对象作为内存遍历的根节点（GC Roots），比方说thread stack中的变量，JNI中的全局变量，zygote中的对象（class loader加载）等，然后开始对heap进行遍历。到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。如下图蓝色部分</p>
<p><img src="http://img.blog.csdn.net/20131025115331781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2VtbWVt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="GC"></p>
<ul>
<li>Shallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。</li>
<li>Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。</li>
</ul>
<h2 id="内存管理分析">内存管理分析</h2><ol>
<li>打开 DDMS ，选中需要分析的进程，然后点击update heap<img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14527590780897.jpg" alt=""></li>
<li>在app 中操作后，点击 Cause GC,观察heap 的使用量<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14527591546703.png" alt=""></li>
<li>点击 <img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14527592144127.png" alt=""> 导出 HPROF 文件</li>
<li>转换 hprof 的格式，从而支持使用 MAT 工具打开分析</li>
<li><code>hprof-conv &lt;source_file&gt; &lt;dest_file&gt;</code></li>
<li>使用 MAT 打开生成文件</li>
<li>点击<img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14527602568618.png" alt=""> 查看详情</li>
</ol>
<h2 id="MAT_使用">MAT 使用</h2><ul>
<li>可以在上面过滤自己需要的类名，支持正则表达式</li>
<li>在某一项上右键打开菜单选择 list objects -&gt;with incoming refs 将列出该类的实例：</li>
<li>快速找出某个实例没被释放的原因，可以右健 Path to GC Roots—&gt;exclue all phantom/weak/soft etc</li>
</ul>
<ul>
<li>Shallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。</li>
<li>Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。</li>
</ul>
<h2 id="分析实例">分析实例</h2><h3 id="实例1">实例1</h3><p>Mat中导入数据后，过滤包名，按照 obj 数量排序<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14530982417272.png" alt=""><br>发现 AsyncTaskService 有9个实例，不正常，右键  Path to GC Roots 查看<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14530983537752.png" alt=""><br>发现是 volley 中的 NetworkDispatcher 持有了 context 导致释放不了</p>
<p><strong>NetworkDispatcher 持有（用到了） UserStatsPostRequest 持有 mLIstener、mErrorListener 持有 context</strong></p>
<p>在  <code>AsyncTaskService</code>中 <code>PoiInfoApi.refreshPoiInfo(AsyncTaskService.this, null);</code><br>传入的 <code>context</code> 是<code>AsyncTaskService</code>，导致 <code>PoiInfo</code> 与 <code>AsyncTaskService</code>的生命周期相关联<br>当 <code>service</code>生命周期结束时，<code>mLIstener</code> 仍然持有 <code>Service</code> ，导致 GC无法回收，当下次再次请求 <code>Poiapi</code>时，会再次用到一个新的<code>AsyncTaskService</code> </p>
<h4 id="解决方法">解决方法</h4><p>传入的 <code>context</code> 不使用 <code>activity</code> 或<code>Service</code>这样和 Android 生命周期相关的，使用 <code>appcation</code> 中的 <code>sContext</code></p>
<h3 id="实例2">实例2</h3><ol>
<li>点击<img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14532588103369.png" alt=""> ，按照堆排序</li>
</ol>
<p><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14532588339301.png" alt=""><br>此时是按照占用的大小排序的，首先Retained Heap表示这个对象以及它所持有的其它引用（包括直接和间接）所占的总内存，因此从上图中看，前两行的Retained Heap是最大的，我们分析内存泄漏时，内存最大的对象也是最应该去怀疑的。</p>
<p>在每一行的最左边都有一个文件型的图标，这些图标有的左下角带有一个红色的点，有的则没有。带有红点的对象就表示是可以被GC Roots访问到的，根据上面的讲解，可以被GC Root访问到的对象都是无法被回收的</p>
<p>第一行为资源文件，比较大很正常，第二行为 bitmap，点击  -&gt; Path to GC Roots -&gt; exclude weak references，为什么选择exclude weak references呢？因为弱引用是不会阻止对象被垃圾回收器回收的，所以我们这里直接把它排除掉<br><img src="http://7xqcjz.com1.z0.glb.clouddn.com/2016-02-01-14532592207499.png" alt=""></p>
<p><strong>黑体表示变量名，右侧正常体表示类名， 由上到下表示含有关系</strong></p>
<p>可以看到 bitmap 之所以释放不掉是因为 linearLayout 无法释放，而linearLayout之所以释放不掉是因为 linearLayout 无法释放，是因为 LoginActivity 无法释放，….最终发现是 SPDataManager中 的 sContext 持有了 Activity，导致 Activity 无法被 GC回收</p>
<h4 id="解决方法-1">解决方法</h4><p>在构造 SPDataManger 时，不使用 Activity 的 context ，而使用 getapplicationContext，避免与 Actvity 的生命周期关联</p>
<h1 id="参考">参考</h1><blockquote>
<p><a href="http://blog.csdn.net/gemmem/article/details/13017999" target="_blank" rel="external">http://blog.csdn.net/gemmem/article/details/13017999</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/4223863" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/4223863</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="内存泄露">内存泄露</h1><blockquote>
<p>内存泄露的定义:<br>当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放(Remove,移除)他们.</p>
</blockquote>
<h2 id="产生的原因：">产生的原因：</h2><p>内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）</p>
<p><em>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</em></p>]]>
    
    </summary>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
      <category term="内存泄露" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
  </entry>
  
</feed>