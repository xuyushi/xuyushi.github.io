<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Xu Yushi's Blog]]></title>
  <link href="xuyushi.github.io/atom.xml" rel="self"/>
  <link href="xuyushi.github.io/"/>
  <updated>2018-09-14T09:32:04+08:00</updated>
  <id>xuyushi.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[移动增长堆栈（2）--洞察与分析]]></title>
    <link href="xuyushi.github.io/mobile_growth_stack_part_2.html"/>
    <updated>2018-09-13T17:12:06+08:00</updated>
    <id>xuyushi.github.io/mobile_growth_stack_part_2.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15368299264873/15368299403940.png" alt=""/></p>

<p>洞察分析层是堆栈中最全面的层，其基础是定量和定性数据、指标、建模和衡量影响和识别机会方面的重要性的报表。 尽管可以通过足够的投资来制作自定义解决方案或快速黑客或数据库查询以获得短期洞察力，市面上还是存在许多工具和服务来帮助这一层中的特定数据收集或处理活动。</p>

<h2 id="toc_0">归因(Attribution)</h2>

<p>app 的安装归因于特定营销活动，内容分享归因于社交网络，邀请或者其他的获取源在网络上有不同的追踪技术。浏览器cookie可以在移动/响应式网站上使用，但对于本机应用程序，用户可以使用特定于设备的ID（如IDFA或Android ID），或通过不完美的指纹识别技术，这些技术结合了大量数据输入以匹配用户（或 ，更准确地说，一个设备）点击安装。 在考虑多个接触点和跨平台流量（例如，桌面Web到移动设备安装）时，归因变得更具挑战性。</p>

<h2 id="toc_1">Deeplinks</h2>

<p>本地移动应用程序正在发展;它们不再仅仅从手机的主屏幕上启动，而是越来越多地从深度链接上启动，用户可以直接访问应用程序中的特定内容(假设他们已经安装了)。许多移动应用程序都实现了deeplink模式，为应用程序提供了额外的入口点。Deeplinks可以包含在推送通知、电子邮件、消息、其他应用程序、来自网站的链接以及几乎任何可以启动常规web URL的地方。不仅如此，应用程序中的内容可以通过谷歌进行索引，并出现在搜索结果中(iOS 9和更高版本中，如果启用了通用链接，也支持应用程序索引)。深度链接也用于重新定位广告活动，即现有(但可能已失效)用户在其他应用程序中接受广告，目的是重新吸引他们，并将他们带回应用程序的特定部分。</p>

<p>如果你的应用程序支持深度链接内容，那么收集这些链接的表现是很重要的。了解哪个深度链接uri正在被打开，以及理想情况下用户来自哪里(例如浏览器链接、推送通知、重定向活动等)，将提供有价值的洞察哪些内容是最受欢迎的，以及更深入地了解各种渠道和活动是如何重新吸引现有用户的。这些数据可以为新的内容的编辑政策提供信息，并帮助优化通讯活动。</p>

<h2 id="toc_2">事件追踪(Event Tracking)</h2>

<p>在粒度级别衡量用户参与度是进行数据驱动的优化以及评估功能的采用和性能的关键先决条件。</p>

<p>用户在应用程序中执行的任何操作（应用程序打开，帐户注册，屏幕之间的导航，按钮按下，内容共享，购买等），以及以编程方式在应用程序内发生的事情（例如，敌方太空船被摧毁，级别 已完成，帐户成功创建等）是作为分析实施的一部分跟踪作为“事件”的候选者。 当网络条件允许时，分析SDK通常会将这些事件以及与此事件发生相关的任何其他元数据（通常称为“事件属性”）传输到服务器。</p>

<p>为了在基于web的仪表板中进行分析，聚合和存储事件数据服务器端是目前常见的做法，许多分析工具都可以简化这一任务。这样的定量事件数据显示了用户如何与应用/游戏进行交互，而应用/游戏的特性是最常用/最不常用的，它可以帮助识别bug(例如，如果事件数量突然骤减，与事件相关的特性可能会被破坏)，并允许对关键用户路径的参与漏斗进行可视化。此外，服务器生成的营销活动或活动通知可以由事件触发，并可能使用事件属性数据进行个性化处理。</p>

<h2 id="toc_3">活动测量(Campaign Measurement)</h2>

<p>市场营销活动，无论是为了获得用户、参与/保留或盈利，都需要适当的度量，以便度量影响/ROI。没有对广告活动和创意/文案表现的定量了解，广告预算就无法合理分配或调整规模，也就无法优化广告活动。</p>

<p>对于用户获取（UA）或重定向广告系列，此主题与安装/深层链接归因和事件跟踪密切相关; 营销人员需要了解每个网络和广告系列变体提供的安装量，获取这些新用户的费用以及这些用户的“质量”（通常根据群组生成的参与度/留存或付费事件来衡量） （归因于广告系列的用户），以优化广告支出以提高效果。</p>

<p>电子邮件，推送和应用内广告系列等生命周期营销也需要进行详细衡量，以便运行实验以提高开放和点击率以及下游性能目标，例如增加应用内购买，推动应用内更多关键操作，改进 留存等</p>

<h2 id="toc_4">应用商店分析与智能(App Store Analytics &amp; Intelligence)</h2>

<p>任何应用发布商都将通过至少一个（可能是几个）应用商店分发他们的应用;除iTunes App Store和Google Play外，还有许多其他分销渠道，包括Windows Store，Amazon App Store，Samsung Apps，Myapp（腾讯）等。</p>

<p>如果使用提供这些数据的服务，基本App Store Analytics可按国家/地区，设备，操作系统版本等以及竞争对手的应用安装和应用内购买进行衡量和报告。</p>

<p>随着每天都有数以千计的新应用和游戏提交到应用商店，在商店中保持可见性对于应用发布商来说是一场持续的战斗。观察竞争趋势并对其做出反应，关键字搜索量和其他市场情报可以使发布商在竞争中占据优势。查看某类别中顶级应用程序的预测下载数据可以为战略规划提供信息，并提供发布商为了达到商店中特定排名而需要达到的每日下载量的指示（尽管通用下载估算 - 使用预测方法生成 - 应谨慎对待，因为类别和分析工具之间的准确性差异很大）。尽管如此，分析应用商店数据以期获得可操作的洞察力可能对产品生命周期的所有阶段都有所帮助。</p>

<p>App Store搜索也是应用程序发现的重要组成部分，对关键字进行仔细识别和测试可以增加商店的有机下载量。存在许多ASO工具，其估计关键字搜索量并估计在搜索特定关键字时高度排名的难度。</p>

<h2 id="toc_5">用户细分(User Segmentation)</h2>

<p>并非所有用户都是相同的; 一些人群将更加投入，更有可能在应用程序中花钱，或者显示一些共同特征，使他们能够被分组到有意义的部分，以便进行分析，营销，动态定价等等。 大多数分析工具允许基于用户元数据（a.k.a属性）或应用程序内的行为创建和跟踪动态更新的用户细分。 通过针对特定用户细分定制应用内和外部消息传递活动，营销人员可以提高其广告系列的相关性和影响力并带来更多影响。</p>

<h2 id="toc_6">队列分析(Cohort Analysis)</h2>

<p>为了了解用户增长和留存如何随着时间的推移而发展，重要的是检查同类群组中的用户（具有一些共同特征的用户组，通常是安装/注册日期），而不是依赖于总体注册等顶级指标 用户，每月活动用户（MAU）和每日活动用户（DAU），这些用户往往会掩盖潜在的保留问题。</p>

<p>典型的群组保留表将用户划分为在应用中首次出现的时段（通常是日/周/月），并显示在以下时段中返回到应用的用户数（或群组的百分比）。</p>

<p><img src="media/15368299264873/15368384975993.png" alt=""/></p>

<h2 id="toc_7">内容分析(Content Analytics)</h2>

<p>如果应用或游戏包含动态内容，例如 新闻文章，食谱，照片，音乐曲目等随后跟踪内容（观看，喜欢，书签，购买等）和内容共享，可以深入了解哪些内容和类别可以提供最佳ROI。 除了跟踪内容参与之外，还期望测量特定内容项由于被共享而产生的推荐用户的数量以及哪些频道提供最佳的病毒性。</p>

<h2 id="toc_8">情绪追踪(Sentiment Tracking)</h2>

<p>客户满意度很重要;不满或心怀不满的用户面临流失的高风险，并且可能会在应用商店或在线论坛上发出负面反馈，从而阻止潜在用户。相反，快乐或高兴的用户可以成为移动产品的强大拥护者，并且应该在用户细分中进行识别。</p>

<p>衡量客户满意度的方法有很多种;在线，应用内或电子邮件调查可用于收集详细的反馈，但更常见的是，用户只需通过弹出窗口向应用程序提供0到5星的评分，或者提供他们的净推荐分数（NPS） ）评分简单，标准化的问题“你有多大可能推荐[产品]给同事的朋友？”（评分为0-10）。</p>

<p>为应用程序评分较高的用户可以自信地定位，以便对商店中的应用进行评级，邀请朋友，分享内容或发布有关应用的推文。具有负面情绪的用户可以被识别并且 - 希望 - 通过客户服务工作来安抚，并鼓励他们直接向出版商而不是公众提供反馈。</p>

<p>在推广到100％的用户群之前,情感跟踪技术可用于定量评估用户对新功能或内容的反应.</p>

<h2 id="toc_9">屏幕流跟(Screen Flows)</h2>

<p>与事件跟踪类似，屏幕流跟踪可以深入了解用户如何浏览应用，他们登陆的屏幕以及他们到达那里的路径。 对屏幕流程的分析可以识别未充分利用的屏幕或功能，这些屏幕或功能可能会受益于UI中更突出（或完全切断），或者表明用户在应用程序的意外部分花费了大量时间。 </p>

<h2 id="toc_10">转换渠道(Conversion Funnels)</h2>

<p>跟踪和可视化关键参与流程中的每个事件，例如帐户创建，购买，搜索等，有助于识别表现不佳的流程，并通过显示用户在每个阶段中的落差来指导优化工作。</p>

<p>在大多数分析套件中，可以临时创建新的渠道，因此可以轻松创建新的渠道来监控新功能或购买选项的性能。 详细的事件跟踪是漏斗可视化的先决条件。</p>

<h2 id="toc_11">结算和收入报告(Billing And Revenue Reporting)</h2>

<p>一些移动应用程序或平台运营市场，供应商和消费者可以在那里交易虚拟或现实世界的商品或服务。在其他情况下，应用程序内的内容可能以按播放付费或按观看付费的方式从供应商获得许可。</p>

<p>如果上述任何一项都适用，准确(最好是自动化)的记录和报告支出、许可费、版税或广告收入、应用内购买或订阅收入是产品分析和报告框架的必要组成部分。</p>

<h2 id="toc_12">增长模型（Growth Modelling）</h2>

<p>增长是一个系统，有许多输入和反馈循环。 在组织内部建立共享理解 - 引导到抽象模型 - 激发增长努力，为假设生成和构思过程提供信息。 随着时间的推移，增长模型可能会得到改进，因为这种共享理解是通过实验学习和对用户行为，市场动态和运营数据的更深入理解而发展的。</p>

<p><img src="media/15368299264873/15368395298439.jpg" alt=""/></p>

<p>Uber’s growth model. (Src = <a href="http://andrewchen.co/ubers-virtuous-cycle-5-important-reads-about-uber/">http://andrewchen.co/ubers-virtuous-cycle-5-important-reads-about-uber/</a>)</p>

<p>除了开发如上所述的高级定性模型之外，连接采集（按各种采集渠道和病毒循环细分）和留存/流失的电子表格或类似定量模型将证明非常有价值，无论是为了理解 为不同的场景提供和创建预测。 通过这种模型，可以实现场景规划，<strong>团队可以根据对活跃用户增长产生最大影响的内容来调整获客和留存工作的组合</strong>。</p>

<h2 id="toc_13">LTV 模型 (LTV Modeling)</h2>

<p>一旦应用程序可以变现，了解用户的生命周期价值（LTV）就非常重要。 LTV是用户在其生命周期内产生的未来预期收入的现值计算。 由于这是一个前向投影，LTV建模并不是一门精确的科学; 用户产生的实际收入可能超过或低于LTV计算，因此在使用LTV进行广告购买决策时保证是保守的。 LTV可能受到许多因素的影响，包括采购来源，用户人口统计，产品内的货币化可能性范围等。如果用户保留（寿命）可以增加，那么LTV也会更高。</p>

<h2 id="toc_14">growth 计算(Growth Accounting)</h2>

<p>虽然定量增长模型用于生成前瞻性预测，但增长计算过程涉及跟踪当前和历史用户增长。主动用户增长可以看作是一个简单的函数:</p>

<p>活跃用户=新用户+保留用户 - 流失用户（在给定时间段内，例如最近30天）</p>

<p>（注意：&#39;失效&#39;的用户可能更正确，因为他们可能没有完全被搅动，因为他们永远不会返回，而只是他们在这段时间内没有活跃）。</p>

<p>另一种思考方式是，增长来自三个独立的“桶”用户：新用户，重复用户和回头客。 重复用户是那些在上一期间活跃并且在此期间再次被看到的用户。 返回的用户在前一段时间内被重新激活。 跟踪这三个存储桶中的活跃用户可以更深入地了解活动用户数以及在给定时间段内驱动增长（或缺乏增长）的因素。</p>

<p><img src="media/15368299264873/15368882958675.jpg" alt=""/></p>

<h1 id="toc_15">App性能分析(CPU、电池、网络、崩溃等) (App Performance Analysis (CPU, Battery, Network, Crashes Etc))</h1>

<p>移动产品与桌面应用和网站的不同之处在于可以访问它们的各种环境。在桌面环境中，Web应用程序可以安全地假设未经计量的Internet连接（可能具有良好的带宽和延迟）始终可用。良好的移动产品设计用于带宽有限，延迟较高或无网络连接的情况。移动设备依靠电池运行，用户越来越精明，因此可能会删除电池占用应用程序。同样，许多用户没有无限的数据计划，并期望应用和移动网站具有数据意识。最后，崩溃的应用程序会迅速卸载，通常在应用商店中留下较差的评论。</p>

<p>虽然性能分析可能主要由工程团队考虑，但值得记住的是，在上述任何情况下表现不佳的产品可能会遭受高流失和/或减少参与度。关注绩效指标将提醒团队任何潜在的增长抑制因素。</p>

<p><img src="media/15368299264873/15368883864437.jpg" alt=""/></p>

<p>上图:Fabric monitor应用程序，包含崩溃报告。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动增长堆栈（1）--概述]]></title>
    <link href="xuyushi.github.io/mobile_growth_stack_part_1.html"/>
    <updated>2018-09-13T16:23:56+08:00</updated>
    <id>xuyushi.github.io/mobile_growth_stack_part_1.html</id>
    <content type="html"><![CDATA[
<p>本系列文章翻译自 ：<a href="https://mobilegrowthstack.com/what-is-the-mobile-growth-stack-426c6e474329">https://mobilegrowthstack.com/what-is-the-mobile-growth-stack-426c6e474329</a></p>

<p><img src="media/15368270366063/15368294184568.png" alt=""/></p>

<h2 id="toc_0">什么是 移动增长堆栈?</h2>

<p>移动增长堆栈(Mobile Growth Stack)是一个框架，它可以帮助营销人员，创始人和增长从业者制定和完成一种能增加产品用户数的战略。尽管移动增长堆栈的某些层和元素在业务的不同阶段更具相关性，但它可以应用与产品生命周期的任何阶段，也可以应用于许多不同的业务和模型。</p>

<span id="more"></span><!-- more -->

<p>有关如何将增长堆栈应用于您的业务的详细说明，请查看我们关于<a href="https://mobilegrowthstack.com/applying-the-mobile-growth-stack-81b0f6ca66bf#.1ia4twj7u">应用增长栈的文章</a></p>

<h2 id="toc_1">历史与进化</h2>

<p>Andy Carvell 由Andy Carvell开发和发布的。 Andy花了15 年的职业生涯开发和发布移动产品和服务，而且他用了 4.5 年时间专注于SoundCloud的移动用户的增长。Andy和前SoundCloud增长团队成员Moritz Daan现在根据他们与全球各种应用开发商和发行商合作的经验，将他们整合在一起， 开发了<a href="https://www.phiture.com/">Phiture</a> -- 移动增长顾问</p>

<p>您可以阅读以下有关该堆栈的原始博文：</p>

<p><a href="https://medium.com/@andy_carvell/the-mobile-growth-stack-3ffa6856f482">移动增长堆栈</a></p>

<p><a href="https://medium.com/@andy_carvell/2015-the-mobile-growth-stack-revised-58f5d11d43f3">2015年：移动增长堆栈修订</a></p>

<p>有关将增长堆栈和“堆栈思维”应用于您的业务的深入指南，请查看本站点上的随附文章“<a href="https://mobilegrowthstack.com/applying-the-mobile-growth-stack-81b0f6ca66bf#.1ia4twj7u">应用堆栈</a>”。</p>

<h2 id="toc_2">工作原理</h2>

<p>增长栈有三个水平层，代表关键目标：获渠，参与/留存和变现，这三层都由第四层（洞察与分析）做支撑。</p>

<p>处于产品成熟度不同阶段的公司可能会优先考虑不同的层次，以实现其中短期业务目标。成功的战略需要在某个时刻在所有三个核心层产生影响。但是如果没有洞察和分析这是很难的。</p>

<p>堆栈中的每个元素（即每个单独的单元格）表示可以也不可以构成移动增长策略的一部分。 并非所有元素都同样适用于特定的app。 智能增长战略并不试图涵盖堆栈的每个元素，而是选择适当的活动组合来发挥核心优势，为近期增长提供最佳机会，并投资为下一个增长点带来能力和渠道和希望。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[业务流程设计]]></title>
    <link href="xuyushi.github.io/15318371632829.html"/>
    <updated>2018-07-17T22:19:23+08:00</updated>
    <id>xuyushi.github.io/15318371632829.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">业务流程图</h2>

<ul>
<li>产品设计的过程文件，类似于建筑图纸</li>
<li>产品设计，就是流程设计</li>
<li>凡是产品需求必有流程图</li>
</ul>

<h2 id="toc_1">做产品就是做流程</h2>

<ul>
<li>流程对了，后面的原型，需求文档，评审都容易了</li>
<li>传承，让你自己、同事、后续接手的人很容易交接</li>
<li>让参与者明确知道业务是如何运作的，快速开展工作</li>
<li>明确产品优化的过程与收益，设置考核指标更合理</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_2">不同阶段，业务流程的作用</h2>

<ul>
<li><strong>功能优化：</strong>看之前的业务流程，找改进点</li>
<li><strong>独立功能设计：</strong>单通道流程图，看用户，信息的流向</li>
<li><strong>独立产品设计：</strong>泳道图，复杂的用户，信息交互处理</li>
<li><strong>原型交互设计：</strong>页面流程图，规定页面的交互方向</li>
</ul>

<h2 id="toc_3">基本业务流程图包含什么</h2>

<ul>
<li><strong>事项：</strong>要完成的事情是什么？</li>
<li><strong>用户：</strong>分别有哪些人会参与到流程中</li>
<li><strong>信息：</strong>数据是怎么流转的</li>
<li><strong>异常：</strong>异常处理</li>
</ul>

<pre><code class="language-mermaid">graph TD
op1[明确用户与任务]
op2[开始与结束]
op3[明确顺序]
op4[异常情况]
op5[优化调整]
op6[输出]

op1 --&gt; op2
op2 --&gt; op3
op3--&gt; op4
op4--&gt; op5
op5 --&gt; op6

</code></pre>

<h2 id="toc_4">单通道的业务流程技巧</h2>

<ul>
<li><strong>主线清晰：</strong>关键路径、关键任务一目了然</li>
<li><strong>先主后次：</strong>先搞定关键路径，再补充细节</li>
<li><strong>优化调整：</strong>先把最长的路径想到，再合并操作流程</li>
</ul>

<h2 id="toc_5">业务流程图能力</h2>

<ul>
<li><strong>多看：</strong>多调研，体验各同类功能点</li>
<li><strong>多想：</strong>用产品的视角想想为什么是这样的设计</li>
<li><strong>多画：</strong></li>
<li><strong>多交流：</strong>多和功底好的同事交流</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[完整功能点设计]]></title>
    <link href="xuyushi.github.io/15318354800090.html"/>
    <updated>2018-07-17T21:51:20+08:00</updated>
    <id>xuyushi.github.io/15318354800090.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">所有产品都是由小功能构成的</h2>

<ul>
<li>产品经理不是功能经理，好的产品经理一定能做好功能</li>
<li>产品早期，功能为主，产品成熟后，对原有功能的迭代为主</li>
<li>完整的功能，一般需要经过简单的评审才能提交研发</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">明确功能目的</h2>

<p><strong>对用户</strong>对哪类用户具体有什么好处？有没有受影响的用户</p>

<ul>
<li>增加内容，提升准确度（如选择标签）</li>
<li>减少操作，提升便利性（推荐入口）</li>
<li>功能补充，提升体验</li>
</ul>

<h2 id="toc_2">目的性如何定</h2>

<h3 id="toc_3">对平台（内）</h3>

<p>对内部数据、操作人员是否提升的效率</p>

<ul>
<li>增加渠道，引入新用户</li>
<li>减少重复操作</li>
<li>数据分层，提升精准度</li>
</ul>

<h3 id="toc_4">商业</h3>

<p>是提高收入？还是提升了转化率</p>

<ul>
<li>拉倒付费转化率</li>
<li>增加新产品，创造心收入点</li>
<li>对原有数做重新组合，提高转化率</li>
</ul>

<h2 id="toc_5">制定功能方案</h2>

<ul>
<li>可能的解决方案有哪些</li>
<li>梳理每个方案的简要业务流程</li>
<li>针对性的分析，选择合适的方案</li>
<li>开发难度/见效/用户场景</li>
</ul>

<h2 id="toc_6">方案细化</h2>

<ul>
<li><strong>流程细化：</strong>梳理业务流程，增加异常情况</li>
<li><strong>考核指标：</strong>上线后如何评定功能点的效果</li>
</ul>

<h2 id="toc_7">原型和文档</h2>

<p>略</p>

<h2 id="toc_8">运营推广方案</h2>

<ul>
<li>找位置：用户的关键路径</li>
<li>定内容：匹配用户和场景，制定文案和推广形式</li>
<li>要效果：运营的转化效果，后续的计划</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[产品调研]]></title>
    <link href="xuyushi.github.io/15318107329806.html"/>
    <updated>2018-07-17T14:58:52+08:00</updated>
    <id>xuyushi.github.io/15318107329806.html</id>
    <content type="html"><![CDATA[
<p>功能调研何产品调研有什么区别</p>

<ul>
<li>共同点
<ul>
<li>目的性明确</li>
<li>注重底层逻辑流程</li>
<li>用户需求如何被满足</li>
</ul></li>
<li>不同点
<ul>
<li>功能调研
<ul>
<li>重业务流程</li>
<li>交互体验</li>
<li>突出亮点</li>
</ul></li>
<li>产品调研
<ul>
<li>重功能迭代过程</li>
<li>重产品结构</li>
<li>运营逻辑</li>
</ul></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->   

<h2 id="toc_0">选定目标产品</h2>

<ul>
<li>功能点调研：关注<strong>主流产品</strong>的相关模块
<ul>
<li>电商支付流程：京东，淘宝</li>
<li>社交网站注册流程：微信，qq，陌陌</li>
</ul></li>
<li>完整产品调研：关注<strong>龙头产品</strong>，1-2 个新晋热门产品
<ul>
<li>了解外卖服务流程：美团外卖，饿了么</li>
<li>记帐类产品的核心流程：挖财，网易有钱</li>
</ul></li>
</ul>

<h2 id="toc_1">功能点调研</h2>

<h3 id="toc_2">明确调研目的</h3>

<table>
<thead>
<tr>
<th>调研的类型</th>
<th>目的</th>
</tr>
</thead>

<tbody>
<tr>
<td>竞争对手上了新功能</td>
<td>能不能抄？要不要抄？调研后给播送 作决策依据</td>
</tr>
<tr>
<td>准备上的新功能，先看看别人怎么做的</td>
<td>哪个好？怎么抄？缩短产品设计的过程</td>
</tr>
<tr>
<td>以自我成长学习为目的</td>
<td>为什么这么做？判断自己的分析能力和判断力</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">数据表现</h3>

<ul>
<li>覆盖率</li>
<li>发布量</li>
<li>成交量</li>
</ul>

<h3 id="toc_4">对于自己的产品来说的意义</h3>

<ul>
<li>要不要抄：和用户群是否符合？数据情况如何 </li>
<li>能不能抄：是否有技术壁垒？是否有特殊门槛</li>
<li>结论是什么</li>
</ul>

<h3 id="toc_5">核心问题</h3>

<ul>
<li>新的功能点有哪些？最关键（你准备调研）的是哪个</li>
<li>用户、需求、场景是否被满足了</li>
<li>底层逻辑、产品流程大概是什么样</li>
<li>产品的亮点是什么？为什么</li>
<li>数据表现</li>
</ul>

<h3 id="toc_6">功能调研的误区</h3>

<ul>
<li>没结论</li>
<li>不愿意做</li>
<li>杂</li>
<li>费要提改进意见</li>
</ul>

<h2 id="toc_7">针对产品的调研</h2>

<ul>
<li>了解产品功能，看产品的表现</li>
<li>通过迭代的过程，看产品实现的逻辑</li>
<li>透过一个产品，看穿一个行业</li>
</ul>

<h3 id="toc_8">产品调研全过程流程图</h3>

<pre><code class="language-dot">digraph p2{
    //图设置
    rankdir = TB
    
    node [ shape=&quot;record&quot;, width=.1, height=.1];
    node [fontname = &quot;Verdana&quot;, fontsize = 11, color=&quot;black&quot;, shape=&quot;record&quot;];
    edge [fontname = &quot;Verdana&quot;, fontsize = 9, color=&quot;black&quot;, style=&quot;solid&quot;, arrowsize = 0.6];
    
    调研背景 -&gt; 明确目的
     start -&gt; inim
    
｝
</code></pre>

<p><img src="media/15325273985685/15325278326377.jpg" alt="" style="width:928px;"/></p>

<h3 id="toc_9">针对独立产品的调研怎么做</h3>

<ul>
<li>用户：有哪些类型的用户</li>
<li>场景：不同类型的用户，分别在什么场景下会使用</li>
<li>需求：产品满足了哪些需求 </li>
</ul>

<h3 id="toc_10">产品逻辑</h3>

<ul>
<li>用户的流向：都有哪些用户，怎么发生联系的</li>
<li>数据的流向：产生的数据流是如何运转的</li>
<li>汇合点：用户、数据的在哪个关键页面回合</li>
<li>关键路径：用户操作的关键功能、页面是什么</li>
</ul>

<h3 id="toc_11">通过迭代路径找到关键点</h3>

<h3 id="toc_12">产品的表现如何</h3>

<ul>
<li>数据表现：使用数据、排名数据、评分数据</li>
<li>用户表现：用户点评、产品点评</li>
</ul>

<h3 id="toc_13">多个相同的产品调研</h3>

<ul>
<li>找相同 找不同</li>
<li>关键功能的差异</li>
</ul>

<h3 id="toc_14">出结论</h3>

<ul>
<li>相比优点、缺点、亮点</li>
<li>如果要抄，抄什么？怎么抄？</li>
</ul>

<h3 id="toc_15">明确目的比功能全面更重要</h3>

<ul>
<li>目标：用来做什么？期望</li>
<li>成本：如果自己做，能用 是如何 的？</li>
<li>关联性：第三方产品和你完成目标之间的关联</li>
<li>其他：价格、服务、会不会倒闭等</li>
</ul>

<h3 id="toc_16">深度体验产品</h3>

<ul>
<li>体验产品的过程中，重点关注用户、使用场景需求</li>
<li>把用户、场景、需求明确下来 ，尽可能找到对应的用户做简单的访谈</li>
<li>找出用户视角的产品实现逻辑</li>
</ul>

<blockquote>
<p>用户是谁？使用场景，满足的需求</p>
</blockquote>

<h3 id="toc_17">还原产品</h3>

<ul>
<li>重点关注解决用户需求的过程</li>
<li>还原产品，最终要关注的是流程，而非界面</li>
</ul>

<blockquote>
<p>核心流程，核心页面，产品结构</p>
</blockquote>

<h3 id="toc_18">分析产品</h3>

<ul>
<li>从产品的视角来分析 ，而不是自我感觉</li>
<li>重点关注产品表现，而非界面</li>
<li>不要做看似专业且复杂的分析，通常用户流程终点使用过程，数据已经表现出来了</li>
</ul>

<blockquote>
<p>关键数据，产品表现，数据猜测</p>
</blockquote>

<h3 id="toc_19">产品迭代、运营分析</h3>

<ul>
<li>现在很重要，但发展过程更重要</li>
<li>从产品迭代中可以发现别人踩过的坑</li>
<li>从运营过程中可以发现产品的表现和重要程度</li>
</ul>

<h3 id="toc_20">常见的迭代、运营调研工具</h3>

<ul>
<li>Appstroe: 了解一个产品的基本概况、评价</li>
<li>appannie/应用雷达/七麦：了解更新历史、排名、评价、数据</li>
<li>google 新闻：按实践段搜索产品的新闻稿，了解运营简单过程</li>
<li>淘宝等：如果有会员消费，能看到折扣比例，判断热门程度</li>
<li>手机中国 手机乐园：下载安装安卓版的历史版本</li>
</ul>

<h3 id="toc_21">横向比较同类产品</h3>

<ul>
<li>与同类产品相比，分别处于什么位置</li>
<li>找到产品之间的核心差异点</li>
<li>总结分析同类产品的优缺点</li>
</ul>

<blockquote>
<p>竞争格局，产品差异，总结分析 </p>
</blockquote>

<h3 id="toc_22">调研分析报告</h3>

<ul>
<li>清晰明确的结论</li>
<li>逻辑清晰的表达调研的过程和结论之间的关联</li>
<li>抓重点，说正事</li>
<li>调研报告不带个人色彩，以中立的角度来描述</li>
<li>可读性强，照顾读者</li>
</ul>

<h3 id="toc_23">推广报告</h3>

<ul>
<li>内部分享：再公司内部建立起分享会</li>
<li>外部分享：在第三方平台表达出来</li>
</ul>

<h1 id="toc_24">产品调研 的误区</h1>

<ul>
<li>产品调研 不等于 行业调研</li>
<li>产品调研 不等于 产品体验报告</li>
<li>不要用看起来很高深的分析证明自己的正确性</li>
<li>二三手数据不能证明你正确</li>
<li>非得加改进建议</li>
<li>大而全</li>
<li>强烈的个人倾向</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用思维导图梳理用户需求]]></title>
    <link href="xuyushi.github.io/15316593971293.html"/>
    <updated>2018-07-15T20:56:37+08:00</updated>
    <id>xuyushi.github.io/15316593971293.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">产品设计的核心三要素</h2>

<p>产品设计就是不断解决用户在特定场景下的需求，增加、减少需求并非最关键，关键是能不能解决用户的问题</p>

<ul>
<li>用户</li>
<li>场景</li>
<li>需求</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">思维导图的思考方式</h2>

<ul>
<li>用户：当想到一个功能，先不用考虑怎么实现，而应该想谁会用</li>
<li>场景：用户分别在什么情况下会用（感兴趣）</li>
<li>问题：用户<strong>分别</strong>在上述场景下，会遇到什么问题挑战</li>
<li>方案：用户现在的解决方案是什么</li>
</ul>

<h2 id="toc_2">举个例子</h2>

<p>输入法的面对面翻译功能</p>

<blockquote>
<p>类似于翻译机的实时翻译功能</p>
</blockquote>

<p><img src="media/15316593971293/15317283713594.jpg" alt=""/></p>

<h3 id="toc_3">潜在的用户有哪些</h3>

<ul>
<li>谁会面对面翻译感兴趣</li>
<li>思维导图列出所有感兴趣的人</li>
<li>不用思考行不行，把能想到的穷举</li>
</ul>

<h3 id="toc_4">不同的用户分别碰到什么问题</h3>

<ul>
<li><strong>分别</strong>！！ 不要怕重复</li>
<li>不同的群体，不同的场景，问题是不同的</li>
<li>区分“问题”和“中性次”，如时间，价格，要写成时间短，价格高等</li>
</ul>

<h3 id="toc_5">现在的解决方案是</h3>

<ul>
<li>是用户现有的解决方案 ，而不是你要做的功能解决方案</li>
<li>有很多用户也没有解决方案</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[需求优先级]]></title>
    <link href="xuyushi.github.io/15317376170439.html"/>
    <updated>2018-07-16T18:40:17+08:00</updated>
    <id>xuyushi.github.io/15317376170439.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">四象限看用户量与发生频率</h2>

<ul>
<li>优先解决大量用户的高频问题，基础体验</li>
<li>最后解决少量用户的低频问题，超好体验
<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_1">案例 某垂直电商平台</h3>

<ol>
<li>订单流程、商品详情页</li>
<li>设置、个人资料</li>
<li>商家入驻、商家管理后台</li>
<li>发票</li>
</ol>

<h2 id="toc_2">看开发难度和效果</h2>

<ul>
<li>优先见效快开发难度不大的，迭代</li>
<li>最后做费劲见效慢的，可能是未来的机会</li>
</ul>

<h2 id="toc_3">看产品价值</h2>

<ul>
<li>迫切程度：用户是不是真的非常需要？还是空想的？</li>
<li>付费意愿：用户是否会为了解决问题而付费</li>
<li>ARPU:如果开发出来，用户会为之付多少钱</li>
</ul>

<h2 id="toc_4">看对目标群体的熟悉程度</h2>

<ul>
<li>你是否深入了解用户使用场景</li>
<li>你对用户群体的理解是否足够深入</li>
<li>如果不熟悉，就相伴法熟悉，否则不要动手</li>
</ul>

<h2 id="toc_5">总结结论</h2>

<ul>
<li><strong>用户：</strong>这个功能，第一批的核心用户是谁</li>
<li><strong>场景：</strong>这个用户在什么场景下会使用</li>
<li><strong>问题：</strong>解决了这个用户最大的痛点是什么</li>
<li><strong>对比：</strong>和用户现在的解决方案比，体验/效率提升有多大</li>
</ul>

<h2 id="toc_6">其他</h2>

<ul>
<li>优先级需求的定义要基于当时的环境和实际情况</li>
<li>用户的需求是一个动态变化的过程</li>
<li>产品和运营不分家，再确保满足基本型需求的同时，也要适当考虑满足用户期望型和兴奋型需求</li>
</ul>

<h2 id="toc_7">用户需求重要性的判断标准：</h2>

<ul>
<li>用户基数</li>
<li>使用频率</li>
<li>类别重要性
<ul>
<li>基本型：产品的性能，安全，兼容性等，具有最高优先级</li>
<li>期望型：功能渗透率 x 人均使用次数 x 类别重要性百分比</li>
<li>兴奋型</li>
</ul></li>
</ul>

<h1 id="toc_8">思考题</h1>

<p>【作业题目】给以下需求优先级排序滴滴打车早期第一版核心打车功能已上线，需要对下列功能优先级排序</p>

<ol>
<li>新增“愿等时间”，多等司机一会儿，提高打车成功率</li>
<li>电量优化，叫车更省电</li>
<li>优先文字叫车，更容易更快打到车</li>
<li>定位信号弱时，可自己设置上车点</li>
<li>支付时默认选车券，省钱便捷</li>
<li>即时聊天开放，沟通更方便</li>
</ol>

<table>
<thead>
<tr>
<th>方案</th>
<th>用户量</th>
<th>频率</th>
<th>价值</th>
<th>需求类别</th>
<th>开发成本</th>
</tr>
</thead>

<tbody>
<tr>
<td>1 新增“愿等时间”，多等司机一会儿，提高打车成功率</td>
<td>较多</td>
<td>较多</td>
<td>高</td>
<td>基本</td>
<td>低</td>
</tr>
<tr>
<td>2 电量优化，叫车更省电</td>
<td>很少</td>
<td>很少</td>
<td>低</td>
<td>兴奋</td>
<td>高</td>
</tr>
<tr>
<td>3 优先文字叫车，更容易更快打到车</td>
<td>多</td>
<td>较多</td>
<td>高</td>
<td>基本</td>
<td>中</td>
</tr>
<tr>
<td>4 定位信号弱时，可自己设置上车点</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>基本</td>
<td>中</td>
</tr>
<tr>
<td>5 支付时默认选车券，省钱便捷</td>
<td>多</td>
<td>中</td>
<td>低</td>
<td>期望</td>
<td>低</td>
</tr>
<tr>
<td>6 即时聊天开放，沟通更方便</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>兴奋</td>
<td>高</td>
</tr>
</tbody>
</table>

<p>1-&gt;3-&gt;4-&gt;6-&gt;2-&gt;5</p>

<blockquote>
<p>值得注意的是<code>5 支付时默认选车券，省钱便捷</code> ，处于支付阶段，用户已经基本完成打车流程，价格敏感的用户会自己勾选，不敏感的用户可以节约运营成本 ，忘记勾选的用户增加了用户粘性</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用户调研]]></title>
    <link href="xuyushi.github.io/15316240502263.html"/>
    <updated>2018-07-15T11:07:30+08:00</updated>
    <id>xuyushi.github.io/15316240502263.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">为什么要用户调研</h2>

<ul>
<li>了解用户对产品的使用过程</li>
<li>了解目标用户群使用场景和过程</li>
<li>总结用户的问题和流程</li>
<li>提出最合理的解决方案 </li>
</ul>

<h2 id="toc_1">用户调研全过程</h2>

<ol>
<li>明确背景和目的</li>
<li>选择目标用户</li>
<li>分析用户和问题</li>
<li>准备调研内容</li>
<li>现场调研</li>
<li>总结报告</li>
</ol>

<span id="more"></span><!-- more -->

<h3 id="toc_2">用户调研全过程</h3>

<ul>
<li>背景：什么情况下发起的调研?是否必须通过调研来解决？</li>
<li>目的：通过用户调研希望得到的结果是什么？</li>
<li>忌大而全：调研的方向越聚焦，越有价值</li>
<li>忌家大空：针对行业用户的调研 ，针对满意度的调研，价值都不大</li>
</ul>

<table>
<thead>
<tr>
<th>bad</th>
<th>原因</th>
<th>good</th>
</tr>
</thead>

<tbody>
<tr>
<td>对本站用户 做针对性调研</td>
<td>目的不明确</td>
<td>* 在支付阶段用户流失原因调研分析 * 用户在不同在线学习平台学习过程调研</td>
</tr>
<tr>
<td>做北京地区女性用户使用情况调研</td>
<td>背景不明确</td>
<td>北京地区女性下单转化率很高，调研其在平台购买路径分析</td>
</tr>
<tr>
<td>O2O 行业用户使用习惯调研</td>
<td>大而全</td>
<td>* 京东到家超市业务白领女性消费习惯调研 </td>
</tr>
</tbody>
</table>

<h3 id="toc_3">选择目标用户</h3>

<ul>
<li>典型用户：通过简单的用户画像，找出典型用户</li>
<li>目标用户：时间、地点、配合程度</li>
<li>邀约用户：直接说明目的，并告知可能发生的情况</li>
<li>用户数量：不宜扫网式，一般5-10个</li>
</ul>

<h3 id="toc_4">猜测用户问题 设定题目</h3>

<ul>
<li>用户可能的问题：用户的使用行为表现</li>
<li>可能的解决方案：猜测解决用户问题的手段</li>
<li>确定访问提纲：聚焦且开放的问题</li>
<li>问题数量：线上10-20，线下5-10 展开</li>
</ul>

<h3 id="toc_5">准备调研内容</h3>

<ul>
<li>本品已知问题：用户操作习惯、消费习惯和过程，原因</li>
<li>本品未知问题：用户的痛点是什么？哪些操作用户很烦，用户愿意掏钱做什么？</li>
<li>竞品已知问题：用户直观感知两者区别，竞品使用差异</li>
<li>竞品已知问题：如果从竞品移入，用户放弃理由。从本品移到竞品，原因？ </li>
</ul>

<p><img src="media/15316240502263/15316441642224.jpg" alt="" style="width:737px;"/></p>

<h3 id="toc_6">现场调研</h3>

<ul>
<li>了解用户使用的过程：最好观察用户的行为</li>
<li>提问：对关键行为、预设问题进行提问</li>
<li>反馈：对有效的信息反馈给用户，并深究</li>
</ul>

<h4 id="toc_7">让用户完成明确的任务</h4>

<ul>
<li>给用户一到两个明确的任务（基于你之前对用户 的分析）</li>
<li>让用户自行使用并完成任务（不做任何主动指导和讲解）</li>
<li>从用户完成任务的过程中，从场景中发现问题</li>
<li>不同类型的用户，尽量分开做，不同的任务分开做</li>
</ul>

<h4 id="toc_8">分析用户卡住的原因 猜测可能的问题</h4>

<ul>
<li>重点关注异常行为</li>
<li>重点关注用户的表现</li>
<li>重点关注用户的表情</li>
</ul>

<blockquote>
<p>比如停留时间长，来回切换，用户放弃任务</p>
</blockquote>

<h4 id="toc_9">用户试图解决什么问题 ？为什么</h4>

<ul>
<li>用户拿到任务之后，是怎么思考得</li>
<li>认为需要完成工作，大约需要怎么做</li>
<li>针对关键点，完整描述对象 ，并提问</li>
<li>追问为什么</li>
<li>完成一个行为和问题收集
<ul>
<li>在一个完整路径上追问</li>
<li>用聚焦且开放的问题，引导用户说出自己的想法</li>
<li>打破砂锅问到底</li>
</ul></li>
</ul>

<h4 id="toc_10">用户觉得有什么方法能更好的解决问题</h4>

<ul>
<li>机遇用户完成任务的过程中遇到的问题</li>
<li>用户任务可以怎么做，会更好提升体验</li>
<li>继续追问为什么</li>
<li>演示新的解决方案看用户的感受</li>
</ul>

<h3 id="toc_11">调研报告</h3>

<ul>
<li>单个用户：记录单用户调研情况</li>
<li>整体情况：汇总用户调研的过程和结论</li>
<li>行动计划：分享并提出行动计划</li>
</ul>

<h2 id="toc_12">用户调研的常见误区</h2>

<ul>
<li>指望从用户调研中获取需求是产品经理懒惰的表现</li>
<li>用户调研不等于用户访谈，访谈只是其中的一种方式</li>
<li>把个体当整体</li>
<li>从用户调研中找自我感觉的证明</li>
<li>用户调研的结论不要谈占比</li>
</ul>

<h2 id="toc_13">忌讳</h2>

<ul>
<li>直接问用户想要什么，有什么需求</li>
<li>直接问用户有没有用，好不好用</li>
<li>快速打断用户</li>
<li>说服用户</li>
</ul>

<h2 id="toc_14">如何让用户开口</h2>

<ul>
<li>让用户讲自己 的经历，把用户当采访对象</li>
<li>鼓励，少打断，多鼓励用户表达，期待的眼神</li>
<li>刺激，说反话，聊对立的用户，让用户表达看法 </li>
</ul>

<h2 id="toc_15">设计改善措施</h2>

<p><img src="media/15316240502263/15316452423278.jpg" alt=""/></p>

<ul>
<li>认知缺口：产品经理不知道用户想要的是什么。若出现了认知缺口，则首先是让产品经理清楚知道用户流失的真正原因。</li>
<li>执行缺口：产品经理知道用户想要什么，但实际做出来的产品与设计中的不一致。若出现了执行缺口，则要了解具体哪个执行步骤出现问题，是资源的欠缺还是技术难以实现。</li>
<li>传递缺口：产品的宣传和指引不能让用户对产品真正认知了解若出现了传递缺口，则要了解用户现在的感知是怎么样的，在哪些宣传和指引上出现了问题。</li>
<li>流失缺口：用户体验到的产品和期望的不一样。</li>
</ul>

<h1 id="toc_16">拓展</h1>

<blockquote>
<p><a href="http://cdc.tencent.com/2013/07/03/%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E5%8E%9F%E5%9B%A0%E8%B0%83%E7%A0%94%E5%9B%9B%E6%AD%A5%E7%BB%8F/">用户流失原因调研四步经</a> <br/>
<a href="https://www.zhihu.com/question/20345655/answer/19110604">如何去做用户访谈和用户调研</a><br/>
<a href="http://blog.sanjieke.cn/article/144538.html">如何做好用户调研</a><br/>
<a href="http://www.yunzhan365.com/59771541.html">如何做一次完美的用户调研</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用户反馈发现问题]]></title>
    <link href="xuyushi.github.io/15316220023386.html"/>
    <updated>2018-07-15T10:33:22+08:00</updated>
    <id>xuyushi.github.io/15316220023386.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">关注什么问题</h2>

<ul>
<li>自身产品的问题</li>
<li>竞品的问题</li>
<li>可能的机会点</li>
</ul>

<h2 id="toc_1">渠道</h2>

<h3 id="toc_2">渠道类型</h3>

<ul>
<li>公开渠道：apple store，微博，贴吧，第三方应用商城</li>
<li>半公开渠道：微信，朋友圈，用户评价</li>
<li>内部渠道：用户投诉，电话录音
<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_3">处理策略</h3>

<ul>
<li>公开渠道：勤搜索、关键词订阅、自动化监控</li>
<li>半公开渠道：定期搜索关键字、定期分析用户评论</li>
</ul>

<h3 id="toc_4">内部渠道</h3>

<ul>
<li>整合内部用户反馈渠道</li>
<li>定期与一线同事沟通</li>
<li>到一线去</li>
</ul>

<h2 id="toc_5">主流应用商店与常用工具</h2>

<ul>
<li>iOS：AppStore</li>
<li>Android：360手机助手、安卓市场、百度手机助手 、小米/华为、oppo 等商城、豌豆荚</li>
<li>常用工具：AppAnnie、应用雷达、ASO114、七麦</li>
</ul>

<h3 id="toc_6">应用商城监控</h3>

<ul>
<li>低分差评：重点看1-3 分</li>
<li>有效评论：重点看有实际描述的评论</li>
<li>异常行为：比如水军刷榜、恶意评价</li>
<li>竞品变化：监控竞对的应用变化</li>
</ul>

<h2 id="toc_7">主流社交平台与常用工具</h2>

<ul>
<li>主流平台：微博、贴吧、知乎、雪球等</li>
<li>工具：关键字、收藏夹、微博企业版、百度、google</li>
</ul>

<h2 id="toc_8">用户点评看什么</h2>

<ul>
<li>差评：为什么差评？原因、现象是什么</li>
<li>描述：重点看有实际描述的评论</li>
<li>异常行为：刷榜、恶意评价</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[abtest 数据分析]]></title>
    <link href="xuyushi.github.io/15299133098726.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133098726.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">背景</h1>

<p>在设计A/B测试时，总有一个无法避免的问题：实验数据的结果是样本数据的波动还是真实的数据提升？答案取决于数据的提升和样本量，需要使用数理统计的方法判断实验结果的科学性。</p>

<span id="more"></span><!-- more -->

<h1 id="toc_1">基础概念</h1>

<p>由于数据分析需要比较多的概念，在本节统一做介绍 <strong>（有基础的可略过本节）</strong></p>

<h2 id="toc_2">总体与样本</h2>

<p>总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。</p>

<p>实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。</p>

<p>抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。</p>

<p>抽样最重要的一点就是要尽量保证样本具有<strong>代表性</strong>，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。</p>

<h2 id="toc_3">统计量及其分布</h2>

<p>在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。</p>

<h3 id="toc_4">正态分布</h3>

<p>正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 x=μ 对称的钟形曲线，方差 σ2 决定了曲线中峰的陡峭程度。其中，μ 是正态分布的数学期望，\(σ^2\)是正态分布的方差，正态分布记为 X∼N(μ,\(σ^2\))。μ=0 且 \(σ^2\)=1 时的正态分布称为标准正态分布，记为 X∼N(0,1)。</p>

<p><img src="media/15299133098726/15269536482648.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_5">t分布</h3>

<p>通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当<strong>样本量不足的时候，误差较大，所以需要应用t分布来计算</strong>。</p>

<p>分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。</p>

<p><img src="media/15299133098726/15269537711881.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_6">参数估计</h2>

<p>根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。</p>

<p>参数估计的形式有两种：</p>

<ul>
<li>点估计：根据样本估计参数的近似值</li>
<li>区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高</li>
</ul>

<h3 id="toc_7">置信区间</h3>

<p>置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。</p>

<p><img src="media/15299133098726/15269540524945.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_8">假设检验</h2>

<p>假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。</p>

<p>假设检验运用了反证法，其一般流程是</p>

<ul>
<li>提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能</li>
<li>选择检验方法和检验统计量</li>
<li>在原假设下推导统计量的分布，比如正态分布或t分布等</li>
<li>选择显著性水平</li>
<li>计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。</li>
</ul>

<h3 id="toc_9">显著性检验</h3>

<p>拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。</p>

<p>不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 α，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 β。</p>

<p>由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 α 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验</p>

<h3 id="toc_10">双侧检验，单侧检验</h3>

<p>实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：</p>

<ul>
<li>双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端</li>
<li>单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧</li>
</ul>

<p><img src="media/15299133098726/15269547975976.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_11">检验方法</h3>

<p>上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。</p>

<p>比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。</p>

<p>总体方差已知：Z检验<br/>
总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差<br/>
总体方差未知，样本量小于30：t检验</p>

<h3 id="toc_12">Z检验</h3>

<p>todo</p>

<h3 id="toc_13">t检验</h3>

<p>todo</p>

<h3 id="toc_14">p-value</h3>

<p>在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。</p>

<p><img src="media/15299133098726/15269558290250.png" alt=""/></p>

<h1 id="toc_15">ABtest中的假设检验</h1>

<blockquote>
<p>In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]<br/>
A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.<br/>
– wikipedia</p>
</blockquote>

<p>即，A/B 测试是一种两样本的随机对照试验，<strong>在统计学上是一种两样本的假设检验</strong>。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异。<strong>从 A/B 测试的试验原理来看，它是统计学上假设检验(显著性检验)的一种形式。</strong></p>

<!--假设检验一般有四个步骤，我们以两独立样本比率检验(two independent sample evaluation)作为案例。假设微信想通过改变注册流程来提高新用户注册成功的比率。

###第一步：提出假设

一般而言有两种假设，分别是原假设(null hypothesis)和备择假设(alternative hypothesis)。原假设一般比较消极，即新注册流程与旧流程并无不同。相对应的备择假设为新注册流程与旧流程有差别。设立两种假设的逻辑是，除非在数据明显的反对原假设时，我们一般不拒绝原假设，也就是默认原假设为真。而这种“保护”会通过“容错率”来体现。

### 第二步：提取随机样本
在设置好两种注册流程之后，实验将随机选取一部分新用户提供新的流程，而剩下的一部分仍然使用老的流程。值得注意的是样本的选取一定要是随机的(random)，而且每个用户必须持续的只接收到一种流程(persistent manner)。随机分配(random split)并不要求平均分配。

### 第三步：计算检验统计量
在收集完数据后，我们需要计算检验统计量(test statistics)。检验统计量是一个用来衡量数据是否支持原假设的统计量。在这个案例中，检验统计量是

$$Z=\frac{p_t-p_c}{\sqrt{(\frac{p_t(1-p_t)}{n_t}+\frac{p_c(1-p_c)}{n_c})}}$$

其中p_t和p_c分别代表新流程和旧流程的注册成功率，n_t和n_c分别代表两者的样本数量，p_t p_c代表结合的注册成功率。直观上而言，检验统计量是取出两者成功率的差值，并通过标准差进行了标准化。如果这个检验统计量绝对值越大，就代表数据越反对原假设。

### 第四步：决定是否拒绝原假设
此时我们需要通过检验统计量绝对值的大小来判断是否拒绝原假设。在原假设下，检验统计量应该服从某种标准的分布。例如在微信的例子中，检验统计量在原假设情况下近似服从标准正态分布。当检验统计量的数值极端到在原假设时，它和更极端的情况，发生的概率非常小时，我们就说样本明显的反对原假设，因此拒绝。我们也用p值来衡量样本是否支持原假设。

-->

<p>随机将测试用户群分为2部分，用户群1使用A方案，用户群2使用B方案，经过一定测试时间后，根据收集到的两方案样本观测数据，根据显著性检验结果选取最好方案。</p>

<p>为了下文方便说明，我们不妨设A方案为参考方案（或旧方案），B方案为实验方案（或新方案）。以下我们以某流程转化率为例。</p>

<h3 id="toc_16">选取观测指标</h3>

<p>使用A方案的人数\(N_A\)，使用B方案的人数\(N_B\)，通常情况下\(N=N_A=N_B\)；</p>

<p>由样本计算出A方案转化率为\(P_a\)，B方案的转化率 为\(P_b\)</p>

<p>总体A的分布：\(A～B(N,P_a)\)，总体B的分布：\(A～B(N,P_b)\)；</p>

<p>根据中心极限定理可知，\(P_a\)和\(P_b\)均可认为近似服从正态分布：\[A～N(N,P_a(1-P_a)/N_a)\] \[B～N(N,P_b(1-P_b)/N_b)\]</p>

<p>所以根据正态分布的性质 \[X=P_b - P_a = N( P_b - P_a, (\frac{P_a(1-P_a)}{N_a}) + (\frac{P_b(1-P_b)}{N_b}))\]</p>

<h3 id="toc_17">建立原假设和备择假设</h3>

<p>由于我们的期望结果是B方案的转化率高于A 方案的转化率，所以原假设和备择假设如下：<br/>
\[H_0: X=P-b - P_a &lt;=0\]<br/>
\[H_0: X=P-b - P_a &gt;0\]</p>

<p>构建检验统计量<br/>
 \[Z=P_b - P_a = N(P_b - P_a, (\frac{P_a(1-P_a)}{N_a}) + (\frac{P_b(1-P_b)}{N_b})  )\]</p>

<h3 id="toc_18">显著性检验结论</h3>

<p>给定显著性水平为。当时\(Z&gt;Z_α\)，拒绝原假设，认为B方案的转化率高于A 方案，建议可以进行推广；当时\(Z&lt;=Z_α\)不能拒绝原假设，即认为B方案的转化率不高于A 方案，建议暂不建议进行推广。</p>

<blockquote>
<p>一般采用 α=0.05，置信度95%，则Z=1.644854</p>
</blockquote>

<!--# 参考
> https://zhuanlan.zhihu.com/p/21731601
> https://blog.csdn.net/buracag_mc/article/details/74905483
> https://www.zhihu.com/question/23680352  显著水平和pvalue 关系
> https://zhuanlan.zhihu.com/p/33415389 显著性样本？
> http://solnotes.com/2016/10/08/simple-stats-in-abtesting/
> https://zhuanlan.zhihu.com/p/21731601
> https://zhuanlan.zhihu.com/p/21829614-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABtest 平台框架]]></title>
    <link href="xuyushi.github.io/15299133098793.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133098793.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">背景</h2>

<p>目前输入法内部功能迭代，主要是通过灰度和小渠道的策略，对比新版本和旧版本的数据指标。存在着以下问题</p>

<ol>
<li>数据可能收到渠道、周期波动等因素的干扰</li>
<li>缺少聚合对比数据 指标的平台，不方便做决策</li>
<li>同时上线多个feature 对指标可能互相影响</li>
<li>新功能存在风险</li>
</ol>

<span id="more"></span><!-- more -->

<h2 id="toc_1">ABtest</h2>

<p>使用abtest平台能解决上述问题，并且具有以下优势</p>

<ol>
<li>数据共享：不限于端上的需求实验，服务端/前端页/商业化 等都能通过abtest 平台做决策</li>
<li>实验隔离：使用多层分流结构，可以同时上线多个AB实验，每个实验之间隔离，数据指标互不影响</li>
<li>风险可控：ab 实验采用动态下发机制，随时控制功能上下线</li>
<li>指标聚合：核心指标、分类指标数据聚合，易于得出结论，方便做决策</li>
<li>扩展空间：后续可扩展为消费者BG 的共享平台</li>
</ol>

<h2 id="toc_2">A/B测试的三大特性：先验、并行、科学</h2>

<ul>
<li>先验性： A/B测试结果属于预测型结论，与“后验”的归纳性结论差别巨大。后验的方式是先将版本发布，再通过数据验证效果，而A/B 测试用很少的样本量来推断新版本在全流量下的效果。</li>
<li>并行性： A/B测试将两个或以上的方案同时在线试验，保证每个版本所处环境的一致性，同时节省了验证的时间，无需在验证完一个版本之后再测试另一个。</li>
<li>科学性： A/B 测试的正确做法是将相似特征的用户均匀的分配到试验组中，确保每个组别的用户特征的相似性，从而避免辛普森悖论。</li>
</ul>

<p>A/B测试试验是产生用户阻力的地方，也是增长前进的核心动力。</p>

<h2 id="toc_3">实验流程</h2>

<p><img src="media/15299133098793/15264426763763.png" alt=""/></p>

<h2 id="toc_4">方案</h2>

<p>采用服务端多层分流方案，整体架构包括以下几个部分</p>

<p><img src="media/15299133098793/15262797128472.png" alt=""/></p>

<ul>
<li>AB 实验配置平台：产品经理/研发平时配置新实验</li>
<li>分流服务：读取 AB 实验配置平台的配置数据，执行具体的分流算法</li>
<li>集成方应用：客户端通过请求分流服务来获取具体加载哪些实验，上报实验分组和埋点</li>
<li>数据分析：分析打点数据，通过一定的数据分析算法，得出能够判断版本优劣的报表数据</li>
<li>AB实验展示平台：图标方式展示处理过的数据，方便人员做决策</li>
</ul>

<h1 id="toc_5">ABtest sdk 需求文档见附件</h1>

<!--## 人员配置
* 服务端：1 名（分流策略，处理端上上报数据）
* 大数据：1 名（数据处理/生成报表数据）
* 数据分析师：1 名（abtest 数据指标，数据处理策略，实验指标评判标准）
* 产品经理：1 名 （ab 配置平台，ab 数据平台，端上策略，分流策略，项目管理）
* Android ：1 名（abtest sdk，输入法接入，数据上报）
* UI：1 名（内部平台页面设计）
* QA: 1名 （服务端前段页面，分流策略，客户端逻辑测试）
> 人员暂定，具体时间节点按照排期决定
-->

<!--## 时间节点


| 时间  | 规划 | 备注  |
| --- | --- | --- |
| 05/17 - 05/25 | 产品细则制定，abtest 指标拟定 |  |
| 05/28 - 05/29 | 需求评审，UI 评估，技术选型，人员排期制定项目计划表 |  |
| 05/30 - 06/08 | 开发阶段 |  |
| 06/09 - 06/14 | 测试，bug 修复 |  |
| 06/15 - 06/18 | 灰度上线 |  |


> 时间为预估，具体排期待人力，需求明确后确定
-->

<!--
## 通用参数
1. 版本号
2. os version
3. 地域
4. 渠道
5. platform
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在离开北京的前夕]]></title>
    <link href="xuyushi.github.io/15299133099414.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099414.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15299133099414/15249794589499.png" alt="15249794589499"/></p>

<span id="more"></span><!-- more -->

<h1 id="toc_0">git init</h1>

<p>还记得15年那个夏天， 独自一人拖着个行李箱，连北京城的样子都还没见到，一路坐着地铁来到了五环外的一个城中村安顿了一个窝。一个人来到一座城市，定有一个理由。我当时的理由很简单 ——赚钱。那时的北京对我来说是一座完全陌生的城市，甚至陌生到没有一个朋友，一个同学。这一年学会了享受一个人时光，一个人看电影，一个人吃火锅。无拘无束，自由自在。</p>

<h1 id="toc_1">git add .</h1>

<p>在学校画pcb写单片机的我，确实没想过日后能从事互联网的工作。非常庆幸能在美团遇到这样一个机遇，还遇到一群这么好的同事。觉得每一天都很充实，海绵一样汲取着知识。渐渐的在这个城市有了朋友，可以和朋友一起跑步，狼人杀，撸串。。<br/>
北京是一个包容性很强的城市，无论你是什么妖魔鬼怪，你总能找到你的栖息地。<br/>
如果说美团是梦想起飞的地方，那么头条就像是一把火，用激情点燃梦想。 来头条一年多收获的很多，也很享受何和一群牛逼的同事做着改变世界的事情。</p>

<p><img src="media/15299133099414/15250202451953.png" alt="15250202451953" style="width:1100px;"/></p>

<h1 id="toc_2">git commit</h1>

<p>不得不承认北京是我生命的重要塑造者。至少我在毕业时，没想到在北京待着这三年能改变这么多。三年前的我很喜欢“天道酬勤”这个词？ 现在看来有些鸡汤满满，现在更喜欢“低调 务实 自驱 反思”。虽然我还是有点小懒，虽然不那么聪明，但是相比三年前的我很喜欢现在的我。有时也会想想，如果当年做的决定不是来北京，那我现在会是一个什么样的自己。</p>

<h1 id="toc_3">git checkout -b new_branch</h1>

<p>从来没想过在北京扎根，这是一个不属于我的城市，昂贵的房价并负担不起，户口也看不到希望，离开北京对于我来说只是时间问题。但离开了北京确实也舍弃了很多东西，也不清楚这次离开北京的选择是不是正确。</p>

<p>人一生有太多的选择，可能当年某个午后很小的选择，未来的一切都会变的不一样，如果当年没有读研？如果当年不选择来北京？如果当面选择继续做硬件？如果没有来头条？如果没有遇到她？之前每次回首自己做的重大决定，都很庆幸自己选择了正确的路。但细想下，也可能每条路的结果都不差看你怎么对待自己的选择，每条路都不是一帆风顺的，是抱怨后悔当初的决定？还是脚踏实地的向前？ 也可能这过程更为重要吧。同时也做了最坏的打算，真的觉得离开北京不适合，大不了再 <code>git checkout -b</code>一个继续撸咯。</p>

<p>还有不到24小时离开北京，没有太多的遗憾，只是有些不舍，舍不得的不是北京这座城，而是我的朋友们。愿我们未来一切都好。</p>

<blockquote class="blockquote-center">北京的小伙伴们，再见了，有缘的话。</blockquote>

<p><img src="media/15299133099414/15249794854372.png" alt="15249794854372" style="width:1100px;"/></p>

<p><img src="media/15299133099414/15250146162808.png" alt="15250146162808" style="width:1100px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins 平台搭建]]></title>
    <link href="xuyushi.github.io/15299133099249.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099249.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<h3 id="toc_1">java 环境搭建</h3>

<pre><code class="language-bash">java -version
</code></pre>

<p>如果显示Java版本号，说明已经正确安装，如果显示没有该命令，需要安装Java：<br/>
<span id="more"></span><!-- more --></p>

<h4 id="toc_2">mac</h4>

<pre><code class="language-bash">brew cask install java
</code></pre>

<h4 id="toc_3">linux</h4>

<pre><code class="language-bash">sudo yum install java
</code></pre>

<p>该命令如果检测到Java不存在可以直接安装Java,如果已存在则可以升级Java</p>

<p>环境配置 vim /etc/profile 追加</p>

<pre><code class="language-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64/
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
</code></pre>

<h3 id="toc_4">jenkins 安装</h3>

<h4 id="toc_5">mac</h4>

<pre><code class="language-bash">brew install jenkins 
</code></pre>

<h4 id="toc_6">Linux</h4>

<pre><code class="language-bash">sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo
sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
</code></pre>

<p>添加完成之后直接使用yum命令安装Jenkins:<br/>
<code>yum install jenkins<br/>
</code></p>

<h2 id="toc_7">启动</h2>

<p>命令行直接启动</p>

<p>mac </p>

<pre><code class="language-bash">Jenkins
</code></pre>

<p>linux </p>

<pre><code class="language-bash">sudo service jenkins start
Starting Jenkins                                           [  OK  ]
</code></pre>

<blockquote>
<p>默认端口 8080 可能冲突 需要修改  <code>vim /etc/sysconfig/jenkins</code></p>
</blockquote>

<h2 id="toc_8">环境配置</h2>

<blockquote>
<p>admin 密码 在 sudo cat /var/lib/jenkins/secrets/initialAdminPassword</p>
</blockquote>

<p>启动完毕后，打开浏览器，在地址栏中输入localhost:8080</p>

<p>系统管理 -&gt; 系统设置 ，填写Android 环境变量</p>

<p><img src="media/15299133099249/15240201058052.jpg" alt=""/></p>

<h1 id="toc_9">插件管理</h1>

<p>获取插件失败 ，需要将https 降级为http<br/>
<img src="media/15299133099249/15240202191693.jpg" alt=""/></p>

<p>系统管理 -&gt; 系统设置 -&gt; 插件管理 -&gt; 高级</p>

<p>升级站点改为 <br/>
<a href="http://mirrors.jenkins-ci.org/status.html">http://mirrors.jenkins-ci.org/status.html</a></p>

<p>下载插件</p>

<ul>
<li>Gradle</li>
<li>git</li>
<li>gitlab</li>
<li>ssh</li>
<li>等</li>
<li><br/>
## 新建项目
<img src="media/15299133099249/15240215365291.jpg" alt=""/></li>
</ul>

<p>可以增加参数化的构建</p>

<p><img src="media/15299133099249/15242012652458.jpg" alt=""/></p>

<p>打包完后工作空间即可生成对应的打包文件</p>

<p><img src="media/15299133099249/15240222554515.jpg" alt=""/></p>

<blockquote>
<p>构建local 文件 需要，file:// + <git 仓库文件路径></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gitlab 搭建]]></title>
    <link href="xuyushi.github.io/15299133099310.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099310.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">安装</h1>

<pre><code class="language-bash">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
yum install gitlab-ce
</code></pre>

<span id="more"></span><!-- more -->

<!--```bash
Retrieving key from https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey
Importing GPG key 0xE15E78F4:
 Userid     : "GitLab B.V. (package repository signing key) <packages@gitlab.com>"
 Fingerprint: 1a4c 919d b987 d435 9396 38b9 1421 9a96 e15e 78f4
 From       : https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey
Is this ok [y/N]:
```
-->

<h1 id="toc_1">启动 GitLab</h1>

<p>安装完成之后，打开配置文件<code>/etc/gitlab/gitlab.rb</code>将 <code>external_url = &#39;http://git.example.com&#39;</code>修改为自己的 IP 地址：<code>external_url &#39;http://ip_address&#39;</code>，然后执行下面的命令，对 GitLab 进行编译：</p>

<pre><code class="language-bash">gitlab-ctl reconfigure
</code></pre>

<h1 id="toc_2">GitLab 基本配置</h1>

<p>GitLab 的相关参数配置都存在 /etc/gitlab/gitlab.rb 文件里。自 GitLab 7.6 开始的新安装包, 已经默认将所有的参数写入到 /etc/gitlab/gitlab.rb 配置文件中。</p>

<h2 id="toc_3">配置端口</h2>

<p>GitLab 默认使用 80 端口对外提供服务，因为 80 端口被其他服务占用，所以需要更改。打开 /etc/gitlab/gitlab.rb 配置文件，修改 external_url &#39;http://ip_address&#39; 为 external_url &#39;http://ip_address:new-port&#39;，</p>

<p>报错 </p>

<pre><code class="language-bash">There was an error running gitlab-ctl reconfigure:

execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 390) had an error: Mixlib::ShellOut::ShellCommandFailed: Expected process to exit with [0], but received &#39;&#39;
---- Begin output of /opt/gitlab/bin/gitlab-rake cache:clear ----
STDOUT:
STDERR:
---- End output of /opt/gitlab/bin/gitlab-rake cache:clear ----
Ran /opt/gitlab/bin/gitlab-rake cache:clear returned

</code></pre>

<p>原来是机器内存没达到gitlab的要求，我的机器内存只有1G，gitlab的要求1G ram+1G swap</p>

<p>ubuntu下增加swap交换空间参考 </p>

<blockquote>
<p><a href="http://www.huzs.net/?p=1683">http://www.huzs.net/?p=1683</a></p>
</blockquote>

<h2 id="toc_4">Credentials</h2>

<ol>
<li>设置是 需要将开发机私钥设置copy 进jenkins</li>
<li>开发机共钥放 gitlab</li>
<li>本地机的  共钥放 gitlab
<img src="media/15299133099310/15242020277016.jpg" alt=""/></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android sdk 搭建]]></title>
    <link href="xuyushi.github.io/15299133099366.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099366.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Step 1. Download and Install Android SDK.</h2>

<pre><code class="language-bash">mkdir -p /opt/sdk-tools-linux-3859397
cd /opt/sdk-tools-linux-3859397
sudo wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip
sudo unzip sdk-tools-linux-3859397.zip
cd /opt
sudo chown -R root:root sdk-tools-linux-3859397
sudo ln -s sdk-tools-linux-3859397 android-sdk
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Step 2. Set Android SDK Environment Value.</h2>

<pre><code class="language-bash"> sudo vim /etc/profile.d/android-sdk-env.sh

export ANDROID_HOME=&quot;/opt/android-sdk&quot;
export PATH=&quot;$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH&quot;

sudo source /etc/profile.d/android-sdk-env.sh
</code></pre>

<h2 id="toc_2">Step 3.1 Update Android SDK.</h2>

<pre><code class="language-bash">cd /opt/android-sdk/tools
sudo ./android update sdk --no-ui
</code></pre>

<h2 id="toc_3">Step 3.2 Update Android SDK.</h2>

<p>Use Command Line to Update Android SDK</p>

<p>This is an example.</p>

<pre><code class="language-bash">/opt/android-sdk/tools/bin/sdkmanager --list
/opt/android-sdk/tools/bin/sdkmanager &quot;tools&quot; &quot;build-tools;26.0.0&quot; &quot;extras;android;m2repository&quot; &quot;extras;google;google_play_services&quot; &quot;platforms;android-26&quot; &quot;platform-tools&quot;
Posted by Moon Light February 1, 2016   android
</code></pre>

<h2 id="toc_4">更新sdk 版本</h2>

<pre><code class="language-bash">android update sdk --no-ui --all --filter &quot;android-23&quot;

android update sdk -u -t tool,platform-tool -a
</code></pre>

<p>yum install java-devel</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven 搭建]]></title>
    <link href="xuyushi.github.io/15299133099121.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099121.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<p>下载 </p>

<pre><code class="language-bash">wget -P /usr/local http://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz
</code></pre>

<p>安装</p>

<pre><code class="language-bash"># cd /usr/local
# mkdir nexus
# tar -zxvf nexus-3.6.0-02-unix.tar.gz -C nexus //解压缩到nexus文件夹（其中包含nexus-3.6.0-02和sonatype-work）

# cd nexus
# mv nexus-3.6.0-02/ nexus
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">配置</h2>

<p>自定义配置虚拟机可打开 nexus.vmoptions 文件进行配置（如果Linux硬件配置比较低的话，建议修改为合适的大小，否则会出现运行崩溃的现象）：</p>

<pre><code class="language-bash">vim nexus/config/nexus.vmoptions   
</code></pre>

<p>修改端口号</p>

<pre><code class="language-bash">application-host=&lt;vps 的ip&gt;
</code></pre>

<h2 id="toc_2">启动</h2>

<pre><code class="language-bash">/usr/local/nexus/nexus/bin/nexus start 
</code></pre>

<h2 id="toc_3">配置</h2>

<p>打开 <a href="http://ip:%E7%AB%AF%E5%8F%A3/nexus/">http://ip:端口/nexus/</a> ，初始账号 admin 密码 admin123</p>

<p>添加自己的仓库</p>

<p><img src="media/15299133099121/15242064068383.jpg" alt=""/></p>

<p>增加 user</p>

<p><img src="media/15299133099121/15242066550367.jpg" alt=""/></p>

<p><img src="media/15299133099121/15242067791896.jpg" alt=""/></p>

<h2 id="toc_4">android studio 打包上传</h2>

<p>新建一个测试 Android library moudle</p>

<p>peoject gradle 增加maven 仓库地址</p>

<pre><code class="language-gradle">buildscript {
    
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.0.0&#39;
        

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        repositories {
            maven { url &#39;http://xxx.xxx.1xx.3xxx:xxxx/nexus/content/repositories/testRep/&#39; }
        }
    }
}

</code></pre>

<p>library build.gradle 增加</p>

<pre><code class="language-gradle">apply plugin: &#39;maven&#39;
apply plugin: &#39;signing&#39;

def SNAPSHOT_REPOSITORY_URL = &#39;http://108.160.133.31:20014/nexus/content/repositories/testRep-snapshot/&#39;
def RELEASE_REPOSITORY_URL = &#39;http://108.160.133.31:20014//nexus/content/repositories/testRep/&#39;

uploadArchives {
    repositories {
        mavenDeployer {
            pom.groupId = &#39;io.github.xuyushi&#39;
            pom.artifactId = &#39;test&#39;
            pom.version = &#39;1.0.3&#39;
            repository(url: RELEASE_REPOSITORY_URL) {
                authentication(userName:&#39;xxxx&#39;, password: &#39;*****&#39;)
            }
            snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {
                authentication(userName:&#39;xxxx&#39;, password: &#39;****&#39;)
            }
        }
    }
}


</code></pre>

<p>编译上传</p>

<pre><code class="language-bash">../gradlw upload
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架3-Kotlin]]></title>
    <link href="xuyushi.github.io/15299133099083.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099083.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">gradle 修改</h2>

<p>加入 kotlin 之后需要使用 kapt,gradle 修改为</p>

<pre><code class="language-gradle">    //kotlin
    //dagger
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;

    compile &quot;com.blankj:utilcode:$rootProject.androidUtilsVerson&quot;
    //不加无法编译通过
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.kotlin_version&quot;

</code></pre>

<span id="more"></span><!-- more -->

<p>project gradle</p>

<pre><code class="language-gradle">buildscript {
    ext.kotlin_version = &#39;1.1.51&#39;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre>

<p>可以使用 AS 3.0 的新功能 或者 kotlin 插件，将项目整个工程转为 kotlin</p>

<h2 id="toc_1">注意，有几处 需要手动修改</h2>

<h3 id="toc_2">定义的dagger注解</h3>

<pre><code class="language-kotlin">@Scope
@kotlin.annotation.Retention
annotation class ActivityScoped

@Scope
@kotlin.annotation.Retention
annotation class FragmentScoped

</code></pre>

<h2 id="toc_3">注入使用</h2>

<pre><code class="language-gradle">    @Inject
    lateinit var mPresenter: RegisterContract.Presenter
</code></pre>

<p>需要使用 <code>lateinit</code> 来表示延迟初始化 </p>

<h2 id="toc_4">优化 mvp 结构</h2>

<p>可以将在 Presenter 接口这持有 view （view 是abs），复写接口的时候复写改 view</p>

<pre><code class="language-kotlin">
interface BasePresenter&lt;T&gt; {
    var mView:T?
    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    fun takeView(view: T){
        mView = view
    }

    /**
     * Drops the reference to the view when destroyed
     */
    fun dropView(){
        mView = null
    }

}

</code></pre>

<p>并在<code>takeView</code> <code>dropView</code> 对 view 进行复制，这样的好处就是复现该接口的同时就不用重复这些代码了 。而 java在接口也不能定义变量，在接口方法也也不能定义操作</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架3-Kotlin]]></title>
    <link href="xuyushi.github.io/15299133099209.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099209.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">gradle 修改</h2>

<p>加入 kotlin 之后需要使用 kapt,gradle 修改为</p>

<pre><code class="language-gradle">    //kotlin
    //dagger
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;

    compile &quot;com.blankj:utilcode:$rootProject.androidUtilsVerson&quot;
    //不加无法编译通过
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.kotlin_version&quot;

</code></pre>

<span id="more"></span><!-- more -->

<p>project gradle</p>

<pre><code class="language-gradle">buildscript {
    ext.kotlin_version = &#39;1.1.51&#39;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre>

<p>可以使用 AS 3.0 的新功能 或者 kotlin 插件，将项目整个工程转为 kotlin</p>

<h2 id="toc_1">注意，有几处 需要手动修改</h2>

<h3 id="toc_2">定义的dagger注解</h3>

<pre><code class="language-kotlin">@Scope
@kotlin.annotation.Retention
annotation class ActivityScoped

@Scope
@kotlin.annotation.Retention
annotation class FragmentScoped

</code></pre>

<h2 id="toc_3">注入使用</h2>

<pre><code class="language-gradle">    @Inject
    lateinit var mPresenter: RegisterContract.Presenter
</code></pre>

<p>需要使用 <code>lateinit</code> 来表示延迟初始化 </p>

<h2 id="toc_4">优化 mvp 结构</h2>

<p>可以将在 Presenter 接口这持有 view （view 是abs），复写接口的时候复写改 view</p>

<pre><code class="language-kotlin">
interface BasePresenter&lt;T&gt; {
    var mView:T?
    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    fun takeView(view: T){
        mView = view
    }

    /**
     * Drops the reference to the view when destroyed
     */
    fun dropView(){
        mView = null
    }

}

</code></pre>

<p>并在<code>takeView</code> <code>dropView</code> 对 view 进行复制，这样的好处就是复现该接口的同时就不用重复这些代码了 。而 java在接口也不能定义变量，在接口方法也也不能定义操作</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架2-mvp 结构]]></title>
    <link href="xuyushi.github.io/15299133100126.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100126.html</id>
    <content type="html"><![CDATA[
<p>之前有两篇文章已经详细介绍过 mvp  <a href="http://xuyushi.github.io/2016/02/28/MVP/">Android 中的MVP 模式</a>    <a href="http://xuyushi.github.io/2016/04/30/%E5%9C%B0%E5%9B%BE%E5%8C%BA%E5%9F%9F%E7%BB%98%E5%88%B6%20MVP%20%E5%AE%9E%E8%B7%B5/">地图区域绘制 MVP 实践</a> ，本篇结合上篇的依赖注入使用<br/>
<span id="more"></span><!-- more --></p>

<h1 id="toc_0">定义 base 类</h1>

<p>定义 view 和 Presenter 的 interface</p>

<pre><code class="language-java">public interface BaseView&lt;T&gt; {

}
public interface BasePresenter&lt;T&gt; {

    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    void  takeView(T view);

    /**
     * Drops the reference to the view when destroyed
     */
    void dropView();

}


</code></pre>

<p>presenter 的<code>takeView</code>在 view 对应的resume 生命周期中获取 view ，在 desdroy 中 将 view 赋值为 null ，以免内存泄露。</p>

<h2 id="toc_1">Contract</h2>

<p>Contract 为 view 和 Presenter 的继承接口 <br/>
举个例子 实现一个 splash 页面</p>

<pre><code class="language-java">
public interface SplashContract {
    interface View extends BaseView&lt;Presenter&gt; {
        void showWaitingPage();
    }

    interface Presenter extends BasePresenter&lt;View&gt; {
        void goLogin();

        void goMain();

        void tryLogin();

        void takeView(SplashContract.View view);
    }
}

</code></pre>

<p>SplashPresenter</p>

<pre><code class="language-java">class SplashPresenter implements SplashContract.Presenter{

    @Inject
    public SplashPresenter() {
    }

    @Nullable
    private SplashContract.View mView;

    @Override
    public void goLogin() {
        ToastUtils.showShort(&quot;go login&quot;);
        ActivityUtils.startActivity(LoginActivity.class);
    }

    @Override
    public void goMain() {
        ToastUtils.showShort(&quot;go Main&quot;);
        ActivityUtils.startActivity(MainActivity.class);
    }

    @Override
    public  void tryLogin() {
        Handler requestHandler = new Handler(Looper.getMainLooper());
        requestHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                boolean islogin = false;
                if (islogin) {
                    goMain();
                } else {
                    goLogin();
                }
            }
        }, 1000);


    }

    @Override
    public void takeView(SplashContract.View view) {
        mView = view;
        if (mView != null) {
            mView.showWaitingPage();
        }
    }

    @Override
    public void dropView() {
        mView = null;
    }
}

</code></pre>

<blockquote>
<p>注意 <br/>
在构造方法是 使用 <code>@Inject</code> 注解，一遍 dagger 框架能找到该类<br/>
每次调用view 中的方法时，都要进行判空，感觉上用 kotlin 代码会更方便点</p>
</blockquote>

<pre><code class="language-java">public class SplashActivity extends BaseActivity implements SplashContract.View {
    @Inject
    Context mContext;

    @Inject
    SplashContract.Presenter mPresenter;

    @BindView(R.id.ll_root)
    LinearLayout mLlRoot;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mPresenter.tryLogin();
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                ContactUtil.getContacts(mContext);
            }
        });
        thread.start();
    }

    @Override
    protected int getLayout() {
        return R.layout.activity_splash;
    }

    @Override
    protected void onResume() {
        super.onResume();
        mPresenter.takeView(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mPresenter.dropView();
    }

    @Override
    public void showWaitingPage() {
//        mLlRoot.setBackground(R.mipmap.ic_launcher);
    }
}
</code></pre>

<ol>
<li>Activity 实现view 接口，并在<code>onResume</code> 时<code>akeView</code>，<code>onDestroy</code> 时<code>dropView</code></li>
<li>通过 dagger 注入找到对应的 presenter </li>
</ol>

<p>为了能找到 Presenter ，我们还应该建立接口和对应实现的联系 ，可以使用 <code>@bind</code>注解 </p>

<p>SplashPresenterModule</p>

<pre><code class="language-java">@Module
public abstract class SplashPresenterModule {

    @ActivityScoped
    @Binds
    abstract SplashContract.Presenter statitsticsPresenter(SplashPresenter presenter);
}

</code></pre>

<p>然后在上篇文章提到的<code>ActivityBindingModule</code> 中，加入该 Activity 和改 module</p>

<pre><code class="language-java">@Module
public abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = TellTruePresenterModule.class)
    abstract MainActivity mainActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = SplashPresenterModule.class)
    abstract SplashActivity splashActivity();

}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架1-依赖注入]]></title>
    <link href="xuyushi.github.io/15299133100165.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100165.html</id>
    <content type="html"><![CDATA[
<p>关于依赖注入在 <a href="http://xuyushi.github.io/2017/04/08/Android%20CleanArchitecture%20--Dagger/">之前的文章里有详细的分析</a></p>

<p>而最近的 dagger 的更新又再次方便了注入过程 。<br/>
回顾之前的 dagger 在 Activity 、fragment 等 Android 组件中是如何注入的</p>

<ol>
<li>在 moduel 中，提供所需注入的元素的构造方法</li>
<li>构造对应的 <code>Component</code>，包含所需的 <code>module</code>，并将<code>module</code> 中的方法暴露出。并申明对应的inject方法 </li>
<li>在actvity 中注入</li>
</ol>

<p>这样做的弊端是 <br/>
<span id="more"></span><!-- more --></p>

<ol>
<li>即使Dagger使我们的代码耦合性更低，但是如果要面临重构，我们仍然不得不去面对每个Activity中这样数行需要我们「复制」+「粘贴」的代码，这会给我们的重构带来一定的难度（试想一下，如果我们的应用有数十个乃至上百个这样的Activity或者Fragment容器，我们的重构计划，首先就要面对这样数百行的代码）。<br/></li>
<li>更重要的是，它要求注射类型（FrombulationActivity）知道其注射器。 即使这是通过接口而不是具体类型完成的，它打破了依赖注入的核心原则：一个类不应该知道如何实现依赖注入。</li>
<li>在开发过程中明显发现，在每个 Activity 中构造对应的<code>Component</code>，然后注入 是件很恶心的事情，而且这个注入并不能写入 base 类中，只能每个 Activity 中再重复写入</li>
</ol>

<p>在新版的 dagger 中提供了 <code>ContributesAndroidInjector</code>这样一个注解</p>

<p>看下官方文档如何描述的</p>

<pre><code class="language-java">/**
 * Generates an {@link AndroidInjector} for the return type of this method. The injector is
 * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}&#39;s
 * component.
 *
 * &lt;p&gt;This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
 * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
 * MyService}, etc). The method should have no parameters.
 *
 * &lt;p&gt;For more information, see &lt;a href=&quot;https://google.github.io/dagger/android&quot;&gt;the docs&lt;/a&gt;
 */
</code></pre>

<p><code>@ContributesAndroidInjector</code>使用在 module 中的抽象方法上。该方法不该有参数，<strong>返回类型必须是 Activity、Fragment 和 Service 等 Android Framework 的类型</strong>。dagger 将会为这样的一个方法生成一个对应的 Subcomponent。这个注解还能接受一系列 Module 作为值，这些 module 将会成为所生成的 Subcomponent 的 module。</p>

<h2 id="toc_0">搭建过程</h2>

<h3 id="toc_1">添加依赖</h3>

<pre><code class="language-gradle">    // Dagger dependencies
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    annotationProcessor &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot; // if you use the support libraries
    annotationProcessor &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;

</code></pre>

<h2 id="toc_2">ActivityBindingModule</h2>

<p>ActivityBindingModule 使用dagger 框架提供<code>ContributesAndroidInjector注解</code> 辅助我们注入 Android 框架</p>

<pre><code class="language-java">@Module
public abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = TellTruePresenterModule.class)
    abstract MainActivity mainActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = SplashPresenterModule.class)
    abstract SplashActivity splashActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = LoginModule.class)
    abstract LoginActivity loginActivity();
}
</code></pre>

<p>以后每次增加 Activity 或者 service 等，只要在这添加一行代码就行了，不需要修改对应的 Activity</p>

<h2 id="toc_3">AppComponent</h2>

<pre><code class="language-java">@Singleton
@Component(modules = {TasksRepositoryModule.class,
        ApplicationModule.class,
        ActivityBindingModule.class,
        AndroidSupportInjectionModule.class})

public interface AppComponent extends AndroidInjector&lt;DaggerApplication&gt; {

    void inject(MyApplication application);

    TasksRepository getTasksRepository();

    @Override
    void inject(DaggerApplication instance);

    // Gives us syntactic sugar. we can then do DaggerAppComponent.builder().application(this).build().inject(this);
    // never having to instantiate any modules or say which module we are passing the application to.
    // Application will just be provided into our app graph now.
    @Component.Builder
    interface Builder {

        @BindsInstance
        AppComponent.Builder application(Application application);

        AppComponent build();
    }

//    APIInterface APIInterface();
}

</code></pre>

<p>注意注解中 module 的依赖</p>

<h2 id="toc_4">ApplicationModule</h2>

<pre><code class="language-java">@Module
public abstract class ApplicationModule {
    //expose Application as an injectable context
    @Binds
    abstract Context bindContext(Application application);

    @Provides
    public static APIInterface provideInterface() {
        Retrofit retrofit= new Retrofit.Builder()
                .baseUrl(&quot;https://api.github.com&quot;)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        APIInterface service = retrofit.create(APIInterface.class);
        return service;
    }
}


</code></pre>

<p>可以把全局的一些单例类放在这个 moduel。 比如<code>RetrofitService</code>、application 的<code>context</code> 等 </p>

<h2 id="toc_5">添加 Activity fragment 的 scope</h2>

<pre><code class="language-java">@Documented
@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface ActivityScoped {
}


@Scope
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface FragmentScoped {}

</code></pre>

<h2 id="toc_6">application 中 inject</h2>

<pre><code class="language-java">public class MyApplication extends DaggerApplication {
    @Inject
    TasksRepository tasksRepository;

    @Override
    protected AndroidInjector&lt;? extends DaggerApplication&gt; applicationInjector() {
        AppComponent appComponent = DaggerAppComponent.builder().application(this).build();
        appComponent.inject(this);
        return appComponent;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Utils.init(this);
    }
}

</code></pre>

<blockquote>
<p>注意 <br/>
activity 和 fragment 等都要 extend 自 dagger 中的对应类，也可以将对应的逻辑抽象至 base 类中</p>
</blockquote>

<p>最后可以将以上类放入同一个包中<br/>
<img src="media/15299133100165/15091645703766.png" alt=""/></p>

<h1 id="toc_7">参考</h1>

<blockquote>
<p><a href="https://juejin.im/entry/593cee56ac502e006b3dc9c2">https://juejin.im/entry/593cee56ac502e006b3dc9c2</a><br/>
<a href="https://segmentfault.com/a/1190000010016618">https://segmentfault.com/a/1190000010016618</a></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
