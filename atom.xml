<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Xu Yushi's Blog]]></title>
  <link href="xuyushi.github.io/atom.xml" rel="self"/>
  <link href="xuyushi.github.io/"/>
  <updated>2018-07-22T14:55:26+08:00</updated>
  <id>xuyushi.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[业务流程设计]]></title>
    <link href="xuyushi.github.io/15318371632829.html"/>
    <updated>2018-07-17T22:19:23+08:00</updated>
    <id>xuyushi.github.io/15318371632829.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">业务流程图</h2>

<ul>
<li>产品设计的过程文件，类似于建筑图纸</li>
<li>产品设计，就是流程设计</li>
<li>凡是产品需求必有流程图</li>
</ul>

<h2 id="toc_1">做产品就是做流程</h2>

<ul>
<li>流程对了，后面的原型，需求文档，评审都容易了</li>
<li>传承，让你自己、同事、后续接手的人很容易交接</li>
<li>让参与者明确知道业务是如何运作的，快速开展工作</li>
<li>明确产品优化的过程与收益，设置考核指标更合理</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_2">不同阶段，业务流程的作用</h2>

<ul>
<li><strong>功能优化：</strong>看之前的业务流程，找改进点</li>
<li><strong>独立功能设计：</strong>单通道流程图，看用户，信息的流向</li>
<li><strong>独立产品设计：</strong>泳道图，复杂的用户，信息交互处理</li>
<li><strong>原型交互设计：</strong>页面流程图，规定页面的交互方向</li>
</ul>

<h2 id="toc_3">基本业务流程图包含什么</h2>

<ul>
<li><strong>事项：</strong>要完成的事情是什么？</li>
<li><strong>用户：</strong>分别有哪些人会参与到流程中</li>
<li><strong>信息：</strong>数据是怎么流转的</li>
<li><strong>异常：</strong>异常处理</li>
</ul>

<pre><code class="language-mermaid">graph TD
op1[明确用户与任务]
op2[开始与结束]
op3[明确顺序]
op4[异常情况]
op5[优化调整]
op6[输出]

op1 --&gt; op2
op2 --&gt; op3
op3--&gt; op4
op4--&gt; op5
op5 --&gt; op6

</code></pre>

<h2 id="toc_4">单通道的业务流程技巧</h2>

<ul>
<li><strong>主线清晰：</strong>关键路径、关键任务一目了然</li>
<li><strong>先主后次：</strong>先搞定关键路径，再补充细节</li>
<li><strong>优化调整：</strong>先把最长的路径想到，再合并操作流程</li>
</ul>

<h2 id="toc_5">业务流程图能力</h2>

<ul>
<li><strong>多看：</strong>多调研，体验各同类功能点</li>
<li><strong>多想：</strong>用产品的视角想想为什么是这样的设计</li>
<li><strong>多画：</strong></li>
<li><strong>多交流：</strong>多和功底好的同事交流</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[完整功能点设计]]></title>
    <link href="xuyushi.github.io/15318354800090.html"/>
    <updated>2018-07-17T21:51:20+08:00</updated>
    <id>xuyushi.github.io/15318354800090.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">所有产品都是由小功能构成的</h2>

<ul>
<li>产品经理不是功能经理，好的产品经理一定能做好功能</li>
<li>产品早期，功能为主，产品成熟后，对原有功能的迭代为主</li>
<li>完整的功能，一般需要经过简单的评审才能提交研发</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">明确功能目的</h2>

<p><strong>对用户</strong>对哪类用户具体有什么好处？有没有受影响的用户</p>

<ul>
<li>增加内容，提升准确度（如选择标签）</li>
<li>减少操作，提升便利性（推荐入口）</li>
<li>功能补充，提升体验</li>
</ul>

<h2 id="toc_2">目的性如何定</h2>

<h3 id="toc_3">对平台（内）</h3>

<p>对内部数据、操作人员是否提升的效率</p>

<ul>
<li>增加渠道，引入新用户</li>
<li>减少重复操作</li>
<li>数据分层，提升精准度</li>
</ul>

<h3 id="toc_4">商业</h3>

<p>是提高收入？还是提升了转化率</p>

<ul>
<li>拉倒付费转化率</li>
<li>增加新产品，创造心收入点</li>
<li>对原有数做重新组合，提高转化率</li>
</ul>

<h2 id="toc_5">制定功能方案</h2>

<ul>
<li>可能的解决方案有哪些</li>
<li>梳理每个方案的简要业务流程</li>
<li>针对性的分析，选择合适的方案</li>
<li>开发难度/见效/用户场景</li>
</ul>

<h2 id="toc_6">方案细化</h2>

<ul>
<li><strong>流程细化：</strong>梳理业务流程，增加异常情况</li>
<li><strong>考核指标：</strong>上线后如何评定功能点的效果</li>
</ul>

<h2 id="toc_7">原型和文档</h2>

<p>略</p>

<h2 id="toc_8">运营推广方案</h2>

<ul>
<li>找位置：用户的关键路径</li>
<li>定内容：匹配用户和场景，制定文案和推广形式</li>
<li>要效果：运营的转化效果，后续的计划</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[产品调研]]></title>
    <link href="xuyushi.github.io/15318107329806.html"/>
    <updated>2018-07-17T14:58:52+08:00</updated>
    <id>xuyushi.github.io/15318107329806.html</id>
    <content type="html"><![CDATA[
<p>功能调研何产品调研有什么区别</p>

<ul>
<li>共同点
<ul>
<li>目的性明确</li>
<li>注重底层逻辑流程</li>
<li>用户需求如何被满足</li>
</ul></li>
<li>不同点
<ul>
<li>功能调研
<ul>
<li>重业务流程</li>
<li>交互体验</li>
<li>突出亮点</li>
</ul></li>
<li>产品调研
<ul>
<li>重功能迭代过程</li>
<li>重产品结构</li>
<li>运营逻辑</li>
</ul></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->    

<h2 id="toc_0">功能点调研</h2>

<h3 id="toc_1">明确调研目的</h3>

<table>
<thead>
<tr>
<th>调研的类型</th>
<th>目的</th>
</tr>
</thead>

<tbody>
<tr>
<td>竞争对手上了新功能</td>
<td>能不能抄？要不要抄？调研后给播送 作决策依据</td>
</tr>
<tr>
<td>准备上的新功能，先看看别人怎么做的</td>
<td>哪个好？怎么抄？缩短产品设计的过程</td>
</tr>
<tr>
<td>以自我成长学习为目的</td>
<td>为什么这么做？判断自己的分析能力和判断力</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">数据表现</h3>

<ul>
<li>覆盖率</li>
<li>发布量</li>
<li>成交量</li>
</ul>

<h3 id="toc_3">对于自己的产品来说的意义</h3>

<ul>
<li>要不要抄：和用户群是否符合？数据情况如何 </li>
<li>能不能抄：是否有技术壁垒？是否有特殊门槛</li>
<li>结论是什么</li>
</ul>

<h3 id="toc_4">核心问题</h3>

<ul>
<li>新的功能点有哪些？最关键（你准备调研）的是哪个</li>
<li>用户、需求、场景是否被满足了</li>
<li>底层逻辑、产品流程大概是什么样</li>
<li>产品的亮点是什么？为什么</li>
<li>数据表现</li>
</ul>

<h3 id="toc_5">功能调研的误区</h3>

<ul>
<li>没结论</li>
<li>不愿意做</li>
<li>杂</li>
<li>费要提改进意见</li>
</ul>

<h2 id="toc_6">针对产品的调研</h2>

<ul>
<li>了解产品功能，看产品的表现</li>
<li>通过迭代的过程，看产品实现的逻辑</li>
<li>透过一个产品，看穿一个行业</li>
</ul>

<h3 id="toc_7">针对独立产品的调研怎么做</h3>

<ul>
<li>用户：有哪些类型的用户</li>
<li>场景：不同类型的用户，分别在什么场景下会使用</li>
<li>需求：产品满足了哪些需求 </li>
</ul>

<h3 id="toc_8">产品逻辑</h3>

<ul>
<li>用户的流向：都有哪些用户，怎么发生联系的</li>
<li>数据的流向：产生的数据流是如何运转的</li>
<li>汇合点：用户、数据的在哪个关键页面回合</li>
<li>关键路径：用户操作的关键功能、页面是什么</li>
</ul>

<h3 id="toc_9">通过迭代路径找到关键点</h3>

<h3 id="toc_10">产品的表现如何</h3>

<ul>
<li>数据表现：使用数据、排名数据、评分数据</li>
<li>用户表现：用户点评、产品点评</li>
</ul>

<h3 id="toc_11">多个相同的产品调研</h3>

<ul>
<li>找相同 找不同</li>
<li>关键功能的差异</li>
</ul>

<h3 id="toc_12">出结论</h3>

<ul>
<li>相比优点、缺点、亮点</li>
<li>如果要抄，抄什么？怎么抄？</li>
</ul>

<h3 id="toc_13">明确目的比功能全面更重要</h3>

<ul>
<li>目标：用来做什么？期望</li>
<li>成本：如果自己做，能用 是如何 的？</li>
<li>关联性：第三方产品和你完成目标之间的关联</li>
<li>其他：价格、服务、会不会倒闭等</li>
</ul>

<h1 id="toc_14">产品调研 的误区</h1>

<ul>
<li>产品调研 不等于行业调研</li>
<li>二三手数据不能证明你正确</li>
<li>非得加改进建议</li>
<li>大而全</li>
<li>强烈的个人倾向</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用思维导图梳理用户需求]]></title>
    <link href="xuyushi.github.io/15316593971293.html"/>
    <updated>2018-07-15T20:56:37+08:00</updated>
    <id>xuyushi.github.io/15316593971293.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">产品设计的核心三要素</h2>

<p>产品设计就是不断解决用户在特定场景下的需求，增加、减少需求并非最关键，关键是能不能解决用户的问题</p>

<ul>
<li>用户</li>
<li>场景</li>
<li>需求</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">思维导图的思考方式</h2>

<ul>
<li>用户：当想到一个功能，先不用考虑怎么实现，而应该想谁会用</li>
<li>场景：用户分别在什么情况下会用（感兴趣）</li>
<li>问题：用户<strong>分别</strong>在上述场景下，会遇到什么问题挑战</li>
<li>方案：用户现在的解决方案是什么</li>
</ul>

<h2 id="toc_2">举个例子</h2>

<p>输入法的面对面翻译功能</p>

<blockquote>
<p>类似于翻译机的实时翻译功能</p>
</blockquote>

<p><img src="media/15316593971293/15317283713594.jpg" alt=""/></p>

<h3 id="toc_3">潜在的用户有哪些</h3>

<ul>
<li>谁会面对面翻译感兴趣</li>
<li>思维导图列出所有感兴趣的人</li>
<li>不用思考行不行，把能想到的穷举</li>
</ul>

<h3 id="toc_4">不同的用户分别碰到什么问题</h3>

<ul>
<li><strong>分别</strong>！！ 不要怕重复</li>
<li>不同的群体，不同的场景，问题是不同的</li>
<li>区分“问题”和“中性次”，如时间，价格，要写成时间短，价格高等</li>
</ul>

<h3 id="toc_5">现在的解决方案是</h3>

<ul>
<li>是用户现有的解决方案 ，而不是你要做的功能解决方案</li>
<li>有很多用户也没有解决方案</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[需求优先级]]></title>
    <link href="xuyushi.github.io/15317376170439.html"/>
    <updated>2018-07-16T18:40:17+08:00</updated>
    <id>xuyushi.github.io/15317376170439.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">四象限看用户量与发生频率</h2>

<ul>
<li>优先解决大量用户的高频问题，基础体验</li>
<li>最后解决少量用户的低频问题，超好体验
<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_1">案例 某垂直电商平台</h3>

<ol>
<li>订单流程、商品详情页</li>
<li>设置、个人资料</li>
<li>商家入驻、商家管理后台</li>
<li>发票</li>
</ol>

<h2 id="toc_2">看开发难度和效果</h2>

<ul>
<li>优先见效快开发难度不大的，迭代</li>
<li>最后做费劲见效慢的，可能是未来的机会</li>
</ul>

<h2 id="toc_3">看产品价值</h2>

<ul>
<li>迫切程度：用户是不是真的非常需要？还是空想的？</li>
<li>付费意愿：用户是否会为了解决问题而付费</li>
<li>ARPU:如果开发出来，用户会为之付多少钱</li>
</ul>

<h2 id="toc_4">看对目标群体的熟悉程度</h2>

<ul>
<li>你是否深入了解用户使用场景</li>
<li>你对用户群体的理解是否足够深入</li>
<li>如果不熟悉，就相伴法熟悉，否则不要动手</li>
</ul>

<h2 id="toc_5">总结结论</h2>

<ul>
<li><strong>用户：</strong>这个功能，第一批的核心用户是谁</li>
<li><strong>场景：</strong>这个用户在什么场景下会使用</li>
<li><strong>问题：</strong>解决了这个用户最大的痛点是什么</li>
<li><strong>对比：</strong>和用户现在的解决方案比，体验/效率提升有多大</li>
</ul>

<h2 id="toc_6">其他</h2>

<ul>
<li>优先级需求的定义要基于当时的环境和实际情况</li>
<li>用户的需求是一个动态变化的过程</li>
<li>产品和运营不分家，再确保满足基本型需求的同时，也要适当考虑满足用户期望型和兴奋型需求</li>
</ul>

<h2 id="toc_7">用户需求重要性的判断标准：</h2>

<ul>
<li>用户基数</li>
<li>使用频率</li>
<li>类别重要性
<ul>
<li>基本型：产品的性能，安全，兼容性等，具有最高优先级</li>
<li>期望型：功能渗透率 x 人均使用次数 x 类别重要性百分比</li>
<li>兴奋型</li>
</ul></li>
</ul>

<h1 id="toc_8">思考题</h1>

<p>【作业题目】给以下需求优先级排序滴滴打车早期第一版核心打车功能已上线，需要对下列功能优先级排序</p>

<ol>
<li>新增“愿等时间”，多等司机一会儿，提高打车成功率</li>
<li>电量优化，叫车更省电</li>
<li>优先文字叫车，更容易更快打到车</li>
<li>定位信号弱时，可自己设置上车点</li>
<li>支付时默认选车券，省钱便捷</li>
<li>即时聊天开放，沟通更方便</li>
</ol>

<table>
<thead>
<tr>
<th>方案</th>
<th>用户量</th>
<th>频率</th>
<th>价值</th>
<th>需求类别</th>
<th>开发成本</th>
</tr>
</thead>

<tbody>
<tr>
<td>1 新增“愿等时间”，多等司机一会儿，提高打车成功率</td>
<td>较多</td>
<td>较多</td>
<td>高</td>
<td>基本</td>
<td>低</td>
</tr>
<tr>
<td>2 电量优化，叫车更省电</td>
<td>很少</td>
<td>很少</td>
<td>低</td>
<td>兴奋</td>
<td>高</td>
</tr>
<tr>
<td>3 优先文字叫车，更容易更快打到车</td>
<td>多</td>
<td>较多</td>
<td>高</td>
<td>基本</td>
<td>中</td>
</tr>
<tr>
<td>4 定位信号弱时，可自己设置上车点</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>基本</td>
<td>中</td>
</tr>
<tr>
<td>5 支付时默认选车券，省钱便捷</td>
<td>多</td>
<td>中</td>
<td>低</td>
<td>期望</td>
<td>低</td>
</tr>
<tr>
<td>6 即时聊天开放，沟通更方便</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>兴奋</td>
<td>高</td>
</tr>
</tbody>
</table>

<p>1-&gt;3-&gt;4-&gt;6-&gt;2-&gt;5</p>

<blockquote>
<p>值得注意的是<code>5 支付时默认选车券，省钱便捷</code> ，处于支付阶段，用户已经基本完成打车流程，价格敏感的用户会自己勾选，不敏感的用户可以节约运营成本 ，忘记勾选的用户增加了用户粘性</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用户调研]]></title>
    <link href="xuyushi.github.io/15316240502263.html"/>
    <updated>2018-07-15T11:07:30+08:00</updated>
    <id>xuyushi.github.io/15316240502263.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">为什么要用户调研</h2>

<ul>
<li>了解用户对产品的使用过程</li>
<li>了解目标用户群使用场景和过程</li>
<li>总结用户的问题和流程</li>
<li>提出最合理的解决方案 </li>
</ul>

<h2 id="toc_1">用户调研全过程</h2>

<ol>
<li>明确背景和目的</li>
<li>选择目标用户</li>
<li>分析用户和问题</li>
<li>准备调研内容</li>
<li>现场调研</li>
<li>总结报告</li>
</ol>

<span id="more"></span><!-- more -->

<h3 id="toc_2">用户调研全过程</h3>

<ul>
<li>背景：什么情况下发起的调研?是否必须通过调研来解决？</li>
<li>目的：通过用户调研希望得到的结果是什么？</li>
<li>忌大而全：调研的方向越聚焦，越有价值</li>
<li>忌家大空：针对行业用户的调研 ，针对满意度的调研，价值都不大</li>
</ul>

<table>
<thead>
<tr>
<th>bad</th>
<th>原因</th>
<th>good</th>
</tr>
</thead>

<tbody>
<tr>
<td>对本站用户 做针对性调研</td>
<td>目的不明确</td>
<td>* 在支付阶段用户流失原因调研分析 * 用户在不同在线学习平台学习过程调研</td>
</tr>
<tr>
<td>做北京地区女性用户使用情况调研</td>
<td>背景不明确</td>
<td>北京地区女性下单转化率很高，调研其在平台购买路径分析</td>
</tr>
<tr>
<td>O2O 行业用户使用习惯调研</td>
<td>大而全</td>
<td>* 京东到家超市业务白领女性消费习惯调研 </td>
</tr>
</tbody>
</table>

<h3 id="toc_3">选择目标用户</h3>

<ul>
<li>典型用户：通过简单的用户画像，找出典型用户</li>
<li>目标用户：时间、地点、配合程度</li>
<li>邀约用户：直接说明目的，并告知可能发生的情况</li>
<li>用户数量：不宜扫网式，一般5-10个</li>
</ul>

<h3 id="toc_4">猜测用户问题 设定题目</h3>

<ul>
<li>用户可能的问题：用户的使用行为表现</li>
<li>可能的解决方案：猜测解决用户问题的手段</li>
<li>确定访问提纲：聚焦且开放的问题</li>
<li>问题数量：线上10-20，线下5-10 展开</li>
</ul>

<h3 id="toc_5">准备调研内容</h3>

<ul>
<li>本品已知问题：用户操作习惯、消费习惯和过程，原因</li>
<li>本品未知问题：用户的痛点是什么？哪些操作用户很烦，用户愿意掏钱做什么？</li>
<li>竞品已知问题：用户直观感知两者区别，竞品使用差异</li>
<li>竞品已知问题：如果从竞品移入，用户放弃理由。从本品移到竞品，原因？ </li>
</ul>

<p><img src="media/15316240502263/15316441642224.jpg" alt="" style="width:737px;"/></p>

<h3 id="toc_6">现场调研</h3>

<ul>
<li>了解用户使用的过程：最好观察用户的行为</li>
<li>提问：对关键行为、预设问题进行提问</li>
<li>反馈：对有效的信息反馈给用户，并深究</li>
</ul>

<h3 id="toc_7">调研报告</h3>

<ul>
<li>单个用户：记录单用户调研情况</li>
<li>整体情况：汇总用户调研的过程和结论</li>
<li>行动计划：分享并提出行动计划</li>
</ul>

<h2 id="toc_8">用户调研的常见误区</h2>

<ul>
<li>指望从用户调研中获取需求是产品经理懒惰的表现</li>
<li>用户调研不等于用户访谈，访谈只是其中的一种方式</li>
<li>把个体当整体</li>
<li>从用户调研中找自我感觉的证明</li>
<li>用户调研的结论不要谈占比</li>
</ul>

<h2 id="toc_9">忌讳</h2>

<ul>
<li>直接问用户想要什么，有什么需求</li>
<li>直接问用户有没有用，好不好用</li>
<li>快速打断用户</li>
<li>说服用户</li>
</ul>

<h2 id="toc_10">设计改善措施</h2>

<p><img src="media/15316240502263/15316452423278.jpg" alt=""/></p>

<ul>
<li>认知缺口：产品经理不知道用户想要的是什么。若出现了认知缺口，则首先是让产品经理清楚知道用户流失的真正原因。</li>
<li>执行缺口：产品经理知道用户想要什么，但实际做出来的产品与设计中的不一致。若出现了执行缺口，则要了解具体哪个执行步骤出现问题，是资源的欠缺还是技术难以实现。</li>
<li>传递缺口：产品的宣传和指引不能让用户对产品真正认知了解若出现了传递缺口，则要了解用户现在的感知是怎么样的，在哪些宣传和指引上出现了问题。</li>
<li>流失缺口：用户体验到的产品和期望的不一样。</li>
</ul>

<h1 id="toc_11">拓展</h1>

<blockquote>
<p><a href="http://cdc.tencent.com/2013/07/03/%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E5%8E%9F%E5%9B%A0%E8%B0%83%E7%A0%94%E5%9B%9B%E6%AD%A5%E7%BB%8F/">用户流失原因调研四步经</a> <br/>
<a href="https://www.zhihu.com/question/20345655/answer/19110604">如何去做用户访谈和用户调研</a><br/>
<a href="http://blog.sanjieke.cn/article/144538.html">如何做好用户调研</a><br/>
<a href="http://www.yunzhan365.com/59771541.html">如何做一次完美的用户调研</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用户反馈发现问题]]></title>
    <link href="xuyushi.github.io/15316220023386.html"/>
    <updated>2018-07-15T10:33:22+08:00</updated>
    <id>xuyushi.github.io/15316220023386.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">关注什么问题</h2>

<ul>
<li>自身产品的问题</li>
<li>竞品的问题</li>
<li>可能的机会点</li>
</ul>

<h2 id="toc_1">渠道</h2>

<h3 id="toc_2">渠道类型</h3>

<ul>
<li>公开渠道：apple store，微博，贴吧，第三方应用商城</li>
<li>半公开渠道：微信，朋友圈，用户评价</li>
<li>内部渠道：用户投诉，电话录音
<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_3">处理策略</h3>

<ul>
<li>公开渠道：勤搜索、关键词订阅、自动化监控</li>
<li>半公开渠道：定期搜索关键字、定期分析用户评论</li>
<li><br/>
### 内部渠道</li>
<li>整合内部用户反馈渠道</li>
<li>定期与一线同事沟通</li>
<li>到一线去</li>
</ul>

<h2 id="toc_4">主流应用商店与常用工具</h2>

<ul>
<li>iOS：AppStore</li>
<li>Android：360手机助手、安卓市场、百度手机助手 、小米/华为、oppo 等商城、豌豆荚</li>
<li>常用工具：AppAnnie、应用雷达、ASO114、七麦</li>
</ul>

<h3 id="toc_5">应用商城监控</h3>

<ul>
<li>低分差评：重点看1-3 分</li>
<li>有效评论：重点看有实际描述的评论</li>
<li>异常行为：比如水军刷榜、恶意评价</li>
<li>竞品变化：监控竞对的应用变化</li>
</ul>

<h2 id="toc_6">主流社交平台与常用工具</h2>

<ul>
<li>主流平台：微博、贴吧、知乎、雪球等</li>
<li>工具：关键字、收藏夹、微博企业版、百度、google</li>
</ul>

<h2 id="toc_7">用户点评看什么</h2>

<ul>
<li>差评：为什么差评？原因、现象是什么</li>
<li>描述：重点看有实际描述的评论</li>
<li>异常行为：刷榜、恶意评价</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[abtest 数据分析]]></title>
    <link href="xuyushi.github.io/15299133098726.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133098726.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">背景</h1>

<p>在设计A/B测试时，总有一个无法避免的问题：实验数据的结果是样本数据的波动还是真实的数据提升？答案取决于数据的提升和样本量，需要使用数理统计的方法判断实验结果的科学性。</p>

<span id="more"></span><!-- more -->

<h1 id="toc_1">基础概念</h1>

<p>由于数据分析需要比较多的概念，在本节统一做介绍 <strong>（有基础的可略过本节）</strong></p>

<h2 id="toc_2">总体与样本</h2>

<p>总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。</p>

<p>实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。</p>

<p>抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。</p>

<p>抽样最重要的一点就是要尽量保证样本具有<strong>代表性</strong>，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。</p>

<h2 id="toc_3">统计量及其分布</h2>

<p>在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。</p>

<h3 id="toc_4">正态分布</h3>

<p>正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 x=μ 对称的钟形曲线，方差 σ2 决定了曲线中峰的陡峭程度。其中，μ 是正态分布的数学期望，\(σ^2\)是正态分布的方差，正态分布记为 X∼N(μ,\(σ^2\))。μ=0 且 \(σ^2\)=1 时的正态分布称为标准正态分布，记为 X∼N(0,1)。</p>

<p><img src="media/15299133098726/15269536482648.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_5">t分布</h3>

<p>通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当<strong>样本量不足的时候，误差较大，所以需要应用t分布来计算</strong>。</p>

<p>分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。</p>

<p><img src="media/15299133098726/15269537711881.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_6">参数估计</h2>

<p>根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。</p>

<p>参数估计的形式有两种：</p>

<ul>
<li>点估计：根据样本估计参数的近似值</li>
<li>区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高</li>
</ul>

<h3 id="toc_7">置信区间</h3>

<p>置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。</p>

<p><img src="media/15299133098726/15269540524945.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_8">假设检验</h2>

<p>假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。</p>

<p>假设检验运用了反证法，其一般流程是</p>

<ul>
<li>提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能</li>
<li>选择检验方法和检验统计量</li>
<li>在原假设下推导统计量的分布，比如正态分布或t分布等</li>
<li>选择显著性水平</li>
<li>计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。</li>
</ul>

<h3 id="toc_9">显著性检验</h3>

<p>拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。</p>

<p>不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 α，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 β。</p>

<p>由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 α 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验</p>

<h3 id="toc_10">双侧检验，单侧检验</h3>

<p>实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：</p>

<ul>
<li>双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端</li>
<li>单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧</li>
</ul>

<p><img src="media/15299133098726/15269547975976.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_11">检验方法</h3>

<p>上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。</p>

<p>比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。</p>

<p>总体方差已知：Z检验<br/>
总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差<br/>
总体方差未知，样本量小于30：t检验</p>

<h3 id="toc_12">Z检验</h3>

<p>todo</p>

<h3 id="toc_13">t检验</h3>

<p>todo</p>

<h3 id="toc_14">p-value</h3>

<p>在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。</p>

<p><img src="media/15299133098726/15269558290250.png" alt=""/></p>

<h1 id="toc_15">ABtest中的假设检验</h1>

<blockquote>
<p>In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]<br/>
A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.<br/>
– wikipedia</p>
</blockquote>

<p>即，A/B 测试是一种两样本的随机对照试验，<strong>在统计学上是一种两样本的假设检验</strong>。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异。<strong>从 A/B 测试的试验原理来看，它是统计学上假设检验(显著性检验)的一种形式。</strong></p>

<!--假设检验一般有四个步骤，我们以两独立样本比率检验(two independent sample evaluation)作为案例。假设微信想通过改变注册流程来提高新用户注册成功的比率。

###第一步：提出假设

一般而言有两种假设，分别是原假设(null hypothesis)和备择假设(alternative hypothesis)。原假设一般比较消极，即新注册流程与旧流程并无不同。相对应的备择假设为新注册流程与旧流程有差别。设立两种假设的逻辑是，除非在数据明显的反对原假设时，我们一般不拒绝原假设，也就是默认原假设为真。而这种“保护”会通过“容错率”来体现。

### 第二步：提取随机样本
在设置好两种注册流程之后，实验将随机选取一部分新用户提供新的流程，而剩下的一部分仍然使用老的流程。值得注意的是样本的选取一定要是随机的(random)，而且每个用户必须持续的只接收到一种流程(persistent manner)。随机分配(random split)并不要求平均分配。

### 第三步：计算检验统计量
在收集完数据后，我们需要计算检验统计量(test statistics)。检验统计量是一个用来衡量数据是否支持原假设的统计量。在这个案例中，检验统计量是

$$Z=\frac{p_t-p_c}{\sqrt{(\frac{p_t(1-p_t)}{n_t}+\frac{p_c(1-p_c)}{n_c})}}$$

其中p_t和p_c分别代表新流程和旧流程的注册成功率，n_t和n_c分别代表两者的样本数量，p_t p_c代表结合的注册成功率。直观上而言，检验统计量是取出两者成功率的差值，并通过标准差进行了标准化。如果这个检验统计量绝对值越大，就代表数据越反对原假设。

### 第四步：决定是否拒绝原假设
此时我们需要通过检验统计量绝对值的大小来判断是否拒绝原假设。在原假设下，检验统计量应该服从某种标准的分布。例如在微信的例子中，检验统计量在原假设情况下近似服从标准正态分布。当检验统计量的数值极端到在原假设时，它和更极端的情况，发生的概率非常小时，我们就说样本明显的反对原假设，因此拒绝。我们也用p值来衡量样本是否支持原假设。

-->

<p>随机将测试用户群分为2部分，用户群1使用A方案，用户群2使用B方案，经过一定测试时间后，根据收集到的两方案样本观测数据，根据显著性检验结果选取最好方案。</p>

<p>为了下文方便说明，我们不妨设A方案为参考方案（或旧方案），B方案为实验方案（或新方案）。以下我们以某流程转化率为例。</p>

<h3 id="toc_16">选取观测指标</h3>

<p>使用A方案的人数\(N_A\)，使用B方案的人数\(N_B\)，通常情况下\(N=N_A=N_B\)；</p>

<p>由样本计算出A方案转化率为\(P_a\)，B方案的转化率 为\(P_b\)</p>

<p>总体A的分布：\(A～B(N,P_a)\)，总体B的分布：\(A～B(N,P_b)\)；</p>

<p>根据中心极限定理可知，\(P_a\)和\(P_b\)均可认为近似服从正态分布：\[A～N(N,P_a(1-P_a)/N_a)\] \[B～N(N,P_b(1-P_b)/N_b)\]</p>

<p>所以根据正态分布的性质 \[X=P_b - P_a = N( P_b - P_a, (\frac{P_a(1-P_a)}{N_a}) + (\frac{P_b(1-P_b)}{N_b}))\]</p>

<h3 id="toc_17">建立原假设和备择假设</h3>

<p>由于我们的期望结果是B方案的转化率高于A 方案的转化率，所以原假设和备择假设如下：<br/>
\[H_0: X=P-b - P_a &lt;=0\]<br/>
\[H_0: X=P-b - P_a &gt;0\]</p>

<p>构建检验统计量<br/>
 \[Z=P_b - P_a = N(P_b - P_a, (\frac{P_a(1-P_a)}{N_a}) + (\frac{P_b(1-P_b)}{N_b})  )\]</p>

<h3 id="toc_18">显著性检验结论</h3>

<p>给定显著性水平为。当时\(Z&gt;Z_α\)，拒绝原假设，认为B方案的转化率高于A 方案，建议可以进行推广；当时\(Z&lt;=Z_α\)不能拒绝原假设，即认为B方案的转化率不高于A 方案，建议暂不建议进行推广。</p>

<blockquote>
<p>一般采用 α=0.05，置信度95%，则Z=1.644854</p>
</blockquote>

<!--# 参考
> https://zhuanlan.zhihu.com/p/21731601
> https://blog.csdn.net/buracag_mc/article/details/74905483
> https://www.zhihu.com/question/23680352  显著水平和pvalue 关系
> https://zhuanlan.zhihu.com/p/33415389 显著性样本？
> http://solnotes.com/2016/10/08/simple-stats-in-abtesting/
> https://zhuanlan.zhihu.com/p/21731601
> https://zhuanlan.zhihu.com/p/21829614-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABtest 平台框架]]></title>
    <link href="xuyushi.github.io/15299133098793.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133098793.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">背景</h2>

<p>目前输入法内部功能迭代，主要是通过灰度和小渠道的策略，对比新版本和旧版本的数据指标。存在着以下问题</p>

<ol>
<li>数据可能收到渠道、周期波动等因素的干扰</li>
<li>缺少聚合对比数据 指标的平台，不方便做决策</li>
<li>同时上线多个feature 对指标可能互相影响</li>
<li>新功能存在风险</li>
</ol>

<span id="more"></span><!-- more -->

<h2 id="toc_1">ABtest</h2>

<p>使用abtest平台能解决上述问题，并且具有以下优势</p>

<ol>
<li>数据共享：不限于端上的需求实验，服务端/前端页/商业化 等都能通过abtest 平台做决策</li>
<li>实验隔离：使用多层分流结构，可以同时上线多个AB实验，每个实验之间隔离，数据指标互不影响</li>
<li>风险可控：ab 实验采用动态下发机制，随时控制功能上下线</li>
<li>指标聚合：核心指标、分类指标数据聚合，易于得出结论，方便做决策</li>
<li>扩展空间：后续可扩展为消费者BG 的共享平台</li>
</ol>

<h2 id="toc_2">A/B测试的三大特性：先验、并行、科学</h2>

<ul>
<li>先验性： A/B测试结果属于预测型结论，与“后验”的归纳性结论差别巨大。后验的方式是先将版本发布，再通过数据验证效果，而A/B 测试用很少的样本量来推断新版本在全流量下的效果。</li>
<li>并行性： A/B测试将两个或以上的方案同时在线试验，保证每个版本所处环境的一致性，同时节省了验证的时间，无需在验证完一个版本之后再测试另一个。</li>
<li>科学性： A/B 测试的正确做法是将相似特征的用户均匀的分配到试验组中，确保每个组别的用户特征的相似性，从而避免辛普森悖论。</li>
</ul>

<p>A/B测试试验是产生用户阻力的地方，也是增长前进的核心动力。</p>

<h2 id="toc_3">实验流程</h2>

<p><img src="media/15299133098793/15264426763763.png" alt=""/></p>

<h2 id="toc_4">方案</h2>

<p>采用服务端多层分流方案，整体架构包括以下几个部分</p>

<p><img src="media/15299133098793/15262797128472.png" alt=""/></p>

<ul>
<li>AB 实验配置平台：产品经理/研发平时配置新实验</li>
<li>分流服务：读取 AB 实验配置平台的配置数据，执行具体的分流算法</li>
<li>集成方应用：客户端通过请求分流服务来获取具体加载哪些实验，上报实验分组和埋点</li>
<li>数据分析：分析打点数据，通过一定的数据分析算法，得出能够判断版本优劣的报表数据</li>
<li>AB实验展示平台：图标方式展示处理过的数据，方便人员做决策</li>
</ul>

<h1 id="toc_5">ABtest sdk 需求文档见附件</h1>

<!--## 人员配置
* 服务端：1 名（分流策略，处理端上上报数据）
* 大数据：1 名（数据处理/生成报表数据）
* 数据分析师：1 名（abtest 数据指标，数据处理策略，实验指标评判标准）
* 产品经理：1 名 （ab 配置平台，ab 数据平台，端上策略，分流策略，项目管理）
* Android ：1 名（abtest sdk，输入法接入，数据上报）
* UI：1 名（内部平台页面设计）
* QA: 1名 （服务端前段页面，分流策略，客户端逻辑测试）
> 人员暂定，具体时间节点按照排期决定
-->

<!--## 时间节点


| 时间  | 规划 | 备注  |
| --- | --- | --- |
| 05/17 - 05/25 | 产品细则制定，abtest 指标拟定 |  |
| 05/28 - 05/29 | 需求评审，UI 评估，技术选型，人员排期制定项目计划表 |  |
| 05/30 - 06/08 | 开发阶段 |  |
| 06/09 - 06/14 | 测试，bug 修复 |  |
| 06/15 - 06/18 | 灰度上线 |  |


> 时间为预估，具体排期待人力，需求明确后确定
-->

<!--
## 通用参数
1. 版本号
2. os version
3. 地域
4. 渠道
5. platform
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在离开北京的前夕]]></title>
    <link href="xuyushi.github.io/15299133099414.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099414.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15299133099414/15249794589499.png" alt="15249794589499"/></p>

<span id="more"></span><!-- more -->

<h1 id="toc_0">git init</h1>

<p>还记得15年那个夏天， 独自一人拖着个行李箱，连北京城的样子都还没见到，一路坐着地铁来到了五环外的一个城中村安顿了一个窝。一个人来到一座城市，定有一个理由。我当时的理由很简单 ——赚钱。那时的北京对我来说是一座完全陌生的城市，甚至陌生到没有一个朋友，一个同学。这一年学会了享受一个人时光，一个人看电影，一个人吃火锅。无拘无束，自由自在。</p>

<h1 id="toc_1">git add .</h1>

<p>在学校画pcb写单片机的我，确实没想过日后能从事互联网的工作。非常庆幸能在美团遇到这样一个机遇，还遇到一群这么好的同事。觉得每一天都很充实，海绵一样汲取着知识。渐渐的在这个城市有了朋友，可以和朋友一起跑步，狼人杀，撸串。。<br/>
北京是一个包容性很强的城市，无论你是什么妖魔鬼怪，你总能找到你的栖息地。<br/>
如果说美团是梦想起飞的地方，那么头条就像是一把火，用激情点燃梦想。 来头条一年多收获的很多，也很享受何和一群牛逼的同事做着改变世界的事情。</p>

<p><img src="media/15299133099414/15250202451953.png" alt="15250202451953" style="width:1100px;"/></p>

<h1 id="toc_2">git commit</h1>

<p>不得不承认北京是我生命的重要塑造者。至少我在毕业时，没想到在北京待着这三年能改变这么多。三年前的我很喜欢“天道酬勤”这个词？ 现在看来有些鸡汤满满，现在更喜欢“低调 务实 自驱 反思”。虽然我还是有点小懒，虽然不那么聪明，但是相比三年前的我很喜欢现在的我。有时也会想想，如果当年做的决定不是来北京，那我现在会是一个什么样的自己。</p>

<h1 id="toc_3">git checkout -b new_branch</h1>

<p>从来没想过在北京扎根，这是一个不属于我的城市，昂贵的房价并负担不起，户口也看不到希望，离开北京对于我来说只是时间问题。但离开了北京确实也舍弃了很多东西，也不清楚这次离开北京的选择是不是正确。</p>

<p>人一生有太多的选择，可能当年某个午后很小的选择，未来的一切都会变的不一样，如果当年没有读研？如果当年不选择来北京？如果当面选择继续做硬件？如果没有来头条？如果没有遇到她？之前每次回首自己做的重大决定，都很庆幸自己选择了正确的路。但细想下，也可能每条路的结果都不差看你怎么对待自己的选择，每条路都不是一帆风顺的，是抱怨后悔当初的决定？还是脚踏实地的向前？ 也可能这过程更为重要吧。同时也做了最坏的打算，真的觉得离开北京不适合，大不了再 <code>git checkout -b</code>一个继续撸咯。</p>

<p>还有不到24小时离开北京，没有太多的遗憾，只是有些不舍，舍不得的不是北京这座城，而是我的朋友们。愿我们未来一切都好。</p>

<blockquote class="blockquote-center">北京的小伙伴们，再见了，有缘的话。</blockquote>

<p><img src="media/15299133099414/15249794854372.png" alt="15249794854372" style="width:1100px;"/></p>

<p><img src="media/15299133099414/15250146162808.png" alt="15250146162808" style="width:1100px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins 平台搭建]]></title>
    <link href="xuyushi.github.io/15299133099249.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099249.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<h3 id="toc_1">java 环境搭建</h3>

<pre><code class="language-bash">java -version
</code></pre>

<p>如果显示Java版本号，说明已经正确安装，如果显示没有该命令，需要安装Java：<br/>
<span id="more"></span><!-- more --></p>

<h4 id="toc_2">mac</h4>

<pre><code class="language-bash">brew cask install java
</code></pre>

<h4 id="toc_3">linux</h4>

<pre><code class="language-bash">sudo yum install java
</code></pre>

<p>该命令如果检测到Java不存在可以直接安装Java,如果已存在则可以升级Java</p>

<p>环境配置 vim /etc/profile 追加</p>

<pre><code class="language-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64/
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
</code></pre>

<h3 id="toc_4">jenkins 安装</h3>

<h4 id="toc_5">mac</h4>

<pre><code class="language-bash">brew install jenkins 
</code></pre>

<h4 id="toc_6">Linux</h4>

<pre><code class="language-bash">sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo
sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
</code></pre>

<p>添加完成之后直接使用yum命令安装Jenkins:<br/>
<code>yum install jenkins<br/>
</code></p>

<h2 id="toc_7">启动</h2>

<p>命令行直接启动</p>

<p>mac </p>

<pre><code class="language-bash">Jenkins
</code></pre>

<p>linux </p>

<pre><code class="language-bash">sudo service jenkins start
Starting Jenkins                                           [  OK  ]
</code></pre>

<blockquote>
<p>默认端口 8080 可能冲突 需要修改  <code>vim /etc/sysconfig/jenkins</code></p>
</blockquote>

<h2 id="toc_8">环境配置</h2>

<blockquote>
<p>admin 密码 在 sudo cat /var/lib/jenkins/secrets/initialAdminPassword</p>
</blockquote>

<p>启动完毕后，打开浏览器，在地址栏中输入localhost:8080</p>

<p>系统管理 -&gt; 系统设置 ，填写Android 环境变量</p>

<p><img src="media/15299133099249/15240201058052.jpg" alt=""/></p>

<h1 id="toc_9">插件管理</h1>

<p>获取插件失败 ，需要将https 降级为http<br/>
<img src="media/15299133099249/15240202191693.jpg" alt=""/></p>

<p>系统管理 -&gt; 系统设置 -&gt; 插件管理 -&gt; 高级</p>

<p>升级站点改为 <br/>
<a href="http://mirrors.jenkins-ci.org/status.html">http://mirrors.jenkins-ci.org/status.html</a></p>

<p>下载插件</p>

<ul>
<li>Gradle</li>
<li>git</li>
<li>gitlab</li>
<li>ssh</li>
<li>等</li>
<li><br/>
## 新建项目
<img src="media/15299133099249/15240215365291.jpg" alt=""/></li>
</ul>

<p>可以增加参数化的构建</p>

<p><img src="media/15299133099249/15242012652458.jpg" alt=""/></p>

<p>打包完后工作空间即可生成对应的打包文件</p>

<p><img src="media/15299133099249/15240222554515.jpg" alt=""/></p>

<blockquote>
<p>构建local 文件 需要，file:// + <git 仓库文件路径></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gitlab 搭建]]></title>
    <link href="xuyushi.github.io/15299133099310.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099310.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">安装</h1>

<pre><code class="language-bash">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
yum install gitlab-ce
</code></pre>

<span id="more"></span><!-- more -->

<!--```bash
Retrieving key from https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey
Importing GPG key 0xE15E78F4:
 Userid     : "GitLab B.V. (package repository signing key) <packages@gitlab.com>"
 Fingerprint: 1a4c 919d b987 d435 9396 38b9 1421 9a96 e15e 78f4
 From       : https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey
Is this ok [y/N]:
```
-->

<h1 id="toc_1">启动 GitLab</h1>

<p>安装完成之后，打开配置文件<code>/etc/gitlab/gitlab.rb</code>将 <code>external_url = &#39;http://git.example.com&#39;</code>修改为自己的 IP 地址：<code>external_url &#39;http://ip_address&#39;</code>，然后执行下面的命令，对 GitLab 进行编译：</p>

<pre><code class="language-bash">gitlab-ctl reconfigure
</code></pre>

<h1 id="toc_2">GitLab 基本配置</h1>

<p>GitLab 的相关参数配置都存在 /etc/gitlab/gitlab.rb 文件里。自 GitLab 7.6 开始的新安装包, 已经默认将所有的参数写入到 /etc/gitlab/gitlab.rb 配置文件中。</p>

<h2 id="toc_3">配置端口</h2>

<p>GitLab 默认使用 80 端口对外提供服务，因为 80 端口被其他服务占用，所以需要更改。打开 /etc/gitlab/gitlab.rb 配置文件，修改 external_url &#39;http://ip_address&#39; 为 external_url &#39;http://ip_address:new-port&#39;，</p>

<p>报错 </p>

<pre><code class="language-bash">There was an error running gitlab-ctl reconfigure:

execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 390) had an error: Mixlib::ShellOut::ShellCommandFailed: Expected process to exit with [0], but received &#39;&#39;
---- Begin output of /opt/gitlab/bin/gitlab-rake cache:clear ----
STDOUT:
STDERR:
---- End output of /opt/gitlab/bin/gitlab-rake cache:clear ----
Ran /opt/gitlab/bin/gitlab-rake cache:clear returned

</code></pre>

<p>原来是机器内存没达到gitlab的要求，我的机器内存只有1G，gitlab的要求1G ram+1G swap</p>

<p>ubuntu下增加swap交换空间参考 </p>

<blockquote>
<p><a href="http://www.huzs.net/?p=1683">http://www.huzs.net/?p=1683</a></p>
</blockquote>

<h2 id="toc_4">Credentials</h2>

<ol>
<li>设置是 需要将开发机私钥设置copy 进jenkins</li>
<li>开发机共钥放 gitlab</li>
<li>本地机的  共钥放 gitlab
<img src="media/15299133099310/15242020277016.jpg" alt=""/></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android sdk 搭建]]></title>
    <link href="xuyushi.github.io/15299133099366.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099366.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Step 1. Download and Install Android SDK.</h2>

<pre><code class="language-bash">mkdir -p /opt/sdk-tools-linux-3859397
cd /opt/sdk-tools-linux-3859397
sudo wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip
sudo unzip sdk-tools-linux-3859397.zip
cd /opt
sudo chown -R root:root sdk-tools-linux-3859397
sudo ln -s sdk-tools-linux-3859397 android-sdk
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Step 2. Set Android SDK Environment Value.</h2>

<pre><code class="language-bash"> sudo vim /etc/profile.d/android-sdk-env.sh

export ANDROID_HOME=&quot;/opt/android-sdk&quot;
export PATH=&quot;$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH&quot;

sudo source /etc/profile.d/android-sdk-env.sh
</code></pre>

<h2 id="toc_2">Step 3.1 Update Android SDK.</h2>

<pre><code class="language-bash">cd /opt/android-sdk/tools
sudo ./android update sdk --no-ui
</code></pre>

<h2 id="toc_3">Step 3.2 Update Android SDK.</h2>

<p>Use Command Line to Update Android SDK</p>

<p>This is an example.</p>

<pre><code class="language-bash">/opt/android-sdk/tools/bin/sdkmanager --list
/opt/android-sdk/tools/bin/sdkmanager &quot;tools&quot; &quot;build-tools;26.0.0&quot; &quot;extras;android;m2repository&quot; &quot;extras;google;google_play_services&quot; &quot;platforms;android-26&quot; &quot;platform-tools&quot;
Posted by Moon Light February 1, 2016   android
</code></pre>

<h2 id="toc_4">更新sdk 版本</h2>

<pre><code class="language-bash">android update sdk --no-ui --all --filter &quot;android-23&quot;

android update sdk -u -t tool,platform-tool -a
</code></pre>

<p>yum install java-devel</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven 搭建]]></title>
    <link href="xuyushi.github.io/15299133099121.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099121.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<p>下载 </p>

<pre><code class="language-bash">wget -P /usr/local http://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz
</code></pre>

<p>安装</p>

<pre><code class="language-bash"># cd /usr/local
# mkdir nexus
# tar -zxvf nexus-3.6.0-02-unix.tar.gz -C nexus //解压缩到nexus文件夹（其中包含nexus-3.6.0-02和sonatype-work）

# cd nexus
# mv nexus-3.6.0-02/ nexus
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">配置</h2>

<p>自定义配置虚拟机可打开 nexus.vmoptions 文件进行配置（如果Linux硬件配置比较低的话，建议修改为合适的大小，否则会出现运行崩溃的现象）：</p>

<pre><code class="language-bash">vim nexus/config/nexus.vmoptions   
</code></pre>

<p>修改端口号</p>

<pre><code class="language-bash">application-host=&lt;vps 的ip&gt;
</code></pre>

<h2 id="toc_2">启动</h2>

<pre><code class="language-bash">/usr/local/nexus/nexus/bin/nexus start 
</code></pre>

<h2 id="toc_3">配置</h2>

<p>打开 <a href="http://ip:%E7%AB%AF%E5%8F%A3/nexus/">http://ip:端口/nexus/</a> ，初始账号 admin 密码 admin123</p>

<p>添加自己的仓库</p>

<p><img src="media/15299133099121/15242064068383.jpg" alt=""/></p>

<p>增加 user</p>

<p><img src="media/15299133099121/15242066550367.jpg" alt=""/></p>

<p><img src="media/15299133099121/15242067791896.jpg" alt=""/></p>

<h2 id="toc_4">android studio 打包上传</h2>

<p>新建一个测试 Android library moudle</p>

<p>peoject gradle 增加maven 仓库地址</p>

<pre><code class="language-gradle">buildscript {
    
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.0.0&#39;
        

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        repositories {
            maven { url &#39;http://xxx.xxx.1xx.3xxx:xxxx/nexus/content/repositories/testRep/&#39; }
        }
    }
}

</code></pre>

<p>library build.gradle 增加</p>

<pre><code class="language-gradle">apply plugin: &#39;maven&#39;
apply plugin: &#39;signing&#39;

def SNAPSHOT_REPOSITORY_URL = &#39;http://108.160.133.31:20014/nexus/content/repositories/testRep-snapshot/&#39;
def RELEASE_REPOSITORY_URL = &#39;http://108.160.133.31:20014//nexus/content/repositories/testRep/&#39;

uploadArchives {
    repositories {
        mavenDeployer {
            pom.groupId = &#39;io.github.xuyushi&#39;
            pom.artifactId = &#39;test&#39;
            pom.version = &#39;1.0.3&#39;
            repository(url: RELEASE_REPOSITORY_URL) {
                authentication(userName:&#39;xxxx&#39;, password: &#39;*****&#39;)
            }
            snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {
                authentication(userName:&#39;xxxx&#39;, password: &#39;****&#39;)
            }
        }
    }
}


</code></pre>

<p>编译上传</p>

<pre><code class="language-bash">../gradlw upload
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架3-Kotlin]]></title>
    <link href="xuyushi.github.io/15299133099083.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099083.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">gradle 修改</h2>

<p>加入 kotlin 之后需要使用 kapt,gradle 修改为</p>

<pre><code class="language-gradle">    //kotlin
    //dagger
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;

    compile &quot;com.blankj:utilcode:$rootProject.androidUtilsVerson&quot;
    //不加无法编译通过
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.kotlin_version&quot;

</code></pre>

<span id="more"></span><!-- more -->

<p>project gradle</p>

<pre><code class="language-gradle">buildscript {
    ext.kotlin_version = &#39;1.1.51&#39;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre>

<p>可以使用 AS 3.0 的新功能 或者 kotlin 插件，将项目整个工程转为 kotlin</p>

<h2 id="toc_1">注意，有几处 需要手动修改</h2>

<h3 id="toc_2">定义的dagger注解</h3>

<pre><code class="language-kotlin">@Scope
@kotlin.annotation.Retention
annotation class ActivityScoped

@Scope
@kotlin.annotation.Retention
annotation class FragmentScoped

</code></pre>

<h2 id="toc_3">注入使用</h2>

<pre><code class="language-gradle">    @Inject
    lateinit var mPresenter: RegisterContract.Presenter
</code></pre>

<p>需要使用 <code>lateinit</code> 来表示延迟初始化 </p>

<h2 id="toc_4">优化 mvp 结构</h2>

<p>可以将在 Presenter 接口这持有 view （view 是abs），复写接口的时候复写改 view</p>

<pre><code class="language-kotlin">
interface BasePresenter&lt;T&gt; {
    var mView:T?
    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    fun takeView(view: T){
        mView = view
    }

    /**
     * Drops the reference to the view when destroyed
     */
    fun dropView(){
        mView = null
    }

}

</code></pre>

<p>并在<code>takeView</code> <code>dropView</code> 对 view 进行复制，这样的好处就是复现该接口的同时就不用重复这些代码了 。而 java在接口也不能定义变量，在接口方法也也不能定义操作</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架3-Kotlin]]></title>
    <link href="xuyushi.github.io/15299133099209.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099209.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">gradle 修改</h2>

<p>加入 kotlin 之后需要使用 kapt,gradle 修改为</p>

<pre><code class="language-gradle">    //kotlin
    //dagger
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;

    compile &quot;com.blankj:utilcode:$rootProject.androidUtilsVerson&quot;
    //不加无法编译通过
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.kotlin_version&quot;

</code></pre>

<span id="more"></span><!-- more -->

<p>project gradle</p>

<pre><code class="language-gradle">buildscript {
    ext.kotlin_version = &#39;1.1.51&#39;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre>

<p>可以使用 AS 3.0 的新功能 或者 kotlin 插件，将项目整个工程转为 kotlin</p>

<h2 id="toc_1">注意，有几处 需要手动修改</h2>

<h3 id="toc_2">定义的dagger注解</h3>

<pre><code class="language-kotlin">@Scope
@kotlin.annotation.Retention
annotation class ActivityScoped

@Scope
@kotlin.annotation.Retention
annotation class FragmentScoped

</code></pre>

<h2 id="toc_3">注入使用</h2>

<pre><code class="language-gradle">    @Inject
    lateinit var mPresenter: RegisterContract.Presenter
</code></pre>

<p>需要使用 <code>lateinit</code> 来表示延迟初始化 </p>

<h2 id="toc_4">优化 mvp 结构</h2>

<p>可以将在 Presenter 接口这持有 view （view 是abs），复写接口的时候复写改 view</p>

<pre><code class="language-kotlin">
interface BasePresenter&lt;T&gt; {
    var mView:T?
    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    fun takeView(view: T){
        mView = view
    }

    /**
     * Drops the reference to the view when destroyed
     */
    fun dropView(){
        mView = null
    }

}

</code></pre>

<p>并在<code>takeView</code> <code>dropView</code> 对 view 进行复制，这样的好处就是复现该接口的同时就不用重复这些代码了 。而 java在接口也不能定义变量，在接口方法也也不能定义操作</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架2-mvp 结构]]></title>
    <link href="xuyushi.github.io/15299133100126.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100126.html</id>
    <content type="html"><![CDATA[
<p>之前有两篇文章已经详细介绍过 mvp  <a href="http://xuyushi.github.io/2016/02/28/MVP/">Android 中的MVP 模式</a>    <a href="http://xuyushi.github.io/2016/04/30/%E5%9C%B0%E5%9B%BE%E5%8C%BA%E5%9F%9F%E7%BB%98%E5%88%B6%20MVP%20%E5%AE%9E%E8%B7%B5/">地图区域绘制 MVP 实践</a> ，本篇结合上篇的依赖注入使用<br/>
<span id="more"></span><!-- more --></p>

<h1 id="toc_0">定义 base 类</h1>

<p>定义 view 和 Presenter 的 interface</p>

<pre><code class="language-java">public interface BaseView&lt;T&gt; {

}
public interface BasePresenter&lt;T&gt; {

    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    void  takeView(T view);

    /**
     * Drops the reference to the view when destroyed
     */
    void dropView();

}


</code></pre>

<p>presenter 的<code>takeView</code>在 view 对应的resume 生命周期中获取 view ，在 desdroy 中 将 view 赋值为 null ，以免内存泄露。</p>

<h2 id="toc_1">Contract</h2>

<p>Contract 为 view 和 Presenter 的继承接口 <br/>
举个例子 实现一个 splash 页面</p>

<pre><code class="language-java">
public interface SplashContract {
    interface View extends BaseView&lt;Presenter&gt; {
        void showWaitingPage();
    }

    interface Presenter extends BasePresenter&lt;View&gt; {
        void goLogin();

        void goMain();

        void tryLogin();

        void takeView(SplashContract.View view);
    }
}

</code></pre>

<p>SplashPresenter</p>

<pre><code class="language-java">class SplashPresenter implements SplashContract.Presenter{

    @Inject
    public SplashPresenter() {
    }

    @Nullable
    private SplashContract.View mView;

    @Override
    public void goLogin() {
        ToastUtils.showShort(&quot;go login&quot;);
        ActivityUtils.startActivity(LoginActivity.class);
    }

    @Override
    public void goMain() {
        ToastUtils.showShort(&quot;go Main&quot;);
        ActivityUtils.startActivity(MainActivity.class);
    }

    @Override
    public  void tryLogin() {
        Handler requestHandler = new Handler(Looper.getMainLooper());
        requestHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                boolean islogin = false;
                if (islogin) {
                    goMain();
                } else {
                    goLogin();
                }
            }
        }, 1000);


    }

    @Override
    public void takeView(SplashContract.View view) {
        mView = view;
        if (mView != null) {
            mView.showWaitingPage();
        }
    }

    @Override
    public void dropView() {
        mView = null;
    }
}

</code></pre>

<blockquote>
<p>注意 <br/>
在构造方法是 使用 <code>@Inject</code> 注解，一遍 dagger 框架能找到该类<br/>
每次调用view 中的方法时，都要进行判空，感觉上用 kotlin 代码会更方便点</p>
</blockquote>

<pre><code class="language-java">public class SplashActivity extends BaseActivity implements SplashContract.View {
    @Inject
    Context mContext;

    @Inject
    SplashContract.Presenter mPresenter;

    @BindView(R.id.ll_root)
    LinearLayout mLlRoot;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mPresenter.tryLogin();
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                ContactUtil.getContacts(mContext);
            }
        });
        thread.start();
    }

    @Override
    protected int getLayout() {
        return R.layout.activity_splash;
    }

    @Override
    protected void onResume() {
        super.onResume();
        mPresenter.takeView(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mPresenter.dropView();
    }

    @Override
    public void showWaitingPage() {
//        mLlRoot.setBackground(R.mipmap.ic_launcher);
    }
}
</code></pre>

<ol>
<li>Activity 实现view 接口，并在<code>onResume</code> 时<code>akeView</code>，<code>onDestroy</code> 时<code>dropView</code></li>
<li>通过 dagger 注入找到对应的 presenter </li>
</ol>

<p>为了能找到 Presenter ，我们还应该建立接口和对应实现的联系 ，可以使用 <code>@bind</code>注解 </p>

<p>SplashPresenterModule</p>

<pre><code class="language-java">@Module
public abstract class SplashPresenterModule {

    @ActivityScoped
    @Binds
    abstract SplashContract.Presenter statitsticsPresenter(SplashPresenter presenter);
}

</code></pre>

<p>然后在上篇文章提到的<code>ActivityBindingModule</code> 中，加入该 Activity 和改 module</p>

<pre><code class="language-java">@Module
public abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = TellTruePresenterModule.class)
    abstract MainActivity mainActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = SplashPresenterModule.class)
    abstract SplashActivity splashActivity();

}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架1-依赖注入]]></title>
    <link href="xuyushi.github.io/15299133100165.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100165.html</id>
    <content type="html"><![CDATA[
<p>关于依赖注入在 <a href="http://xuyushi.github.io/2017/04/08/Android%20CleanArchitecture%20--Dagger/">之前的文章里有详细的分析</a></p>

<p>而最近的 dagger 的更新又再次方便了注入过程 。<br/>
回顾之前的 dagger 在 Activity 、fragment 等 Android 组件中是如何注入的</p>

<ol>
<li>在 moduel 中，提供所需注入的元素的构造方法</li>
<li>构造对应的 <code>Component</code>，包含所需的 <code>module</code>，并将<code>module</code> 中的方法暴露出。并申明对应的inject方法 </li>
<li>在actvity 中注入</li>
</ol>

<p>这样做的弊端是 <br/>
<span id="more"></span><!-- more --></p>

<ol>
<li>即使Dagger使我们的代码耦合性更低，但是如果要面临重构，我们仍然不得不去面对每个Activity中这样数行需要我们「复制」+「粘贴」的代码，这会给我们的重构带来一定的难度（试想一下，如果我们的应用有数十个乃至上百个这样的Activity或者Fragment容器，我们的重构计划，首先就要面对这样数百行的代码）。<br/></li>
<li>更重要的是，它要求注射类型（FrombulationActivity）知道其注射器。 即使这是通过接口而不是具体类型完成的，它打破了依赖注入的核心原则：一个类不应该知道如何实现依赖注入。</li>
<li>在开发过程中明显发现，在每个 Activity 中构造对应的<code>Component</code>，然后注入 是件很恶心的事情，而且这个注入并不能写入 base 类中，只能每个 Activity 中再重复写入</li>
</ol>

<p>在新版的 dagger 中提供了 <code>ContributesAndroidInjector</code>这样一个注解</p>

<p>看下官方文档如何描述的</p>

<pre><code class="language-java">/**
 * Generates an {@link AndroidInjector} for the return type of this method. The injector is
 * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}&#39;s
 * component.
 *
 * &lt;p&gt;This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
 * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
 * MyService}, etc). The method should have no parameters.
 *
 * &lt;p&gt;For more information, see &lt;a href=&quot;https://google.github.io/dagger/android&quot;&gt;the docs&lt;/a&gt;
 */
</code></pre>

<p><code>@ContributesAndroidInjector</code>使用在 module 中的抽象方法上。该方法不该有参数，<strong>返回类型必须是 Activity、Fragment 和 Service 等 Android Framework 的类型</strong>。dagger 将会为这样的一个方法生成一个对应的 Subcomponent。这个注解还能接受一系列 Module 作为值，这些 module 将会成为所生成的 Subcomponent 的 module。</p>

<h2 id="toc_0">搭建过程</h2>

<h3 id="toc_1">添加依赖</h3>

<pre><code class="language-gradle">    // Dagger dependencies
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    annotationProcessor &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot; // if you use the support libraries
    annotationProcessor &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;

</code></pre>

<h2 id="toc_2">ActivityBindingModule</h2>

<p>ActivityBindingModule 使用dagger 框架提供<code>ContributesAndroidInjector注解</code> 辅助我们注入 Android 框架</p>

<pre><code class="language-java">@Module
public abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = TellTruePresenterModule.class)
    abstract MainActivity mainActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = SplashPresenterModule.class)
    abstract SplashActivity splashActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = LoginModule.class)
    abstract LoginActivity loginActivity();
}
</code></pre>

<p>以后每次增加 Activity 或者 service 等，只要在这添加一行代码就行了，不需要修改对应的 Activity</p>

<h2 id="toc_3">AppComponent</h2>

<pre><code class="language-java">@Singleton
@Component(modules = {TasksRepositoryModule.class,
        ApplicationModule.class,
        ActivityBindingModule.class,
        AndroidSupportInjectionModule.class})

public interface AppComponent extends AndroidInjector&lt;DaggerApplication&gt; {

    void inject(MyApplication application);

    TasksRepository getTasksRepository();

    @Override
    void inject(DaggerApplication instance);

    // Gives us syntactic sugar. we can then do DaggerAppComponent.builder().application(this).build().inject(this);
    // never having to instantiate any modules or say which module we are passing the application to.
    // Application will just be provided into our app graph now.
    @Component.Builder
    interface Builder {

        @BindsInstance
        AppComponent.Builder application(Application application);

        AppComponent build();
    }

//    APIInterface APIInterface();
}

</code></pre>

<p>注意注解中 module 的依赖</p>

<h2 id="toc_4">ApplicationModule</h2>

<pre><code class="language-java">@Module
public abstract class ApplicationModule {
    //expose Application as an injectable context
    @Binds
    abstract Context bindContext(Application application);

    @Provides
    public static APIInterface provideInterface() {
        Retrofit retrofit= new Retrofit.Builder()
                .baseUrl(&quot;https://api.github.com&quot;)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        APIInterface service = retrofit.create(APIInterface.class);
        return service;
    }
}


</code></pre>

<p>可以把全局的一些单例类放在这个 moduel。 比如<code>RetrofitService</code>、application 的<code>context</code> 等 </p>

<h2 id="toc_5">添加 Activity fragment 的 scope</h2>

<pre><code class="language-java">@Documented
@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface ActivityScoped {
}


@Scope
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface FragmentScoped {}

</code></pre>

<h2 id="toc_6">application 中 inject</h2>

<pre><code class="language-java">public class MyApplication extends DaggerApplication {
    @Inject
    TasksRepository tasksRepository;

    @Override
    protected AndroidInjector&lt;? extends DaggerApplication&gt; applicationInjector() {
        AppComponent appComponent = DaggerAppComponent.builder().application(this).build();
        appComponent.inject(this);
        return appComponent;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Utils.init(this);
    }
}

</code></pre>

<blockquote>
<p>注意 <br/>
activity 和 fragment 等都要 extend 自 dagger 中的对应类，也可以将对应的逻辑抽象至 base 类中</p>
</blockquote>

<p>最后可以将以上类放入同一个包中<br/>
<img src="media/15299133100165/15091645703766.png" alt=""/></p>

<h1 id="toc_7">参考</h1>

<blockquote>
<p><a href="https://juejin.im/entry/593cee56ac502e006b3dc9c2">https://juejin.im/entry/593cee56ac502e006b3dc9c2</a><br/>
<a href="https://segmentfault.com/a/1190000010016618">https://segmentfault.com/a/1190000010016618</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架0-前言]]></title>
    <link href="xuyushi.github.io/15299133100210.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100210.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">前言</h1>

<p>有幸在公司从零开始做一个项目，非常兴奋。也想着在快速开发的过程中如何保持 app 代码结构 clean。由此总结此次代码整体框架的搭建过程，供日后回顾总结</p>

<span id="more"></span><!-- more -->

<p>通过这几天的调研 ，初步决定使用以下</p>

<ol>
<li>mvp 结构，view 和业务逻辑解耦，并可以在 UI 未给出切图时优先开发业务逻辑。</li>
<li>dagger 注入。 是的 v p 之间无依赖关系</li>
<li>~~clean 结构 。 将 业务逻辑独立到每个 usecase中 ~~。发现前期轻量级的 app 并不适合这种结构，使用 usecase 会降低开发效率，此模式更适合与 app 成型后 ，将可以复用的业务逻辑抽象成 usecase</li>
<li>butteknief 注入 </li>
<li>网络库待定 ？repository 模式 ，方便后期网络库更换</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture Components--Room  Persistence Library]]></title>
    <link href="xuyushi.github.io/15299133101299.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133101299.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">Room Persistence Library</h1>

<p>Room 在 SQLite 之上提供了一个抽象层，以便在利用 SQLite 全部功能的同时能够流畅的访问数据库。</p>

<p>将数据持久化到本地对于应用程序处理大量结构化数据有非常大的好处。最常见的情况是缓存相关数据。这样，当设备无法访问网络时，用户仍然可以在离线状态下浏览内容。然后，在设备重新上线后，任何用户发起的内容变更都会同步到服务器。</p>

<p>核心框架提供了内置支持来处理原始的 SQL 内容。虽然这些 API 是强大的，但是它们非常低级并且使用起来需要话费巨大的时间和精力：<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>原始的 SQL 查询没有编译时验证。随着数据图的更改，需要手动更新收影响的 SQL 查询。这个过程是耗时的并且容易出错。</li>
<li>需要使用大量的样板代码用于在 SQL 查询和 Java 数据对象之间转换。</li>
</ul>

<p>Room 在 SQLite 之上提供的抽象层帮助处理这些问题。</p>

<p>Room 有 3 个重大的组件：</p>

<ul>
<li>Database：可以使用此组件创建数据库的持有者。通过注解定义实体列表，通过类的内容定义数据库中数据访问对象（DAO）列表。它是底层连接的主要接入点。</li>
</ul>

<p>注解的类应该是一个继承了 RoomDatabase 的抽象类。在运行时，可以通过调用 Room.databaseBuilder() 或 Room.inMemoryDatabaseBuilder() 获取一个实例。</p>

<ul>
<li>Entity：该组件表示一个保存有数据库行的类。对于每个 Entity，创建一个数据库表来保存项目。必须通过 Database 中的 entities 字段引用 Entity 类。Entity 中的每个字段都会持久化到数据库中，除非使用 @Ignore 注解。</li>
</ul>

<blockquote>
<p>注：Entity 可以拥有一个空的构造函数（如果 DAO 可以访问每个持久化的字段）或一个参数的类型和名字和 Entity 中的字段都匹配的构造函数。Room 还可以使用全部或部分的构造函数，如只接受部分字段的构造函数。</p>
</blockquote>

<ul>
<li>DAO：该组件表示一个数据访问对象（DAO）的类或接口。DAO 是 Room 的主要组件，其职责是定义方法来访问数据库。被 @Database 注解的类必须包含一个没有参数的抽象方法，该方法的返回值是被 @Dao 注解的类。在编译时生成代码时，Room 创建该类的实现。<br/>
&gt; 注：通过使用 DAO 访问数据库，而不是使用查询建造者或直接查询，可以分离数据库结构的不同组件。另外，DAO 可以在测试应用时很容易的模拟数据库。</li>
</ul>

<p>这些组件及其与应用程序其它部分的关系，如图 1 所示：</p>

<p><img src="media/15299133101299/14985505743620.png" alt=""/></p>

<p>以下代码片段包含了一个具有一个 Entity 和一个 DAO 的数据库配置：</p>

<p>User.java</p>

<pre><code class="language-java">
@Entity
public class User {
    @PrimaryKey
    private int uid;

    @ColumnInfo(name = &quot;first_name&quot;)
    private String firstName;

    @ColumnInfo(name = &quot;last_name&quot;)
    private String lastName;

    // 简单起见忽略了 Getters 和 setters，
    // 但是 Room 需要它们。
}
</code></pre>

<p>UserDao.java</p>

<pre><code class="language-java">@Dao
public interface UserDao {
    @Query(&quot;SELECT * FROM user&quot;)
    List&lt;User&gt; getAll();

    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)
    List&lt;User&gt; loadAllByIds(int[] userIds);

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;
           + &quot;last_name LIKE :last LIMIT 1&quot;)
    User findByName(String first, String last);

    @Insert
    void insertAll(User... users);

    @Delete
    void delete(User user);
}
</code></pre>

<p>AppDatabase.java</p>

<pre><code class="language-java">
@Database(entities = {User.class}, version = 1)
public abstract class AppDatabase extends RoomDatabase {
    public abstract UserDao userDao();
}
</code></pre>

<p>创建上述文件之后，使用如下代码获取创建的数据库实例：</p>

<pre><code class="language-java">AppDatabase db = Room.databaseBuilder(getApplicationContext(),
        AppDatabase.class, &quot;database-name&quot;).build();
</code></pre>

<blockquote>
<p>注：在实例化 AppDatabase 对象时应该遵循单例设计模式，因为每个 RoomDatabase 实例都非常昂贵，并且很少需要访问多个实例。</p>
</blockquote>

<h2 id="toc_1">Entity</h2>

<p>当一个类被 @Entity 注解并且被 @Database 注解的 entities 参数引用，Room 会在数据库中为该 Entity 创建一个数据库表。</p>

<p>默认情况下，Room 为每个定义在 Entity 中的字段创建列。如果不希望 Entity 中某些字段被持久化，可以使用 @Ignore 注解这些字段。如下面的代码片段所示：</p>

<pre><code class="language-java">
@Entity
class User {
    @PrimaryKey
    public int id;

    public String firstName;
    public String lastName;

    @Ignore
    Bitmap picture;
}

</code></pre>

<p>要持久化一个字段，Room 必须有权限访问它。可以将字段设置为 public，或为该字段提供 setter 和 getter 方法。如果使用 setter 和 getter 方法，请记住，它们基于 Room 中的 Java Beans 约定。</p>

<h3 id="toc_2">主键</h3>

<p>每个 Entity 必须定义至少一个字段作为主键。即使只有一个字段，仍然需要使用 @PrimaryKey 注解该字段。如果希望 Room 为 Entity 分配自动 ID，可以设置 @PrimaryKey 的 autoGenerate) 属性。如果 Entity 有复合主键，可以使用 @Entity 注解的 primaryKeys) 属性，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(primaryKeys = {&quot;firstName&quot;, &quot;lastName&quot;})
class User {
    public String firstName;
    public String lastName;

    @Ignore
    Bitmap picture;
}
</code></pre>

<p>默认情况下，Room 使用类名作为数据库表的名字。如果希望数据库表有不同的名字，可以设置 @Entity 的 tableName) 属性，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(tableName = &quot;users&quot;)
class User {
    ...
}
</code></pre>

<blockquote>
<p>SQLite 中的表名不区分大小写。</p>
</blockquote>

<p>类似于 tableName) 属性，Room 使用字段名字作为数据库中列的名字。如果想要不同的列名，给字段添加一个 @ColumnInfo 注解，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(tableName = &quot;users&quot;)
class User {
    @PrimaryKey
    public int id;

    @ColumnInfo(name = &quot;first_name&quot;)
    public String firstName;

    @ColumnInfo(name = &quot;last_name&quot;)
    public String lastName;

    @Ignore
    Bitmap picture;
}
</code></pre>

<h3 id="toc_3">索引和唯一性</h3>

<p>根据访问数据的方式，可能需要在数据库中索引某些字段来加速查询。要给 Entity 添加索引，需要在 @Entity 注解中添加 indices) 属性，列出想要包含在索引或复合索引中的列的名字。以下代码片段演示了该注解过程：</p>

<pre><code class="language-java">@Entity(indices = {@Index(&quot;name&quot;), @Index(&quot;last_name&quot;, &quot;address&quot;)})
class User {
    @PrimaryKey
    public int id;

    public String firstName;
    public String address;

    @ColumnInfo(name = &quot;last_name&quot;)
    public String lastName;

    @Ignore
    Bitmap picture;
}

</code></pre>

<p>有时，有些字段或字段组必须是唯一的。可以通过设置 @Index 注解的 unique) 属性为 true 来实施唯一性。以下示例代码可以防止表中的两行数据具有一组相同的 firstNmae 列和 lastName 列：</p>

<pre><code class="language-java">@Entity(indices = {@Index(value = {&quot;first_name&quot;, &quot;last_name&quot;},
        unique = true)})
class User {
    @PrimaryKey
    public int id;

    @ColumnInfo(name = &quot;first_name&quot;)
    public String firstName;

    @ColumnInfo(name = &quot;last_name&quot;)
    public String lastName;

    @Ignore
    Bitmap picture;
}
</code></pre>

<h3 id="toc_4">关系</h3>

<p>因为 SQLite 是一个关系型数据库，可以指定两个对象间的关系。即使大多数 ORM 库允许 Entity 对象之间互相引用，但是 Room 明确禁止这样做。详细信息，请参阅附录：Entity 之间无对象引用。</p>

<p>虽然不能使用直接关系，但是 Room 允许在 Entity 之间定义外键约束。</p>

<p>例如，有一个名为 Book 的 Entity，可以使用 @ForeignKey 注解定义其和 User 的关系，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(foreignKeys = @ForeignKey(entity = User.class,
                                  parentColumns = &quot;id&quot;,
                                  childColumns = &quot;user_id&quot;))
class Book {
    @PrimaryKey
    public int bookId;

    public String title;

    @ColumnInfo(name = &quot;user_id&quot;)
    public int userId;
}
</code></pre>

<p>外键是非常有用的，外键可以让你指定当应用的 Entity 更新时做什么。例如，通过在 @ForeignKey 注解中包含 onDelete=CASCADE) 可以告诉 SQLite 如果相应的 User 实例被删除，则删除该用户的所有图书。</p>

<blockquote>
<p>注：SQLite 将 @Insert(OnConflict=REPLACE) 当作一组 REMOVE 和 REPLACE 操作来处理，而不是当作单独的 UPDATE 操作处理。这种替换冲突值的方法可能会影响外键约束。更多详细信息，请参阅 SQLite 文档的 ON_CONFLICT 子句。</p>
</blockquote>

<h3 id="toc_5">嵌套对象</h3>

<p>有时，可能会需要将一个 Entity 或普通 Java 对象（POJO）作为数据库逻辑中的一个连贯的整体，即使对象包含多个字段。对于这些情况，可以使用 @Embedded 注解来表示要在表中分解为其子字段的对象。可以像查询其它独立字段一样查询嵌套的字段。</p>

<p>例如：User 类可能包含一个类型为 Address 的字段，表示一个名为 street，city，state 和 postCode 的字段组合。要在表中单独存储组合列，请在 User 类中包含一个用 @Embedded 注解的 Address 字段，如下面的代码片段所示：</p>

<pre><code class="language-java">class Address {
    public String street;
    public String state;
    public String city;

    @ColumnInfo(name = &quot;post_code&quot;)
    public int postCode;
}

@Entity
class User {
    @PrimaryKey
    public int id;

    public String firstName;

    @Embedded
    public Address address;
}
</code></pre>

<p>表示 User 对象的表包含以下名称的列：id，firstName，street，state，city 和 post_code。</p>

<p>如果 Entity 有多个相同类型的嵌套字段，可以通过设置 prefix) 属性保持列唯一。Room 会将提供的值添加到嵌套对象每个列名的开头。</p>

<h2 id="toc_6">数据访问对象（DAO）</h2>

<p>Room 的主要组件是 Dao 类。DAP 以干净的方式抽象访问数据库。</p>

<blockquote>
<p>注：除非在建造者上调用了 allowMainThreadQueries())，否则 Room 不允许在主线程上访问数据库，因为这样可能会长时间锁定 UI。异步查询（返回 LiveData 或 RxJava Flowable 的查询）会规避该规则，因为当需要时他们在后台线程上异步运行。</p>
</blockquote>

<h3 id="toc_7">简便的方法</h3>

<p>使用 DAO 类有多个可代表的简便方法。本文档包含了几个常见的例子。</p>

<h4 id="toc_8">Insert</h4>

<p>当创建一个 DAO 方法并用 @Insert 注解时，Room 会在单独的事务中生成一个将所有参数插入到数据库的实现。</p>

<p>以下代码片段显示了几个示例查询：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    public void insertUsers(User... users);

    @Insert
    public void insertBothUsers(User user1, User user2);

    @Insert
    public void insertUsersAndFriends(User user, List&lt;User&gt; friends);
}
</code></pre>

<p>如果 @Insert 方法只接受到一个参数，它能返回一个 long，表示被插入项的新 rowId。如果参数是一个数组或集合，它应该返回 long[] 或 List。</p>

<p>更多详细信息，请参阅 @Insert 注解的参考文档或 SQLite 文档的 Rowid Tables。</p>

<h4 id="toc_9">Update</h4>

<p>Update 是一个用于在数据库中更新以参数形式给到的一组 Entity 的简便方法。它使用一个查询以与每个 Entity 的主键匹配。以下代码片段演示了如何定义该方法：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Update
    public void updateUsers(User... users);
}
</code></pre>

<p>虽然通常不是必须的，可以让该方法返回一个 int 值，表示数据库中更新的行数。</p>

<h4 id="toc_10">Delete</h4>

<p>Delete 是一个用于从数据库中删除以参数形式给到的一组 Entity 的简便方法。它使用主键来查找要删除的 Entity。以下代码片段演示了如何定义该方法：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Delete
    public void deleteUsers(User... users);
}
</code></pre>

<p>虽然通常不是必须的，可以让该方法返回一个 int 值，表示从数据库中删除的行数。</p>

<h3 id="toc_11">使用 @Query 方法</h3>

<p>@Query 是使用 DAO 类的主要注解。它允许在数据库上执行读/写操作。每个 @Query 方法在编译时验证，所以，如果查询有问题，则会发生编译时错误而不是运行时崩溃。</p>

<p>Room 还会验证查询的返回值，如果返回对象的字段名字和查询响应中的相应列名不匹配，则 Room 会用以下两种方式之一提醒你：</p>

<ul>
<li>如果只有部分字段名匹配会发错警告。</li>
<li>如果没有字段名匹配会给出错误。</li>
</ul>

<h4 id="toc_12">简单查询</h4>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user&quot;)
    public User[] loadAllUsers();
}
</code></pre>

<p>这是一个非常简单的查询会载入所有用户。在编译时，Room 知道它正在查询用户表中的所有列。如果查询包含语法错误或数据库中不存在用户表，Room将会在应用程序编译时显示相应的错误信息。</p>

<h4 id="toc_13">传递参数给查询</h4>

<p>大多数情况下，需要传递参数给查询来执行过滤操作。例如，只显示大于某个年龄的用户。要完成此任务，需要在 Room 注解中使用方法参数，如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user WHERE age &gt; :minAge&quot;)
    public User[] loadAllUsersOlderThan(int minAge);
}
</code></pre>

<p>当在编译时处理该查询时，Room 会匹配绑定参数 :minAge 和方法参数 minAge。Room 使用参数名字执进行匹配。如果没有匹配，在应用程序编译时会发生错误。</p>

<p>可以在查询中传递多个参数或多次引用它们，如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge&quot;)
    public User[] loadAllUsersBetweenAges(int minAge, int maxAge);

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :search &quot;
           + &quot;OR last_name LIKE :search&quot;)
    public List&lt;User&gt; findUserWithName(String search);
}
</code></pre>

<h4 id="toc_14">返回列的子集</h4>

<p>大多数情况下，只需要获取到一个 Entity 的几个字段。例如，UI 可能只显示用户的名字和姓氏，而不是用户的每个详细信息。通过只获取应用程序 UI 中显示的列，可以节省宝贵的资源，并且查询完成更快。</p>

<p>Room 可以返回任何 Java 对象，只要可以将返回列的集合映射到返回的对象中。例如，可以创建如下的 POJO 来获取用户的名字和姓氏：</p>

<pre><code class="language-java">public class NameTuple {
    @ColumnInfo(name=&quot;first_name&quot;)
    public String firstName;

    @ColumnInfo(name=&quot;last_name&quot;)
    public String lastName;
}
</code></pre>

<p>现在，可以在查询方法中使用该 POJO。</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT first_name, last_name FROM user&quot;)
    public List&lt;NameTuple&gt; loadFullName();
}
</code></pre>

<p>Room 知道查询 first_name 列和 last_name 列的返回值，并将这些值映射到 NameTuple 类的字段中。因此，Room 可以生成正确的代码。如果查询返回多余的列，或 NameTuple 类中不存在的列，Room 会显示警告。</p>

<blockquote>
<p>注：这些 POJO 也可以使用 @Embedded 注解。</p>
</blockquote>

<h4 id="toc_15">传递一组参数</h4>

<p>一些查询可能需要传递可变数量的参数，直到运行时才知道参数的具体数量。例如，你可能想获取某些区域下所有用户的相关信息。当参数为一个集合时 Room 就会明白，并且会在运行时基于所提供参数的数量展开该集合。</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;)
    public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);
}
</code></pre>

<h4 id="toc_16">可观察的查询</h4>

<p>在执行查询时，总会希望应用程序 UI 在数据更改时自动更新。要实现这个，需要在查询方法的描述中使用类型为 LiveData 的返回值。在数据库更新后，Room 会生成所有必须的代码来更新 LiveData。</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;)
    public LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);
}
</code></pre>

<h4 id="toc_17">RxJava</h4>

<p>Room 还可以从定义的查询返回 RxJava2 的 Publisher 和 Flowable 对象。要使用该功能，需要将 Room 组中的 android.arch.persistence.room:rxjava2 组件添加到构建 Gradle 依赖中。然后，可以返回 RxJava2 中定义的类型对象，如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * from user where id = :id LIMIT 1&quot;)
    public Flowable&lt;User&gt; loadUserById(int id);
}
</code></pre>

<h4 id="toc_18">直接访问 Cursor</h4>

<p>如果应用程序的逻辑需要直接访问返回行，可以从查询返回一个 Cursor 对象。如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user WHERE age &gt; :minAge LIMIT 5&quot;)
    public Cursor loadRawUsersOlderThan(int minAge);
}
</code></pre>

<blockquote>
<p>警告：不鼓励使用 Cursor API，因为它不能保证行是否存在或行包含什么值。仅当你已经有存在 Cursor 的代码并且不好重构时才使用此功能。</p>
</blockquote>

<h4 id="toc_19">多表查询</h4>

<p>某些查询可能需要访问多个表来计算结果。Room 允许编写任何查询，所以也可以连接表。另外，如果响应是一个可观察类型，如：Flowable 或 LiveData，Room 观察查询中引用的所有表。</p>

<p>以下代码片段显示了如何执行表连接以整合借阅书的用户表和当前借出的图书表之间的信息：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM book &quot;
           + &quot;INNER JOIN loan ON loan.book_id = book.id &quot;
           + &quot;INNER JOIN user ON user.id = loan.user_id &quot;
           + &quot;WHERE user.name LIKE :userName&quot;)
   public List&lt;Book&gt; findBooksBorrowedByNameSync(String userName);
}
</code></pre>

<p>这些查询也可以返回 POJO，例如，可以编写一个加载用户及其宠物名称的查询，如下所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
   @Query(&quot;SELECT user.name AS userName, pet.name AS petName &quot;
          + &quot;FROM user, pet &quot;
          + &quot;WHERE user.id = pet.user_id&quot;)
   public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames();

   // You can also define this class in a separate file, as long as you add the
   // &quot;public&quot; access modifier.
   static class UserPet {
       public String userName;
       public String petName;
   }
}
</code></pre>

<h3 id="toc_20">使用类型转换器</h3>

<p>Room 提供内置支持基本数据类型及其封装类型。然而，有时候需要使用自定义类型，并将其值存储在数据库中单独的列里。要添加自定义类型的支持，需要提供一个 TypeConverter 将自定义类转换为 Room 可以持久化的已知类型。</p>

<p>例如：如果想要持久化 Date 实例，你可以编写如下的 TypeConverter 在数据库中存储等效的 Unix 时间戳。</p>

<pre><code class="language-java">public class Converters {
    @TypeConverter
    public static Date fromTimestamp(Long value) {
        return value == null ? null : new Date(value);
    }

    @TypeConverter
    public static Long dateToTimestamp(Date date) {
        return date == null ? null : date.getTime();
    }
}
</code></pre>

<p>上面的例子定义了两个方法，一个将 Date 对象转换为 [Long] 对象，另一个执行逆向转换，将 [Long] 转换为 Date。因为 Room 已经知道如何持久化 [Long] 对象，所以它可以使用该转换器来持久化 Date 类型的值。</p>

<p>下面，给 AppDatabase 添加 [@TypeConverter] 注解，以便 Room 可以在 AppDatabase 对每个 Entity 和 DAO 使用定义的转换器。</p>

<p>AppDatabase.java</p>

<pre><code class="language-java">@Database(entities = {User.java}, version = 1)
@TypeConverters({Converter.class})
public abstract class AppDatabase extends RoomDatabase {
    public abstract UserDao userDao();
}
</code></pre>

<p>使用这些转换器，可以在其它查询中像使用基本数据类型一样使用自定义类型。</p>

<p>User.java</p>

<pre><code class="language-java">@Entity
public class User {
    ...
    private Date birthday;
}
</code></pre>

<p>UserDao.java</p>

<pre><code class="language-java">@Dao
public interface UserDao {
    ...
    @Query(&quot;SELECT * FROM user WHERE birthday BETWEEN :from AND :to&quot;)
    List&lt;User&gt; findUsersBornBetweenDates(Date from, Date to);
}
</code></pre>

<p>还可以给 @Typeconverters 限制不同的作用域，包括单个 Entity，DAO 和 DAO 方法，更多详细信息，请参阅 @TypeConverters 注解的参考文档。</p>

<h3 id="toc_21">数据库迁移</h3>

<p>当给应用程序添加或修改功能时，需要修改 Entity 类来反映这些修改。当用户更新到应用程序的最新版本时，你不希望他们丢失现有数据，特别是如果无法从远程服务端恢复数据时。</p>

<p>Room 允许以编写 Migration 类的方式保留用户数据。每个 Migration 类都指定一个 startVersion 和 endVersion。在运行时，Room 允许每个 Migration 的 migrate()) 方法，使用正确的顺序将数据库迁移到最新版本。</p>

<blockquote>
<p>警告：如果没有提供必要的迁移，则会重建数据库，这意味着将会失去数据库中所有的数据。</p>
</blockquote>

<pre><code class="language-java">Room.databaseBuilder(getApplicationContext(), MyDb.class, &quot;database-name&quot;)
        .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();

static final Migration MIGRATION_1_2 = new Migration(1, 2) {
    @Override
    public void migrate(SupportSQLiteDatabase database) {
        database.execSQL(&quot;CREATE TABLE `Fruit` (`id` INTEGER, &quot;
                + &quot;`name` TEXT, PRIMARY KEY(`id`))&quot;);
    }
};

static final Migration MIGRATION_2_3 = new Migration(2, 3) {
    @Override
    public void migrate(SupportSQLiteDatabase database) {
        database.execSQL(&quot;ALTER TABLE Book &quot;
                + &quot; ADD COLUMN pub_year INTEGER&quot;);
    }
};
</code></pre>

<p>迁移过程结束后，Room验证数据库架构以确保迁移执行正确。如果 Room 发现问题，将会抛出含有不匹配信息的异常。</p>

<h4 id="toc_22">测试迁移</h4>

<p>迁移不是简单的写入，并且无法正确写入它们可能会导致应用程序崩溃。为了保持应用的稳定性，应该实现测试迁移。Room 提供了一个测试 Maven 组件来帮助进行该测试过程。然而，为了使该组件正常工作，需要导出数据库的结构</p>

<h4 id="toc_23">导出架构</h4>

<p>汇编后，Room 将数据库的架构信息导出为 JSON 文件。要导出架构，需要在 build.gradle 文件中设置 room.schemaLocation 注解数据处理属性，如以下代码片段所示：</p>

<p>build.gradle</p>

<pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [&quot;room.schemaLocation&quot;:
                             &quot;$projectDir/schemas&quot;.toString()]
            }
        }
    }
}
</code></pre>

<p>应该将导出的 JSON 文件（其表示数据库架构的历史记录）存储在版本控制系统中，因为它允许 Room 创建旧版本的数据库以进行测试。</p>

<p>要测试这些迁移，请将来自 Room 的 android.arch.persistence.room:testing Maven 组件添加到测试依赖中，并将架构文件的位置添加为资产文件，如以下代码片段所示：</p>

<p>build.gradle</p>

<pre><code class="language-java">android {
    ...
    sourceSets {
        androidTest.assets.srcDirs += files(&quot;$projectDir/schemas&quot;.toString())
    }
}
</code></pre>

<p>测试包提供了一个 MigrationTestHelper 类，可以读取这些架构文件。它也是一个 Junit4 的 TestRule 类，所以它可以管理创建的数据库。</p>

<p>以下代码片段显示了迁移测试的例子：</p>

<pre><code class="language-java">@RunWith(AndroidJUnit4.class)
public class MigrationTest {
    private static final String TEST_DB = &quot;migration-test&quot;;

    @Rule
    public MigrationTestHelper helper;

    public MigrationTest() {
        helper = new MigrationTestHelper(InstrumentationRegistry.getContext(),
                MigrationDb.class.getCanonicalName(),
                new FrameworkSQLiteOpenHelperFactory());
    }

    @Test
    public void migrate1To2() throws IOException {
        SupportSQLiteDatabase db = helper.createDatabase(TEST_DB, 1);

        // db 的架构版本是 1. 使用 SQL 查询插入一些数据。
        // You cannot use DAO classes because they expect the latest schema.
        db.execSQL(...);

        // 准备下一个版本。
        db.close();

        // 使用 version2 重新打开数据库
        // 并且提供 MIGRATION_1_2 作为迁移过程。
        db = helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2);

        // MigrationTestHelper 自动验证架构的更改，
        // 但是需要验证数据是否迁移正确。
    }
}
</code></pre>

<h3 id="toc_24">测试数据库</h3>

<p>当应用程序运行测试时，如果不测试数据库本身则没有必要创建完整的数据库。Room 允许在测试中轻松的模拟数据访问层。这个过程是可能的，因为 DAO 不会泄漏数据库的任何细节。当测试应用程序的其余部分时，应该创建 DAO 类的模拟或假的实例。</p>

<p>有两种方式可以测试数据库：</p>

<ul>
<li>在开发主机上。</li>
<li>在 Android 设备上。</li>
</ul>

<h4 id="toc_25">在主机上测试</h4>

<p>Room 使用 SQLite 支持库，它提供与 Android Framework 类中一致的接口。该支持库允许传递支持库的自定义实现来测试数据库查询。</p>

<p>即使此设置可以让测试快速运行，但是不推荐使用，因为你的设备上（和用户设备上）运行的 SQLite 版本和你主机上运行的版本不一致。</p>

<h4 id="toc_26">在 Android 设备上测试</h4>

<p>用于测试数据库实现的推荐方式是编写在 Android 设备上运行的 Junit 测试。因为这些测试不需要创建 activity，所以它们应该比 UI 测试执行的更快。</p>

<p>设置测试时，应该创建数据库的内存版本，使测试更加封闭，如以下示例所示：</p>

<pre><code class="language-java">@RunWith(AndroidJUnit4.class)
public class SimpleEntityReadWriteTest {
    private UserDao mUserDao;
    private TestDatabase mDb;

    @Before
    public void createDb() {
        Context context = InstrumentationRegistry.getTargetContext();
        mDb = Room.inMemoryDatabaseBuilder(context, TestDatabase.class).build();
        mUserDao = mDb.getUserDao();
    }

    @After
    public void closeDb() throws IOException {
        mDb.close();
    }

    @Test
    public void writeUserAndReadInList() throws Exception {
        User user = TestUtil.createUser(3);
        user.setName(&quot;george&quot;);
        mUserDao.insert(user);
        List&lt;User&gt; byName = mUserDao.findUsersByName(&quot;george&quot;);
        assertThat(byName.get(0), equalTo(user));
    }
}

</code></pre>

<h2 id="toc_27">附录：Entity 之间无对象引用</h2>

<p>将数据库中的关系映射到相应的对象模型是一种常见的做法，并且在服务端可以很好的运行，因为在访问时惰性加载文件是高效的。</p>

<p>然而，在客户端，惰性加载是不可能的，因为有可能发生在 UI 线程上，并且在 UI 线程中查询磁盘上的信息会产生显著的性能问题。 UI 线程大约有 16ms 来计算和绘制 activity 的布局更新，所以，即使一个查询任务只需要 5ms，应用程序仍然可能没有时间绘制帧，造成显著的破坏。更糟糕的时，如果并行运行单独的事务或设备忙于其它磁盘繁重的任务，则查询可能需要更多的时间完成。但是，如果不使用惰性加载，应用程序将会获取比所需更多的数据，造成内存消耗问题。</p>

<p>ORM 通常将此决定留给开发者，以便他们可以根据应用程序的情况做最好的处理。不幸的是，开发者通常的处理结果是在应用程序和 UI 之间共享模型。如果 UI 更新超时，会产生难以预料和调试的问题。</p>

<p>例如：让 UI Book 对象的列表，并且没本书都有一个 Author 对象。最初可能设计使用惰性加载查询，如 Book 实例使用 getAuthor() 方法返回作者。getAuthor() 的第一次调用会调用查询数据库。一段时间后，还需要在应用程序的 UI 显示作者名字。可以轻松的添加方法调用，如以下代码片段所示：</p>

<p>authorNameTextView.setText(user.getAuthor().getName());<br/>
然而，这个看似无辜的变化造成在主线程上查询 Author 表。</p>

<p>如果急需查询作者信息，当不在需要数据时，很难改变数据的加载方式，例如，应用程序的 UI 不再需要显示有关特定作者的信息。因此，当数据不在显示时应用程序必须继续加载数据。如果 Author 类引用其它的表（如，有 getBooks() 方法）情况会更糟。</p>

<p>基于这些原因，Room 禁止 Entity 之间的对象引用。相反，必须明确的请求应用程序需要的数据。</p>

<blockquote>
<p>转自 <a href="https://juejin.im/post/593df980ac502e006c049607">https://juejin.im/post/593df980ac502e006c049607</a></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
