<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Xu Yushi's Blog]]></title>
  <link href="xuyushi.github.io/atom.xml" rel="self"/>
  <link href="xuyushi.github.io/"/>
  <updated>2018-07-15T20:28:52+08:00</updated>
  <id>xuyushi.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[用户调研]]></title>
    <link href="xuyushi.github.io/15316240502263.html"/>
    <updated>2018-07-15T11:07:30+08:00</updated>
    <id>xuyushi.github.io/15316240502263.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">用户调研全过程</h2>

<ol>
<li>明确背景和目的</li>
<li>选择目标用户</li>
<li>分析用户和问题</li>
<li>准备调研内容</li>
<li>现场调研</li>
<li>总结报告</li>
</ol>

<span id="more"></span><!-- more -->

<h3 id="toc_1">用户调研全过程</h3>

<ul>
<li>背景：什么情况下发起的调研?是否必须通过调研来解决？</li>
<li>目的：通过用户调研希望得到的结果是什么？</li>
</ul>

<table>
<thead>
<tr>
<th>bad</th>
<th>原因</th>
<th>good</th>
</tr>
</thead>

<tbody>
<tr>
<td>对本站用户 做针对性调研</td>
<td>目的不明确</td>
<td>* 在支付阶段用户流失原因调研分析 * 用户在不同在线学习平台学习过程调研</td>
</tr>
<tr>
<td>做北京地区女性用户使用情况调研</td>
<td>背景不明确</td>
<td>北京地区女性下单转化率很高，调研其在平台购买路径分析</td>
</tr>
<tr>
<td>O2O 行业用户使用习惯调研</td>
<td>大而全</td>
<td>* 京东到家超市业务白领女性消费习惯调研 </td>
</tr>
</tbody>
</table>

<h3 id="toc_2">选择目标用户</h3>

<ul>
<li>典型用户：通过简单的用户画像，找出典型用户</li>
<li>目标用户：时间、地点、配合程度</li>
<li>邀约用户：直接说明目的，并告知可能发生的情况</li>
<li>用户数量：不宜扫网式，一般5-10个</li>
</ul>

<h3 id="toc_3">猜测用户问题 设定题目</h3>

<ul>
<li>用户可能的问题：用户的使用行为表现</li>
<li>可能的解决方案：猜测解决用户问题的手段</li>
<li>确定访问提纲：聚焦且开放的问题</li>
<li>问题数量：线上10-20，线下5-10 展开</li>
</ul>

<h3 id="toc_4">准备调研内容</h3>

<ul>
<li>本品已知问题：用户操作习惯、消费习惯和过程，原因</li>
<li>本品未知问题：用户的痛点是什么？哪些操作用户很烦，用户愿意掏钱做什么？</li>
<li>竞品已知问题：用户直观感知两者区别，竞品使用差异</li>
<li>竞品已知问题：如果从竞品移入，用户放弃理由。从本品移到竞品，原因？ </li>
</ul>

<p><img src="media/15316240502263/15316441642224.jpg" alt="" style="width:737px;"/></p>

<h3 id="toc_5">现场调研</h3>

<ul>
<li>了解用户使用的过程：最好观察用户的行为</li>
<li>提问：对关键行为、预设问题进行提问</li>
<li>反馈：对有效的信息反馈给用户，并深究</li>
</ul>

<h3 id="toc_6">调研报告</h3>

<ul>
<li>单个用户：记录单用户调研情况</li>
<li>整体情况：汇总用户调研的过程和结论</li>
<li>行动计划：分享并提出行动计划</li>
</ul>

<blockquote>
<p>误区</p>

<ul>
<li>为了调研而调研，需要 带着目的</li>
<li>问用户有什么需求</li>
<li>试图说服用户</li>
<li>求全求量</li>
<li>依赖调查问卷</li>
</ul>
</blockquote>

<h2 id="toc_7">设计改善措施</h2>

<p><img src="media/15316240502263/15316452423278.jpg" alt=""/></p>

<ul>
<li>认知缺口：产品经理不知道用户想要的是什么。若出现了认知缺口，则首先是让产品经理清楚知道用户流失的真正原因。</li>
<li>执行缺口：产品经理知道用户想要什么，但实际做出来的产品与设计中的不一致。若出现了执行缺口，则要了解具体哪个执行步骤出现问题，是资源的欠缺还是技术难以实现。</li>
<li>传递缺口：产品的宣传和指引不能让用户对产品真正认知了解若出现了传递缺口，则要了解用户现在的感知是怎么样的，在哪些宣传和指引上出现了问题。</li>
<li>流失缺口：用户体验到的产品和期望的不一样。</li>
</ul>

<h1 id="toc_8">拓展</h1>

<blockquote>
<p><a href="http://cdc.tencent.com/2013/07/03/%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E5%8E%9F%E5%9B%A0%E8%B0%83%E7%A0%94%E5%9B%9B%E6%AD%A5%E7%BB%8F/">用户流失原因调研四步经</a> <br/>
<a href="https://www.zhihu.com/question/20345655/answer/19110604">如何去做用户访谈和用户调研</a><br/>
<a href="http://blog.sanjieke.cn/article/144538.html">如何做好用户调研</a><br/>
<a href="http://www.yunzhan365.com/59771541.html">如何做一次完美的用户调研</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用户反馈发现问题]]></title>
    <link href="xuyushi.github.io/15316220023386.html"/>
    <updated>2018-07-15T10:33:22+08:00</updated>
    <id>xuyushi.github.io/15316220023386.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">关注什么问题</h2>

<ul>
<li>自身产品的问题</li>
<li>竞品的问题</li>
<li>可能的机会点</li>
</ul>

<h2 id="toc_1">渠道</h2>

<h3 id="toc_2">渠道类型</h3>

<ul>
<li>公开渠道：apple store，微博，贴吧，第三方应用商城</li>
<li>半公开渠道：微信，朋友圈，用户评价</li>
<li>内部渠道：用户投诉，电话录音
<span id="more"></span><!-- more -->
### 处理策略</li>
<li>公开渠道：勤搜索、关键词订阅、自动化监控</li>
<li>半公开渠道：定期搜索关键字、定期分析用户评论<br/>
### 内部渠道</li>
<li>整合内部用户反馈渠道</li>
<li>定期与一线同事沟通</li>
<li>到一线去</li>
</ul>

<h2 id="toc_3">主流应用商店与常用工具</h2>

<ul>
<li>iOS：AppStore</li>
<li>Android：360手机助手、安卓市场、百度手机助手 、小米/华为、oppo 等商城、豌豆荚</li>
<li>常用工具：AppAnnie、应用雷达、ASO114、七麦</li>
</ul>

<h3 id="toc_4">应用商城监控</h3>

<ul>
<li>低分差评：重点看1-3 分</li>
<li>有效评论：重点看有实际描述的评论</li>
<li>异常行为：比如水军刷榜、恶意评价</li>
<li>竞品变化：监控竞对的应用变化</li>
</ul>

<h2 id="toc_5">主流社交平台与常用工具</h2>

<ul>
<li>主流平台：微博、贴吧、知乎、雪球等</li>
<li>工具：关键字、收藏夹、微博企业版、百度、google</li>
</ul>

<h2 id="toc_6">用户点评看什么</h2>

<ul>
<li>差评：为什么差评？原因、现象是什么</li>
<li>描述：重点看有实际描述的评论</li>
<li>异常行为：刷榜、恶意评价</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[abtest 数据分析]]></title>
    <link href="xuyushi.github.io/15299133098726.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133098726.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">背景</h1>

<p>在设计A/B测试时，总有一个无法避免的问题：实验数据的结果是样本数据的波动还是真实的数据提升？答案取决于数据的提升和样本量，需要使用数理统计的方法判断实验结果的科学性。</p>

<span id="more"></span><!-- more -->

<h1 id="toc_1">基础概念</h1>

<p>由于数据分析需要比较多的概念，在本节统一做介绍 <strong>（有基础的可略过本节）</strong></p>

<h2 id="toc_2">总体与样本</h2>

<p>总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。</p>

<p>实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。</p>

<p>抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。</p>

<p>抽样最重要的一点就是要尽量保证样本具有<strong>代表性</strong>，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。</p>

<h2 id="toc_3">统计量及其分布</h2>

<p>在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。</p>

<h3 id="toc_4">正态分布</h3>

<p>正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 x=μ 对称的钟形曲线，方差 σ2 决定了曲线中峰的陡峭程度。其中，μ 是正态分布的数学期望，\(σ^2\)是正态分布的方差，正态分布记为 X∼N(μ,\(σ^2\))。μ=0 且 \(σ^2\)=1 时的正态分布称为标准正态分布，记为 X∼N(0,1)。</p>

<p><img src="media/15299133098726/15269536482648.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_5">t分布</h3>

<p>通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当<strong>样本量不足的时候，误差较大，所以需要应用t分布来计算</strong>。</p>

<p>分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。</p>

<p><img src="media/15299133098726/15269537711881.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_6">参数估计</h2>

<p>根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。</p>

<p>参数估计的形式有两种：</p>

<ul>
<li>点估计：根据样本估计参数的近似值</li>
<li>区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高</li>
</ul>

<h3 id="toc_7">置信区间</h3>

<p>置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。</p>

<p><img src="media/15299133098726/15269540524945.png" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_8">假设检验</h2>

<p>假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。</p>

<p>假设检验运用了反证法，其一般流程是</p>

<ul>
<li>提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能</li>
<li>选择检验方法和检验统计量</li>
<li>在原假设下推导统计量的分布，比如正态分布或t分布等</li>
<li>选择显著性水平</li>
<li>计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。</li>
</ul>

<h3 id="toc_9">显著性检验</h3>

<p>拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。</p>

<p>不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 α，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 β。</p>

<p>由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 α 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验</p>

<h3 id="toc_10">双侧检验，单侧检验</h3>

<p>实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：</p>

<ul>
<li>双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端</li>
<li>单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧</li>
</ul>

<p><img src="media/15299133098726/15269547975976.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_11">检验方法</h3>

<p>上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。</p>

<p>比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。</p>

<p>总体方差已知：Z检验<br/>
总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差<br/>
总体方差未知，样本量小于30：t检验</p>

<h3 id="toc_12">Z检验</h3>

<p>todo</p>

<h3 id="toc_13">t检验</h3>

<p>todo</p>

<h3 id="toc_14">p-value</h3>

<p>在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。</p>

<p><img src="media/15299133098726/15269558290250.png" alt=""/></p>

<h1 id="toc_15">ABtest中的假设检验</h1>

<blockquote>
<p>In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]<br/>
A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.<br/>
– wikipedia</p>
</blockquote>

<p>即，A/B 测试是一种两样本的随机对照试验，<strong>在统计学上是一种两样本的假设检验</strong>。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异。<strong>从 A/B 测试的试验原理来看，它是统计学上假设检验(显著性检验)的一种形式。</strong></p>

<!--假设检验一般有四个步骤，我们以两独立样本比率检验(two independent sample evaluation)作为案例。假设微信想通过改变注册流程来提高新用户注册成功的比率。

###第一步：提出假设

一般而言有两种假设，分别是原假设(null hypothesis)和备择假设(alternative hypothesis)。原假设一般比较消极，即新注册流程与旧流程并无不同。相对应的备择假设为新注册流程与旧流程有差别。设立两种假设的逻辑是，除非在数据明显的反对原假设时，我们一般不拒绝原假设，也就是默认原假设为真。而这种“保护”会通过“容错率”来体现。

### 第二步：提取随机样本
在设置好两种注册流程之后，实验将随机选取一部分新用户提供新的流程，而剩下的一部分仍然使用老的流程。值得注意的是样本的选取一定要是随机的(random)，而且每个用户必须持续的只接收到一种流程(persistent manner)。随机分配(random split)并不要求平均分配。

### 第三步：计算检验统计量
在收集完数据后，我们需要计算检验统计量(test statistics)。检验统计量是一个用来衡量数据是否支持原假设的统计量。在这个案例中，检验统计量是

$$Z=\frac{p_t-p_c}{\sqrt{(\frac{p_t(1-p_t)}{n_t}+\frac{p_c(1-p_c)}{n_c})}}$$

其中p_t和p_c分别代表新流程和旧流程的注册成功率，n_t和n_c分别代表两者的样本数量，p_t p_c代表结合的注册成功率。直观上而言，检验统计量是取出两者成功率的差值，并通过标准差进行了标准化。如果这个检验统计量绝对值越大，就代表数据越反对原假设。

### 第四步：决定是否拒绝原假设
此时我们需要通过检验统计量绝对值的大小来判断是否拒绝原假设。在原假设下，检验统计量应该服从某种标准的分布。例如在微信的例子中，检验统计量在原假设情况下近似服从标准正态分布。当检验统计量的数值极端到在原假设时，它和更极端的情况，发生的概率非常小时，我们就说样本明显的反对原假设，因此拒绝。我们也用p值来衡量样本是否支持原假设。

-->

<p>随机将测试用户群分为2部分，用户群1使用A方案，用户群2使用B方案，经过一定测试时间后，根据收集到的两方案样本观测数据，根据显著性检验结果选取最好方案。</p>

<p>为了下文方便说明，我们不妨设A方案为参考方案（或旧方案），B方案为实验方案（或新方案）。以下我们以某流程转化率为例。</p>

<h3 id="toc_16">选取观测指标</h3>

<p>使用A方案的人数\(N_A\)，使用B方案的人数\(N_B\)，通常情况下\(N=N_A=N_B\)；</p>

<p>由样本计算出A方案转化率为\(P_a\)，B方案的转化率 为\(P_b\)</p>

<p>总体A的分布：\(A～B(N,P_a)\)，总体B的分布：\(A～B(N,P_b)\)；</p>

<p>根据中心极限定理可知，\(P_a\)和\(P_b\)均可认为近似服从正态分布：\[A～N(N,P_a(1-P_a)/N_a)\] \[B～N(N,P_b(1-P_b)/N_b)\]</p>

<p>所以根据正态分布的性质 \[X=P_b - P_a = N( P_b - P_a, (\frac{P_a(1-P_a)}{N_a}) + (\frac{P_b(1-P_b)}{N_b}))\]</p>

<h3 id="toc_17">建立原假设和备择假设</h3>

<p>由于我们的期望结果是B方案的转化率高于A 方案的转化率，所以原假设和备择假设如下：<br/>
\[H_0: X=P-b - P_a &lt;=0\]<br/>
\[H_0: X=P-b - P_a &gt;0\]</p>

<p>构建检验统计量<br/>
 \[Z=P_b - P_a = N(P_b - P_a, (\frac{P_a(1-P_a)}{N_a}) + (\frac{P_b(1-P_b)}{N_b})  )\]</p>

<h3 id="toc_18">显著性检验结论</h3>

<p>给定显著性水平为。当时\(Z&gt;Z_α\)，拒绝原假设，认为B方案的转化率高于A 方案，建议可以进行推广；当时\(Z&lt;=Z_α\)不能拒绝原假设，即认为B方案的转化率不高于A 方案，建议暂不建议进行推广。</p>

<blockquote>
<p>一般采用 α=0.05，置信度95%，则Z=1.644854</p>
</blockquote>

<!--# 参考
> https://zhuanlan.zhihu.com/p/21731601
> https://blog.csdn.net/buracag_mc/article/details/74905483
> https://www.zhihu.com/question/23680352  显著水平和pvalue 关系
> https://zhuanlan.zhihu.com/p/33415389 显著性样本？
> http://solnotes.com/2016/10/08/simple-stats-in-abtesting/
> https://zhuanlan.zhihu.com/p/21731601
> https://zhuanlan.zhihu.com/p/21829614-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABtest 平台框架]]></title>
    <link href="xuyushi.github.io/15299133098793.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133098793.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">背景</h2>

<p>目前输入法内部功能迭代，主要是通过灰度和小渠道的策略，对比新版本和旧版本的数据指标。存在着以下问题</p>

<ol>
<li>数据可能收到渠道、周期波动等因素的干扰</li>
<li>缺少聚合对比数据 指标的平台，不方便做决策</li>
<li>同时上线多个feature 对指标可能互相影响</li>
<li>新功能存在风险</li>
</ol>

<span id="more"></span><!-- more -->

<h2 id="toc_1">ABtest</h2>

<p>使用abtest平台能解决上述问题，并且具有以下优势</p>

<ol>
<li>数据共享：不限于端上的需求实验，服务端/前端页/商业化 等都能通过abtest 平台做决策</li>
<li>实验隔离：使用多层分流结构，可以同时上线多个AB实验，每个实验之间隔离，数据指标互不影响</li>
<li>风险可控：ab 实验采用动态下发机制，随时控制功能上下线</li>
<li>指标聚合：核心指标、分类指标数据聚合，易于得出结论，方便做决策</li>
<li>扩展空间：后续可扩展为消费者BG 的共享平台</li>
</ol>

<h2 id="toc_2">A/B测试的三大特性：先验、并行、科学</h2>

<ul>
<li>先验性： A/B测试结果属于预测型结论，与“后验”的归纳性结论差别巨大。后验的方式是先将版本发布，再通过数据验证效果，而A/B 测试用很少的样本量来推断新版本在全流量下的效果。</li>
<li>并行性： A/B测试将两个或以上的方案同时在线试验，保证每个版本所处环境的一致性，同时节省了验证的时间，无需在验证完一个版本之后再测试另一个。</li>
<li>科学性： A/B 测试的正确做法是将相似特征的用户均匀的分配到试验组中，确保每个组别的用户特征的相似性，从而避免辛普森悖论。</li>
</ul>

<p>A/B测试试验是产生用户阻力的地方，也是增长前进的核心动力。</p>

<h2 id="toc_3">实验流程</h2>

<p><img src="media/15299133098793/15264426763763.png" alt=""/></p>

<h2 id="toc_4">方案</h2>

<p>采用服务端多层分流方案，整体架构包括以下几个部分</p>

<p><img src="media/15299133098793/15262797128472.png" alt=""/></p>

<ul>
<li>AB 实验配置平台：产品经理/研发平时配置新实验</li>
<li>分流服务：读取 AB 实验配置平台的配置数据，执行具体的分流算法</li>
<li>集成方应用：客户端通过请求分流服务来获取具体加载哪些实验，上报实验分组和埋点</li>
<li>数据分析：分析打点数据，通过一定的数据分析算法，得出能够判断版本优劣的报表数据</li>
<li>AB实验展示平台：图标方式展示处理过的数据，方便人员做决策</li>
</ul>

<h1 id="toc_5">ABtest sdk 需求文档见附件</h1>

<!--## 人员配置
* 服务端：1 名（分流策略，处理端上上报数据）
* 大数据：1 名（数据处理/生成报表数据）
* 数据分析师：1 名（abtest 数据指标，数据处理策略，实验指标评判标准）
* 产品经理：1 名 （ab 配置平台，ab 数据平台，端上策略，分流策略，项目管理）
* Android ：1 名（abtest sdk，输入法接入，数据上报）
* UI：1 名（内部平台页面设计）
* QA: 1名 （服务端前段页面，分流策略，客户端逻辑测试）
> 人员暂定，具体时间节点按照排期决定
-->

<!--## 时间节点


| 时间  | 规划 | 备注  |
| --- | --- | --- |
| 05/17 - 05/25 | 产品细则制定，abtest 指标拟定 |  |
| 05/28 - 05/29 | 需求评审，UI 评估，技术选型，人员排期制定项目计划表 |  |
| 05/30 - 06/08 | 开发阶段 |  |
| 06/09 - 06/14 | 测试，bug 修复 |  |
| 06/15 - 06/18 | 灰度上线 |  |


> 时间为预估，具体排期待人力，需求明确后确定
-->

<!--
## 通用参数
1. 版本号
2. os version
3. 地域
4. 渠道
5. platform
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在离开北京的前夕]]></title>
    <link href="xuyushi.github.io/15299133099414.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099414.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15299133099414/15249794589499.png" alt="15249794589499"/></p>

<span id="more"></span><!-- more -->

<h1 id="toc_0">git init</h1>

<p>还记得15年那个夏天， 独自一人拖着个行李箱，连北京城的样子都还没见到，一路坐着地铁来到了五环外的一个城中村安顿了一个窝。一个人来到一座城市，定有一个理由。我当时的理由很简单 ——赚钱。那时的北京对我来说是一座完全陌生的城市，甚至陌生到没有一个朋友，一个同学。这一年学会了享受一个人时光，一个人看电影，一个人吃火锅。无拘无束，自由自在。</p>

<h1 id="toc_1">git add .</h1>

<p>在学校画pcb写单片机的我，确实没想过日后能从事互联网的工作。非常庆幸能在美团遇到这样一个机遇，还遇到一群这么好的同事。觉得每一天都很充实，海绵一样汲取着知识。渐渐的在这个城市有了朋友，可以和朋友一起跑步，狼人杀，撸串。。<br/>
北京是一个包容性很强的城市，无论你是什么妖魔鬼怪，你总能找到你的栖息地。<br/>
如果说美团是梦想起飞的地方，那么头条就像是一把火，用激情点燃梦想。 来头条一年多收获的很多，也很享受何和一群牛逼的同事做着改变世界的事情。</p>

<p><img src="media/15299133099414/15250202451953.png" alt="15250202451953" style="width:1100px;"/></p>

<h1 id="toc_2">git commit</h1>

<p>不得不承认北京是我生命的重要塑造者。至少我在毕业时，没想到在北京待着这三年能改变这么多。三年前的我很喜欢“天道酬勤”这个词？ 现在看来有些鸡汤满满，现在更喜欢“低调 务实 自驱 反思”。虽然我还是有点小懒，虽然不那么聪明，但是相比三年前的我很喜欢现在的我。有时也会想想，如果当年做的决定不是来北京，那我现在会是一个什么样的自己。</p>

<h1 id="toc_3">git checkout -b new_branch</h1>

<p>从来没想过在北京扎根，这是一个不属于我的城市，昂贵的房价并负担不起，户口也看不到希望，离开北京对于我来说只是时间问题。但离开了北京确实也舍弃了很多东西，也不清楚这次离开北京的选择是不是正确。</p>

<p>人一生有太多的选择，可能当年某个午后很小的选择，未来的一切都会变的不一样，如果当年没有读研？如果当年不选择来北京？如果当面选择继续做硬件？如果没有来头条？如果没有遇到她？之前每次回首自己做的重大决定，都很庆幸自己选择了正确的路。但细想下，也可能每条路的结果都不差看你怎么对待自己的选择，每条路都不是一帆风顺的，是抱怨后悔当初的决定？还是脚踏实地的向前？ 也可能这过程更为重要吧。同时也做了最坏的打算，真的觉得离开北京不适合，大不了再 <code>git checkout -b</code>一个继续撸咯。</p>

<p>还有不到24小时离开北京，没有太多的遗憾，只是有些不舍，舍不得的不是北京这座城，而是我的朋友们。愿我们未来一切都好。</p>

<blockquote class="blockquote-center">北京的小伙伴们，再见了，有缘的话。</blockquote>

<p><img src="media/15299133099414/15249794854372.png" alt="15249794854372" style="width:1100px;"/></p>

<p><img src="media/15299133099414/15250146162808.png" alt="15250146162808" style="width:1100px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins 平台搭建]]></title>
    <link href="xuyushi.github.io/15299133099249.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099249.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<h3 id="toc_1">java 环境搭建</h3>

<pre><code class="language-bash">java -version
</code></pre>

<p>如果显示Java版本号，说明已经正确安装，如果显示没有该命令，需要安装Java：<br/>
<span id="more"></span><!-- more --></p>

<h4 id="toc_2">mac</h4>

<pre><code class="language-bash">brew cask install java
</code></pre>

<h4 id="toc_3">linux</h4>

<pre><code class="language-bash">sudo yum install java
</code></pre>

<p>该命令如果检测到Java不存在可以直接安装Java,如果已存在则可以升级Java</p>

<p>环境配置 vim /etc/profile 追加</p>

<pre><code class="language-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64/
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
</code></pre>

<h3 id="toc_4">jenkins 安装</h3>

<h4 id="toc_5">mac</h4>

<pre><code class="language-bash">brew install jenkins 
</code></pre>

<h4 id="toc_6">Linux</h4>

<pre><code class="language-bash">sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo
sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
</code></pre>

<p>添加完成之后直接使用yum命令安装Jenkins:<br/>
<code>yum install jenkins<br/>
</code></p>

<h2 id="toc_7">启动</h2>

<p>命令行直接启动</p>

<p>mac </p>

<pre><code class="language-bash">Jenkins
</code></pre>

<p>linux </p>

<pre><code class="language-bash">sudo service jenkins start
Starting Jenkins                                           [  OK  ]
</code></pre>

<blockquote>
<p>默认端口 8080 可能冲突 需要修改  <code>vim /etc/sysconfig/jenkins</code></p>
</blockquote>

<h2 id="toc_8">环境配置</h2>

<blockquote>
<p>admin 密码 在 sudo cat /var/lib/jenkins/secrets/initialAdminPassword</p>
</blockquote>

<p>启动完毕后，打开浏览器，在地址栏中输入localhost:8080</p>

<p>系统管理 -&gt; 系统设置 ，填写Android 环境变量</p>

<p><img src="media/15299133099249/15240201058052.jpg" alt=""/></p>

<h1 id="toc_9">插件管理</h1>

<p>获取插件失败 ，需要将https 降级为http<br/>
<img src="media/15299133099249/15240202191693.jpg" alt=""/></p>

<p>系统管理 -&gt; 系统设置 -&gt; 插件管理 -&gt; 高级</p>

<p>升级站点改为 <br/>
<a href="http://mirrors.jenkins-ci.org/status.html">http://mirrors.jenkins-ci.org/status.html</a></p>

<p>下载插件</p>

<ul>
<li>Gradle</li>
<li>git</li>
<li>gitlab</li>
<li>ssh</li>
<li>等</li>
<li><br/>
## 新建项目
<img src="media/15299133099249/15240215365291.jpg" alt=""/></li>
</ul>

<p>可以增加参数化的构建</p>

<p><img src="media/15299133099249/15242012652458.jpg" alt=""/></p>

<p>打包完后工作空间即可生成对应的打包文件</p>

<p><img src="media/15299133099249/15240222554515.jpg" alt=""/></p>

<blockquote>
<p>构建local 文件 需要，file:// + <git 仓库文件路径></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gitlab 搭建]]></title>
    <link href="xuyushi.github.io/15299133099310.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099310.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">安装</h1>

<pre><code class="language-bash">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
yum install gitlab-ce
</code></pre>

<span id="more"></span><!-- more -->

<!--```bash
Retrieving key from https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey
Importing GPG key 0xE15E78F4:
 Userid     : "GitLab B.V. (package repository signing key) <packages@gitlab.com>"
 Fingerprint: 1a4c 919d b987 d435 9396 38b9 1421 9a96 e15e 78f4
 From       : https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey
Is this ok [y/N]:
```
-->

<h1 id="toc_1">启动 GitLab</h1>

<p>安装完成之后，打开配置文件<code>/etc/gitlab/gitlab.rb</code>将 <code>external_url = &#39;http://git.example.com&#39;</code>修改为自己的 IP 地址：<code>external_url &#39;http://ip_address&#39;</code>，然后执行下面的命令，对 GitLab 进行编译：</p>

<pre><code class="language-bash">gitlab-ctl reconfigure
</code></pre>

<h1 id="toc_2">GitLab 基本配置</h1>

<p>GitLab 的相关参数配置都存在 /etc/gitlab/gitlab.rb 文件里。自 GitLab 7.6 开始的新安装包, 已经默认将所有的参数写入到 /etc/gitlab/gitlab.rb 配置文件中。</p>

<h2 id="toc_3">配置端口</h2>

<p>GitLab 默认使用 80 端口对外提供服务，因为 80 端口被其他服务占用，所以需要更改。打开 /etc/gitlab/gitlab.rb 配置文件，修改 external_url &#39;http://ip_address&#39; 为 external_url &#39;http://ip_address:new-port&#39;，</p>

<p>报错 </p>

<pre><code class="language-bash">There was an error running gitlab-ctl reconfigure:

execute[clear the gitlab-rails cache] (gitlab::gitlab-rails line 390) had an error: Mixlib::ShellOut::ShellCommandFailed: Expected process to exit with [0], but received &#39;&#39;
---- Begin output of /opt/gitlab/bin/gitlab-rake cache:clear ----
STDOUT:
STDERR:
---- End output of /opt/gitlab/bin/gitlab-rake cache:clear ----
Ran /opt/gitlab/bin/gitlab-rake cache:clear returned

</code></pre>

<p>原来是机器内存没达到gitlab的要求，我的机器内存只有1G，gitlab的要求1G ram+1G swap</p>

<p>ubuntu下增加swap交换空间参考 </p>

<blockquote>
<p><a href="http://www.huzs.net/?p=1683">http://www.huzs.net/?p=1683</a></p>
</blockquote>

<h2 id="toc_4">Credentials</h2>

<ol>
<li>设置是 需要将开发机私钥设置copy 进jenkins</li>
<li>开发机共钥放 gitlab</li>
<li>本地机的  共钥放 gitlab
<img src="media/15299133099310/15242020277016.jpg" alt=""/></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android sdk 搭建]]></title>
    <link href="xuyushi.github.io/15299133099366.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099366.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Step 1. Download and Install Android SDK.</h2>

<pre><code class="language-bash">mkdir -p /opt/sdk-tools-linux-3859397
cd /opt/sdk-tools-linux-3859397
sudo wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip
sudo unzip sdk-tools-linux-3859397.zip
cd /opt
sudo chown -R root:root sdk-tools-linux-3859397
sudo ln -s sdk-tools-linux-3859397 android-sdk
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Step 2. Set Android SDK Environment Value.</h2>

<pre><code class="language-bash"> sudo vim /etc/profile.d/android-sdk-env.sh

export ANDROID_HOME=&quot;/opt/android-sdk&quot;
export PATH=&quot;$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH&quot;

sudo source /etc/profile.d/android-sdk-env.sh
</code></pre>

<h2 id="toc_2">Step 3.1 Update Android SDK.</h2>

<pre><code class="language-bash">cd /opt/android-sdk/tools
sudo ./android update sdk --no-ui
</code></pre>

<h2 id="toc_3">Step 3.2 Update Android SDK.</h2>

<p>Use Command Line to Update Android SDK</p>

<p>This is an example.</p>

<pre><code class="language-bash">/opt/android-sdk/tools/bin/sdkmanager --list
/opt/android-sdk/tools/bin/sdkmanager &quot;tools&quot; &quot;build-tools;26.0.0&quot; &quot;extras;android;m2repository&quot; &quot;extras;google;google_play_services&quot; &quot;platforms;android-26&quot; &quot;platform-tools&quot;
Posted by Moon Light February 1, 2016   android
</code></pre>

<h2 id="toc_4">更新sdk 版本</h2>

<pre><code class="language-bash">android update sdk --no-ui --all --filter &quot;android-23&quot;

android update sdk -u -t tool,platform-tool -a
</code></pre>

<p>yum install java-devel</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven 搭建]]></title>
    <link href="xuyushi.github.io/15299133099121.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099121.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<p>下载 </p>

<pre><code class="language-bash">wget -P /usr/local http://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz
</code></pre>

<p>安装</p>

<pre><code class="language-bash"># cd /usr/local
# mkdir nexus
# tar -zxvf nexus-3.6.0-02-unix.tar.gz -C nexus //解压缩到nexus文件夹（其中包含nexus-3.6.0-02和sonatype-work）

# cd nexus
# mv nexus-3.6.0-02/ nexus
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">配置</h2>

<p>自定义配置虚拟机可打开 nexus.vmoptions 文件进行配置（如果Linux硬件配置比较低的话，建议修改为合适的大小，否则会出现运行崩溃的现象）：</p>

<pre><code class="language-bash">vim nexus/config/nexus.vmoptions   
</code></pre>

<p>修改端口号</p>

<pre><code class="language-bash">application-host=&lt;vps 的ip&gt;
</code></pre>

<h2 id="toc_2">启动</h2>

<pre><code class="language-bash">/usr/local/nexus/nexus/bin/nexus start 
</code></pre>

<h2 id="toc_3">配置</h2>

<p>打开 <a href="http://ip:%E7%AB%AF%E5%8F%A3/nexus/">http://ip:端口/nexus/</a> ，初始账号 admin 密码 admin123</p>

<p>添加自己的仓库</p>

<p><img src="media/15299133099121/15242064068383.jpg" alt=""/></p>

<p>增加 user</p>

<p><img src="media/15299133099121/15242066550367.jpg" alt=""/></p>

<p><img src="media/15299133099121/15242067791896.jpg" alt=""/></p>

<h2 id="toc_4">android studio 打包上传</h2>

<p>新建一个测试 Android library moudle</p>

<p>peoject gradle 增加maven 仓库地址</p>

<pre><code class="language-gradle">buildscript {
    
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.0.0&#39;
        

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        repositories {
            maven { url &#39;http://xxx.xxx.1xx.3xxx:xxxx/nexus/content/repositories/testRep/&#39; }
        }
    }
}

</code></pre>

<p>library build.gradle 增加</p>

<pre><code class="language-gradle">apply plugin: &#39;maven&#39;
apply plugin: &#39;signing&#39;

def SNAPSHOT_REPOSITORY_URL = &#39;http://108.160.133.31:20014/nexus/content/repositories/testRep-snapshot/&#39;
def RELEASE_REPOSITORY_URL = &#39;http://108.160.133.31:20014//nexus/content/repositories/testRep/&#39;

uploadArchives {
    repositories {
        mavenDeployer {
            pom.groupId = &#39;io.github.xuyushi&#39;
            pom.artifactId = &#39;test&#39;
            pom.version = &#39;1.0.3&#39;
            repository(url: RELEASE_REPOSITORY_URL) {
                authentication(userName:&#39;xxxx&#39;, password: &#39;*****&#39;)
            }
            snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {
                authentication(userName:&#39;xxxx&#39;, password: &#39;****&#39;)
            }
        }
    }
}


</code></pre>

<p>编译上传</p>

<pre><code class="language-bash">../gradlw upload
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架3-Kotlin]]></title>
    <link href="xuyushi.github.io/15299133099083.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099083.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">gradle 修改</h2>

<p>加入 kotlin 之后需要使用 kapt,gradle 修改为</p>

<pre><code class="language-gradle">    //kotlin
    //dagger
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;

    compile &quot;com.blankj:utilcode:$rootProject.androidUtilsVerson&quot;
    //不加无法编译通过
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.kotlin_version&quot;

</code></pre>

<span id="more"></span><!-- more -->

<p>project gradle</p>

<pre><code class="language-gradle">buildscript {
    ext.kotlin_version = &#39;1.1.51&#39;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre>

<p>可以使用 AS 3.0 的新功能 或者 kotlin 插件，将项目整个工程转为 kotlin</p>

<h2 id="toc_1">注意，有几处 需要手动修改</h2>

<h3 id="toc_2">定义的dagger注解</h3>

<pre><code class="language-kotlin">@Scope
@kotlin.annotation.Retention
annotation class ActivityScoped

@Scope
@kotlin.annotation.Retention
annotation class FragmentScoped

</code></pre>

<h2 id="toc_3">注入使用</h2>

<pre><code class="language-gradle">    @Inject
    lateinit var mPresenter: RegisterContract.Presenter
</code></pre>

<p>需要使用 <code>lateinit</code> 来表示延迟初始化 </p>

<h2 id="toc_4">优化 mvp 结构</h2>

<p>可以将在 Presenter 接口这持有 view （view 是abs），复写接口的时候复写改 view</p>

<pre><code class="language-kotlin">
interface BasePresenter&lt;T&gt; {
    var mView:T?
    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    fun takeView(view: T){
        mView = view
    }

    /**
     * Drops the reference to the view when destroyed
     */
    fun dropView(){
        mView = null
    }

}

</code></pre>

<p>并在<code>takeView</code> <code>dropView</code> 对 view 进行复制，这样的好处就是复现该接口的同时就不用重复这些代码了 。而 java在接口也不能定义变量，在接口方法也也不能定义操作</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架3-Kotlin]]></title>
    <link href="xuyushi.github.io/15299133099209.html"/>
    <updated>2018-06-25T15:55:09+08:00</updated>
    <id>xuyushi.github.io/15299133099209.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">gradle 修改</h2>

<p>加入 kotlin 之后需要使用 kapt,gradle 修改为</p>

<pre><code class="language-gradle">    //kotlin
    //dagger
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;
    kapt &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;

    compile &quot;com.blankj:utilcode:$rootProject.androidUtilsVerson&quot;
    //不加无法编译通过
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.kotlin_version&quot;

</code></pre>

<span id="more"></span><!-- more -->

<p>project gradle</p>

<pre><code class="language-gradle">buildscript {
    ext.kotlin_version = &#39;1.1.51&#39;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre>

<p>可以使用 AS 3.0 的新功能 或者 kotlin 插件，将项目整个工程转为 kotlin</p>

<h2 id="toc_1">注意，有几处 需要手动修改</h2>

<h3 id="toc_2">定义的dagger注解</h3>

<pre><code class="language-kotlin">@Scope
@kotlin.annotation.Retention
annotation class ActivityScoped

@Scope
@kotlin.annotation.Retention
annotation class FragmentScoped

</code></pre>

<h2 id="toc_3">注入使用</h2>

<pre><code class="language-gradle">    @Inject
    lateinit var mPresenter: RegisterContract.Presenter
</code></pre>

<p>需要使用 <code>lateinit</code> 来表示延迟初始化 </p>

<h2 id="toc_4">优化 mvp 结构</h2>

<p>可以将在 Presenter 接口这持有 view （view 是abs），复写接口的时候复写改 view</p>

<pre><code class="language-kotlin">
interface BasePresenter&lt;T&gt; {
    var mView:T?
    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    fun takeView(view: T){
        mView = view
    }

    /**
     * Drops the reference to the view when destroyed
     */
    fun dropView(){
        mView = null
    }

}

</code></pre>

<p>并在<code>takeView</code> <code>dropView</code> 对 view 进行复制，这样的好处就是复现该接口的同时就不用重复这些代码了 。而 java在接口也不能定义变量，在接口方法也也不能定义操作</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架2-mvp 结构]]></title>
    <link href="xuyushi.github.io/15299133100126.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100126.html</id>
    <content type="html"><![CDATA[
<p>之前有两篇文章已经详细介绍过 mvp  <a href="http://xuyushi.github.io/2016/02/28/MVP/">Android 中的MVP 模式</a>    <a href="http://xuyushi.github.io/2016/04/30/%E5%9C%B0%E5%9B%BE%E5%8C%BA%E5%9F%9F%E7%BB%98%E5%88%B6%20MVP%20%E5%AE%9E%E8%B7%B5/">地图区域绘制 MVP 实践</a> ，本篇结合上篇的依赖注入使用<br/>
<span id="more"></span><!-- more --></p>

<h1 id="toc_0">定义 base 类</h1>

<p>定义 view 和 Presenter 的 interface</p>

<pre><code class="language-java">public interface BaseView&lt;T&gt; {

}
public interface BasePresenter&lt;T&gt; {

    /**
     * Binds presenter with a view when resumed. The Presenter will perform initialization here.
     *
     * @param view the view associated with this presenter
     */
    void  takeView(T view);

    /**
     * Drops the reference to the view when destroyed
     */
    void dropView();

}


</code></pre>

<p>presenter 的<code>takeView</code>在 view 对应的resume 生命周期中获取 view ，在 desdroy 中 将 view 赋值为 null ，以免内存泄露。</p>

<h2 id="toc_1">Contract</h2>

<p>Contract 为 view 和 Presenter 的继承接口 <br/>
举个例子 实现一个 splash 页面</p>

<pre><code class="language-java">
public interface SplashContract {
    interface View extends BaseView&lt;Presenter&gt; {
        void showWaitingPage();
    }

    interface Presenter extends BasePresenter&lt;View&gt; {
        void goLogin();

        void goMain();

        void tryLogin();

        void takeView(SplashContract.View view);
    }
}

</code></pre>

<p>SplashPresenter</p>

<pre><code class="language-java">class SplashPresenter implements SplashContract.Presenter{

    @Inject
    public SplashPresenter() {
    }

    @Nullable
    private SplashContract.View mView;

    @Override
    public void goLogin() {
        ToastUtils.showShort(&quot;go login&quot;);
        ActivityUtils.startActivity(LoginActivity.class);
    }

    @Override
    public void goMain() {
        ToastUtils.showShort(&quot;go Main&quot;);
        ActivityUtils.startActivity(MainActivity.class);
    }

    @Override
    public  void tryLogin() {
        Handler requestHandler = new Handler(Looper.getMainLooper());
        requestHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                boolean islogin = false;
                if (islogin) {
                    goMain();
                } else {
                    goLogin();
                }
            }
        }, 1000);


    }

    @Override
    public void takeView(SplashContract.View view) {
        mView = view;
        if (mView != null) {
            mView.showWaitingPage();
        }
    }

    @Override
    public void dropView() {
        mView = null;
    }
}

</code></pre>

<blockquote>
<p>注意 <br/>
在构造方法是 使用 <code>@Inject</code> 注解，一遍 dagger 框架能找到该类<br/>
每次调用view 中的方法时，都要进行判空，感觉上用 kotlin 代码会更方便点</p>
</blockquote>

<pre><code class="language-java">public class SplashActivity extends BaseActivity implements SplashContract.View {
    @Inject
    Context mContext;

    @Inject
    SplashContract.Presenter mPresenter;

    @BindView(R.id.ll_root)
    LinearLayout mLlRoot;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mPresenter.tryLogin();
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                ContactUtil.getContacts(mContext);
            }
        });
        thread.start();
    }

    @Override
    protected int getLayout() {
        return R.layout.activity_splash;
    }

    @Override
    protected void onResume() {
        super.onResume();
        mPresenter.takeView(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mPresenter.dropView();
    }

    @Override
    public void showWaitingPage() {
//        mLlRoot.setBackground(R.mipmap.ic_launcher);
    }
}
</code></pre>

<ol>
<li>Activity 实现view 接口，并在<code>onResume</code> 时<code>akeView</code>，<code>onDestroy</code> 时<code>dropView</code></li>
<li>通过 dagger 注入找到对应的 presenter </li>
</ol>

<p>为了能找到 Presenter ，我们还应该建立接口和对应实现的联系 ，可以使用 <code>@bind</code>注解 </p>

<p>SplashPresenterModule</p>

<pre><code class="language-java">@Module
public abstract class SplashPresenterModule {

    @ActivityScoped
    @Binds
    abstract SplashContract.Presenter statitsticsPresenter(SplashPresenter presenter);
}

</code></pre>

<p>然后在上篇文章提到的<code>ActivityBindingModule</code> 中，加入该 Activity 和改 module</p>

<pre><code class="language-java">@Module
public abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = TellTruePresenterModule.class)
    abstract MainActivity mainActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = SplashPresenterModule.class)
    abstract SplashActivity splashActivity();

}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架1-依赖注入]]></title>
    <link href="xuyushi.github.io/15299133100165.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100165.html</id>
    <content type="html"><![CDATA[
<p>关于依赖注入在 <a href="http://xuyushi.github.io/2017/04/08/Android%20CleanArchitecture%20--Dagger/">之前的文章里有详细的分析</a></p>

<p>而最近的 dagger 的更新又再次方便了注入过程 。<br/>
回顾之前的 dagger 在 Activity 、fragment 等 Android 组件中是如何注入的</p>

<ol>
<li>在 moduel 中，提供所需注入的元素的构造方法</li>
<li>构造对应的 <code>Component</code>，包含所需的 <code>module</code>，并将<code>module</code> 中的方法暴露出。并申明对应的inject方法 </li>
<li>在actvity 中注入</li>
</ol>

<p>这样做的弊端是 <br/>
<span id="more"></span><!-- more --></p>

<ol>
<li>即使Dagger使我们的代码耦合性更低，但是如果要面临重构，我们仍然不得不去面对每个Activity中这样数行需要我们「复制」+「粘贴」的代码，这会给我们的重构带来一定的难度（试想一下，如果我们的应用有数十个乃至上百个这样的Activity或者Fragment容器，我们的重构计划，首先就要面对这样数百行的代码）。<br/></li>
<li>更重要的是，它要求注射类型（FrombulationActivity）知道其注射器。 即使这是通过接口而不是具体类型完成的，它打破了依赖注入的核心原则：一个类不应该知道如何实现依赖注入。</li>
<li>在开发过程中明显发现，在每个 Activity 中构造对应的<code>Component</code>，然后注入 是件很恶心的事情，而且这个注入并不能写入 base 类中，只能每个 Activity 中再重复写入</li>
</ol>

<p>在新版的 dagger 中提供了 <code>ContributesAndroidInjector</code>这样一个注解</p>

<p>看下官方文档如何描述的</p>

<pre><code class="language-java">/**
 * Generates an {@link AndroidInjector} for the return type of this method. The injector is
 * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}&#39;s
 * component.
 *
 * &lt;p&gt;This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
 * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
 * MyService}, etc). The method should have no parameters.
 *
 * &lt;p&gt;For more information, see &lt;a href=&quot;https://google.github.io/dagger/android&quot;&gt;the docs&lt;/a&gt;
 */
</code></pre>

<p><code>@ContributesAndroidInjector</code>使用在 module 中的抽象方法上。该方法不该有参数，<strong>返回类型必须是 Activity、Fragment 和 Service 等 Android Framework 的类型</strong>。dagger 将会为这样的一个方法生成一个对应的 Subcomponent。这个注解还能接受一系列 Module 作为值，这些 module 将会成为所生成的 Subcomponent 的 module。</p>

<h2 id="toc_0">搭建过程</h2>

<h3 id="toc_1">添加依赖</h3>

<pre><code class="language-gradle">    // Dagger dependencies
    compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;
    annotationProcessor &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;
    compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot; // if you use the support libraries
    annotationProcessor &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot;

</code></pre>

<h2 id="toc_2">ActivityBindingModule</h2>

<p>ActivityBindingModule 使用dagger 框架提供<code>ContributesAndroidInjector注解</code> 辅助我们注入 Android 框架</p>

<pre><code class="language-java">@Module
public abstract class ActivityBindingModule {
    @ActivityScoped
    @ContributesAndroidInjector(modules = TellTruePresenterModule.class)
    abstract MainActivity mainActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = SplashPresenterModule.class)
    abstract SplashActivity splashActivity();

    @ActivityScoped
    @ContributesAndroidInjector(modules = LoginModule.class)
    abstract LoginActivity loginActivity();
}
</code></pre>

<p>以后每次增加 Activity 或者 service 等，只要在这添加一行代码就行了，不需要修改对应的 Activity</p>

<h2 id="toc_3">AppComponent</h2>

<pre><code class="language-java">@Singleton
@Component(modules = {TasksRepositoryModule.class,
        ApplicationModule.class,
        ActivityBindingModule.class,
        AndroidSupportInjectionModule.class})

public interface AppComponent extends AndroidInjector&lt;DaggerApplication&gt; {

    void inject(MyApplication application);

    TasksRepository getTasksRepository();

    @Override
    void inject(DaggerApplication instance);

    // Gives us syntactic sugar. we can then do DaggerAppComponent.builder().application(this).build().inject(this);
    // never having to instantiate any modules or say which module we are passing the application to.
    // Application will just be provided into our app graph now.
    @Component.Builder
    interface Builder {

        @BindsInstance
        AppComponent.Builder application(Application application);

        AppComponent build();
    }

//    APIInterface APIInterface();
}

</code></pre>

<p>注意注解中 module 的依赖</p>

<h2 id="toc_4">ApplicationModule</h2>

<pre><code class="language-java">@Module
public abstract class ApplicationModule {
    //expose Application as an injectable context
    @Binds
    abstract Context bindContext(Application application);

    @Provides
    public static APIInterface provideInterface() {
        Retrofit retrofit= new Retrofit.Builder()
                .baseUrl(&quot;https://api.github.com&quot;)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        APIInterface service = retrofit.create(APIInterface.class);
        return service;
    }
}


</code></pre>

<p>可以把全局的一些单例类放在这个 moduel。 比如<code>RetrofitService</code>、application 的<code>context</code> 等 </p>

<h2 id="toc_5">添加 Activity fragment 的 scope</h2>

<pre><code class="language-java">@Documented
@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface ActivityScoped {
}


@Scope
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface FragmentScoped {}

</code></pre>

<h2 id="toc_6">application 中 inject</h2>

<pre><code class="language-java">public class MyApplication extends DaggerApplication {
    @Inject
    TasksRepository tasksRepository;

    @Override
    protected AndroidInjector&lt;? extends DaggerApplication&gt; applicationInjector() {
        AppComponent appComponent = DaggerAppComponent.builder().application(this).build();
        appComponent.inject(this);
        return appComponent;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Utils.init(this);
    }
}

</code></pre>

<blockquote>
<p>注意 <br/>
activity 和 fragment 等都要 extend 自 dagger 中的对应类，也可以将对应的逻辑抽象至 base 类中</p>
</blockquote>

<p>最后可以将以上类放入同一个包中<br/>
<img src="media/15299133100165/15091645703766.png" alt=""/></p>

<h1 id="toc_7">参考</h1>

<blockquote>
<p><a href="https://juejin.im/entry/593cee56ac502e006b3dc9c2">https://juejin.im/entry/593cee56ac502e006b3dc9c2</a><br/>
<a href="https://segmentfault.com/a/1190000010016618">https://segmentfault.com/a/1190000010016618</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速搭建新项目框架0-前言]]></title>
    <link href="xuyushi.github.io/15299133100210.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133100210.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">前言</h1>

<p>有幸在公司从零开始做一个项目，非常兴奋。也想着在快速开发的过程中如何保持 app 代码结构 clean。由此总结此次代码整体框架的搭建过程，供日后回顾总结</p>

<span id="more"></span><!-- more -->

<p>通过这几天的调研 ，初步决定使用以下</p>

<ol>
<li>mvp 结构，view 和业务逻辑解耦，并可以在 UI 未给出切图时优先开发业务逻辑。</li>
<li>dagger 注入。 是的 v p 之间无依赖关系</li>
<li>~~clean 结构 。 将 业务逻辑独立到每个 usecase中 ~~。发现前期轻量级的 app 并不适合这种结构，使用 usecase 会降低开发效率，此模式更适合与 app 成型后 ，将可以复用的业务逻辑抽象成 usecase</li>
<li>butteknief 注入 </li>
<li>网络库待定 ？repository 模式 ，方便后期网络库更换</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture Components--Room  Persistence Library]]></title>
    <link href="xuyushi.github.io/15299133101299.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133101299.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">Room Persistence Library</h1>

<p>Room 在 SQLite 之上提供了一个抽象层，以便在利用 SQLite 全部功能的同时能够流畅的访问数据库。</p>

<p>将数据持久化到本地对于应用程序处理大量结构化数据有非常大的好处。最常见的情况是缓存相关数据。这样，当设备无法访问网络时，用户仍然可以在离线状态下浏览内容。然后，在设备重新上线后，任何用户发起的内容变更都会同步到服务器。</p>

<p>核心框架提供了内置支持来处理原始的 SQL 内容。虽然这些 API 是强大的，但是它们非常低级并且使用起来需要话费巨大的时间和精力：<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>原始的 SQL 查询没有编译时验证。随着数据图的更改，需要手动更新收影响的 SQL 查询。这个过程是耗时的并且容易出错。</li>
<li>需要使用大量的样板代码用于在 SQL 查询和 Java 数据对象之间转换。</li>
</ul>

<p>Room 在 SQLite 之上提供的抽象层帮助处理这些问题。</p>

<p>Room 有 3 个重大的组件：</p>

<ul>
<li>Database：可以使用此组件创建数据库的持有者。通过注解定义实体列表，通过类的内容定义数据库中数据访问对象（DAO）列表。它是底层连接的主要接入点。</li>
</ul>

<p>注解的类应该是一个继承了 RoomDatabase 的抽象类。在运行时，可以通过调用 Room.databaseBuilder() 或 Room.inMemoryDatabaseBuilder() 获取一个实例。</p>

<ul>
<li>Entity：该组件表示一个保存有数据库行的类。对于每个 Entity，创建一个数据库表来保存项目。必须通过 Database 中的 entities 字段引用 Entity 类。Entity 中的每个字段都会持久化到数据库中，除非使用 @Ignore 注解。</li>
</ul>

<blockquote>
<p>注：Entity 可以拥有一个空的构造函数（如果 DAO 可以访问每个持久化的字段）或一个参数的类型和名字和 Entity 中的字段都匹配的构造函数。Room 还可以使用全部或部分的构造函数，如只接受部分字段的构造函数。</p>
</blockquote>

<ul>
<li>DAO：该组件表示一个数据访问对象（DAO）的类或接口。DAO 是 Room 的主要组件，其职责是定义方法来访问数据库。被 @Database 注解的类必须包含一个没有参数的抽象方法，该方法的返回值是被 @Dao 注解的类。在编译时生成代码时，Room 创建该类的实现。<br/>
&gt; 注：通过使用 DAO 访问数据库，而不是使用查询建造者或直接查询，可以分离数据库结构的不同组件。另外，DAO 可以在测试应用时很容易的模拟数据库。</li>
</ul>

<p>这些组件及其与应用程序其它部分的关系，如图 1 所示：</p>

<p><img src="media/15299133101299/14985505743620.png" alt=""/></p>

<p>以下代码片段包含了一个具有一个 Entity 和一个 DAO 的数据库配置：</p>

<p>User.java</p>

<pre><code class="language-java">
@Entity
public class User {
    @PrimaryKey
    private int uid;

    @ColumnInfo(name = &quot;first_name&quot;)
    private String firstName;

    @ColumnInfo(name = &quot;last_name&quot;)
    private String lastName;

    // 简单起见忽略了 Getters 和 setters，
    // 但是 Room 需要它们。
}
</code></pre>

<p>UserDao.java</p>

<pre><code class="language-java">@Dao
public interface UserDao {
    @Query(&quot;SELECT * FROM user&quot;)
    List&lt;User&gt; getAll();

    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)
    List&lt;User&gt; loadAllByIds(int[] userIds);

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;
           + &quot;last_name LIKE :last LIMIT 1&quot;)
    User findByName(String first, String last);

    @Insert
    void insertAll(User... users);

    @Delete
    void delete(User user);
}
</code></pre>

<p>AppDatabase.java</p>

<pre><code class="language-java">
@Database(entities = {User.class}, version = 1)
public abstract class AppDatabase extends RoomDatabase {
    public abstract UserDao userDao();
}
</code></pre>

<p>创建上述文件之后，使用如下代码获取创建的数据库实例：</p>

<pre><code class="language-java">AppDatabase db = Room.databaseBuilder(getApplicationContext(),
        AppDatabase.class, &quot;database-name&quot;).build();
</code></pre>

<blockquote>
<p>注：在实例化 AppDatabase 对象时应该遵循单例设计模式，因为每个 RoomDatabase 实例都非常昂贵，并且很少需要访问多个实例。</p>
</blockquote>

<h2 id="toc_1">Entity</h2>

<p>当一个类被 @Entity 注解并且被 @Database 注解的 entities 参数引用，Room 会在数据库中为该 Entity 创建一个数据库表。</p>

<p>默认情况下，Room 为每个定义在 Entity 中的字段创建列。如果不希望 Entity 中某些字段被持久化，可以使用 @Ignore 注解这些字段。如下面的代码片段所示：</p>

<pre><code class="language-java">
@Entity
class User {
    @PrimaryKey
    public int id;

    public String firstName;
    public String lastName;

    @Ignore
    Bitmap picture;
}

</code></pre>

<p>要持久化一个字段，Room 必须有权限访问它。可以将字段设置为 public，或为该字段提供 setter 和 getter 方法。如果使用 setter 和 getter 方法，请记住，它们基于 Room 中的 Java Beans 约定。</p>

<h3 id="toc_2">主键</h3>

<p>每个 Entity 必须定义至少一个字段作为主键。即使只有一个字段，仍然需要使用 @PrimaryKey 注解该字段。如果希望 Room 为 Entity 分配自动 ID，可以设置 @PrimaryKey 的 autoGenerate) 属性。如果 Entity 有复合主键，可以使用 @Entity 注解的 primaryKeys) 属性，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(primaryKeys = {&quot;firstName&quot;, &quot;lastName&quot;})
class User {
    public String firstName;
    public String lastName;

    @Ignore
    Bitmap picture;
}
</code></pre>

<p>默认情况下，Room 使用类名作为数据库表的名字。如果希望数据库表有不同的名字，可以设置 @Entity 的 tableName) 属性，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(tableName = &quot;users&quot;)
class User {
    ...
}
</code></pre>

<blockquote>
<p>SQLite 中的表名不区分大小写。</p>
</blockquote>

<p>类似于 tableName) 属性，Room 使用字段名字作为数据库中列的名字。如果想要不同的列名，给字段添加一个 @ColumnInfo 注解，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(tableName = &quot;users&quot;)
class User {
    @PrimaryKey
    public int id;

    @ColumnInfo(name = &quot;first_name&quot;)
    public String firstName;

    @ColumnInfo(name = &quot;last_name&quot;)
    public String lastName;

    @Ignore
    Bitmap picture;
}
</code></pre>

<h3 id="toc_3">索引和唯一性</h3>

<p>根据访问数据的方式，可能需要在数据库中索引某些字段来加速查询。要给 Entity 添加索引，需要在 @Entity 注解中添加 indices) 属性，列出想要包含在索引或复合索引中的列的名字。以下代码片段演示了该注解过程：</p>

<pre><code class="language-java">@Entity(indices = {@Index(&quot;name&quot;), @Index(&quot;last_name&quot;, &quot;address&quot;)})
class User {
    @PrimaryKey
    public int id;

    public String firstName;
    public String address;

    @ColumnInfo(name = &quot;last_name&quot;)
    public String lastName;

    @Ignore
    Bitmap picture;
}

</code></pre>

<p>有时，有些字段或字段组必须是唯一的。可以通过设置 @Index 注解的 unique) 属性为 true 来实施唯一性。以下示例代码可以防止表中的两行数据具有一组相同的 firstNmae 列和 lastName 列：</p>

<pre><code class="language-java">@Entity(indices = {@Index(value = {&quot;first_name&quot;, &quot;last_name&quot;},
        unique = true)})
class User {
    @PrimaryKey
    public int id;

    @ColumnInfo(name = &quot;first_name&quot;)
    public String firstName;

    @ColumnInfo(name = &quot;last_name&quot;)
    public String lastName;

    @Ignore
    Bitmap picture;
}
</code></pre>

<h3 id="toc_4">关系</h3>

<p>因为 SQLite 是一个关系型数据库，可以指定两个对象间的关系。即使大多数 ORM 库允许 Entity 对象之间互相引用，但是 Room 明确禁止这样做。详细信息，请参阅附录：Entity 之间无对象引用。</p>

<p>虽然不能使用直接关系，但是 Room 允许在 Entity 之间定义外键约束。</p>

<p>例如，有一个名为 Book 的 Entity，可以使用 @ForeignKey 注解定义其和 User 的关系，如下面的代码片段所示：</p>

<pre><code class="language-java">@Entity(foreignKeys = @ForeignKey(entity = User.class,
                                  parentColumns = &quot;id&quot;,
                                  childColumns = &quot;user_id&quot;))
class Book {
    @PrimaryKey
    public int bookId;

    public String title;

    @ColumnInfo(name = &quot;user_id&quot;)
    public int userId;
}
</code></pre>

<p>外键是非常有用的，外键可以让你指定当应用的 Entity 更新时做什么。例如，通过在 @ForeignKey 注解中包含 onDelete=CASCADE) 可以告诉 SQLite 如果相应的 User 实例被删除，则删除该用户的所有图书。</p>

<blockquote>
<p>注：SQLite 将 @Insert(OnConflict=REPLACE) 当作一组 REMOVE 和 REPLACE 操作来处理，而不是当作单独的 UPDATE 操作处理。这种替换冲突值的方法可能会影响外键约束。更多详细信息，请参阅 SQLite 文档的 ON_CONFLICT 子句。</p>
</blockquote>

<h3 id="toc_5">嵌套对象</h3>

<p>有时，可能会需要将一个 Entity 或普通 Java 对象（POJO）作为数据库逻辑中的一个连贯的整体，即使对象包含多个字段。对于这些情况，可以使用 @Embedded 注解来表示要在表中分解为其子字段的对象。可以像查询其它独立字段一样查询嵌套的字段。</p>

<p>例如：User 类可能包含一个类型为 Address 的字段，表示一个名为 street，city，state 和 postCode 的字段组合。要在表中单独存储组合列，请在 User 类中包含一个用 @Embedded 注解的 Address 字段，如下面的代码片段所示：</p>

<pre><code class="language-java">class Address {
    public String street;
    public String state;
    public String city;

    @ColumnInfo(name = &quot;post_code&quot;)
    public int postCode;
}

@Entity
class User {
    @PrimaryKey
    public int id;

    public String firstName;

    @Embedded
    public Address address;
}
</code></pre>

<p>表示 User 对象的表包含以下名称的列：id，firstName，street，state，city 和 post_code。</p>

<p>如果 Entity 有多个相同类型的嵌套字段，可以通过设置 prefix) 属性保持列唯一。Room 会将提供的值添加到嵌套对象每个列名的开头。</p>

<h2 id="toc_6">数据访问对象（DAO）</h2>

<p>Room 的主要组件是 Dao 类。DAP 以干净的方式抽象访问数据库。</p>

<blockquote>
<p>注：除非在建造者上调用了 allowMainThreadQueries())，否则 Room 不允许在主线程上访问数据库，因为这样可能会长时间锁定 UI。异步查询（返回 LiveData 或 RxJava Flowable 的查询）会规避该规则，因为当需要时他们在后台线程上异步运行。</p>
</blockquote>

<h3 id="toc_7">简便的方法</h3>

<p>使用 DAO 类有多个可代表的简便方法。本文档包含了几个常见的例子。</p>

<h4 id="toc_8">Insert</h4>

<p>当创建一个 DAO 方法并用 @Insert 注解时，Room 会在单独的事务中生成一个将所有参数插入到数据库的实现。</p>

<p>以下代码片段显示了几个示例查询：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    public void insertUsers(User... users);

    @Insert
    public void insertBothUsers(User user1, User user2);

    @Insert
    public void insertUsersAndFriends(User user, List&lt;User&gt; friends);
}
</code></pre>

<p>如果 @Insert 方法只接受到一个参数，它能返回一个 long，表示被插入项的新 rowId。如果参数是一个数组或集合，它应该返回 long[] 或 List。</p>

<p>更多详细信息，请参阅 @Insert 注解的参考文档或 SQLite 文档的 Rowid Tables。</p>

<h4 id="toc_9">Update</h4>

<p>Update 是一个用于在数据库中更新以参数形式给到的一组 Entity 的简便方法。它使用一个查询以与每个 Entity 的主键匹配。以下代码片段演示了如何定义该方法：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Update
    public void updateUsers(User... users);
}
</code></pre>

<p>虽然通常不是必须的，可以让该方法返回一个 int 值，表示数据库中更新的行数。</p>

<h4 id="toc_10">Delete</h4>

<p>Delete 是一个用于从数据库中删除以参数形式给到的一组 Entity 的简便方法。它使用主键来查找要删除的 Entity。以下代码片段演示了如何定义该方法：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Delete
    public void deleteUsers(User... users);
}
</code></pre>

<p>虽然通常不是必须的，可以让该方法返回一个 int 值，表示从数据库中删除的行数。</p>

<h3 id="toc_11">使用 @Query 方法</h3>

<p>@Query 是使用 DAO 类的主要注解。它允许在数据库上执行读/写操作。每个 @Query 方法在编译时验证，所以，如果查询有问题，则会发生编译时错误而不是运行时崩溃。</p>

<p>Room 还会验证查询的返回值，如果返回对象的字段名字和查询响应中的相应列名不匹配，则 Room 会用以下两种方式之一提醒你：</p>

<ul>
<li>如果只有部分字段名匹配会发错警告。</li>
<li>如果没有字段名匹配会给出错误。</li>
</ul>

<h4 id="toc_12">简单查询</h4>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user&quot;)
    public User[] loadAllUsers();
}
</code></pre>

<p>这是一个非常简单的查询会载入所有用户。在编译时，Room 知道它正在查询用户表中的所有列。如果查询包含语法错误或数据库中不存在用户表，Room将会在应用程序编译时显示相应的错误信息。</p>

<h4 id="toc_13">传递参数给查询</h4>

<p>大多数情况下，需要传递参数给查询来执行过滤操作。例如，只显示大于某个年龄的用户。要完成此任务，需要在 Room 注解中使用方法参数，如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user WHERE age &gt; :minAge&quot;)
    public User[] loadAllUsersOlderThan(int minAge);
}
</code></pre>

<p>当在编译时处理该查询时，Room 会匹配绑定参数 :minAge 和方法参数 minAge。Room 使用参数名字执进行匹配。如果没有匹配，在应用程序编译时会发生错误。</p>

<p>可以在查询中传递多个参数或多次引用它们，如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge&quot;)
    public User[] loadAllUsersBetweenAges(int minAge, int maxAge);

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :search &quot;
           + &quot;OR last_name LIKE :search&quot;)
    public List&lt;User&gt; findUserWithName(String search);
}
</code></pre>

<h4 id="toc_14">返回列的子集</h4>

<p>大多数情况下，只需要获取到一个 Entity 的几个字段。例如，UI 可能只显示用户的名字和姓氏，而不是用户的每个详细信息。通过只获取应用程序 UI 中显示的列，可以节省宝贵的资源，并且查询完成更快。</p>

<p>Room 可以返回任何 Java 对象，只要可以将返回列的集合映射到返回的对象中。例如，可以创建如下的 POJO 来获取用户的名字和姓氏：</p>

<pre><code class="language-java">public class NameTuple {
    @ColumnInfo(name=&quot;first_name&quot;)
    public String firstName;

    @ColumnInfo(name=&quot;last_name&quot;)
    public String lastName;
}
</code></pre>

<p>现在，可以在查询方法中使用该 POJO。</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT first_name, last_name FROM user&quot;)
    public List&lt;NameTuple&gt; loadFullName();
}
</code></pre>

<p>Room 知道查询 first_name 列和 last_name 列的返回值，并将这些值映射到 NameTuple 类的字段中。因此，Room 可以生成正确的代码。如果查询返回多余的列，或 NameTuple 类中不存在的列，Room 会显示警告。</p>

<blockquote>
<p>注：这些 POJO 也可以使用 @Embedded 注解。</p>
</blockquote>

<h4 id="toc_15">传递一组参数</h4>

<p>一些查询可能需要传递可变数量的参数，直到运行时才知道参数的具体数量。例如，你可能想获取某些区域下所有用户的相关信息。当参数为一个集合时 Room 就会明白，并且会在运行时基于所提供参数的数量展开该集合。</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;)
    public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);
}
</code></pre>

<h4 id="toc_16">可观察的查询</h4>

<p>在执行查询时，总会希望应用程序 UI 在数据更改时自动更新。要实现这个，需要在查询方法的描述中使用类型为 LiveData 的返回值。在数据库更新后，Room 会生成所有必须的代码来更新 LiveData。</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;)
    public LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);
}
</code></pre>

<h4 id="toc_17">RxJava</h4>

<p>Room 还可以从定义的查询返回 RxJava2 的 Publisher 和 Flowable 对象。要使用该功能，需要将 Room 组中的 android.arch.persistence.room:rxjava2 组件添加到构建 Gradle 依赖中。然后，可以返回 RxJava2 中定义的类型对象，如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * from user where id = :id LIMIT 1&quot;)
    public Flowable&lt;User&gt; loadUserById(int id);
}
</code></pre>

<h4 id="toc_18">直接访问 Cursor</h4>

<p>如果应用程序的逻辑需要直接访问返回行，可以从查询返回一个 Cursor 对象。如以下代码片段所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM user WHERE age &gt; :minAge LIMIT 5&quot;)
    public Cursor loadRawUsersOlderThan(int minAge);
}
</code></pre>

<blockquote>
<p>警告：不鼓励使用 Cursor API，因为它不能保证行是否存在或行包含什么值。仅当你已经有存在 Cursor 的代码并且不好重构时才使用此功能。</p>
</blockquote>

<h4 id="toc_19">多表查询</h4>

<p>某些查询可能需要访问多个表来计算结果。Room 允许编写任何查询，所以也可以连接表。另外，如果响应是一个可观察类型，如：Flowable 或 LiveData，Room 观察查询中引用的所有表。</p>

<p>以下代码片段显示了如何执行表连接以整合借阅书的用户表和当前借出的图书表之间的信息：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
    @Query(&quot;SELECT * FROM book &quot;
           + &quot;INNER JOIN loan ON loan.book_id = book.id &quot;
           + &quot;INNER JOIN user ON user.id = loan.user_id &quot;
           + &quot;WHERE user.name LIKE :userName&quot;)
   public List&lt;Book&gt; findBooksBorrowedByNameSync(String userName);
}
</code></pre>

<p>这些查询也可以返回 POJO，例如，可以编写一个加载用户及其宠物名称的查询，如下所示：</p>

<pre><code class="language-java">@Dao
public interface MyDao {
   @Query(&quot;SELECT user.name AS userName, pet.name AS petName &quot;
          + &quot;FROM user, pet &quot;
          + &quot;WHERE user.id = pet.user_id&quot;)
   public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames();

   // You can also define this class in a separate file, as long as you add the
   // &quot;public&quot; access modifier.
   static class UserPet {
       public String userName;
       public String petName;
   }
}
</code></pre>

<h3 id="toc_20">使用类型转换器</h3>

<p>Room 提供内置支持基本数据类型及其封装类型。然而，有时候需要使用自定义类型，并将其值存储在数据库中单独的列里。要添加自定义类型的支持，需要提供一个 TypeConverter 将自定义类转换为 Room 可以持久化的已知类型。</p>

<p>例如：如果想要持久化 Date 实例，你可以编写如下的 TypeConverter 在数据库中存储等效的 Unix 时间戳。</p>

<pre><code class="language-java">public class Converters {
    @TypeConverter
    public static Date fromTimestamp(Long value) {
        return value == null ? null : new Date(value);
    }

    @TypeConverter
    public static Long dateToTimestamp(Date date) {
        return date == null ? null : date.getTime();
    }
}
</code></pre>

<p>上面的例子定义了两个方法，一个将 Date 对象转换为 [Long] 对象，另一个执行逆向转换，将 [Long] 转换为 Date。因为 Room 已经知道如何持久化 [Long] 对象，所以它可以使用该转换器来持久化 Date 类型的值。</p>

<p>下面，给 AppDatabase 添加 [@TypeConverter] 注解，以便 Room 可以在 AppDatabase 对每个 Entity 和 DAO 使用定义的转换器。</p>

<p>AppDatabase.java</p>

<pre><code class="language-java">@Database(entities = {User.java}, version = 1)
@TypeConverters({Converter.class})
public abstract class AppDatabase extends RoomDatabase {
    public abstract UserDao userDao();
}
</code></pre>

<p>使用这些转换器，可以在其它查询中像使用基本数据类型一样使用自定义类型。</p>

<p>User.java</p>

<pre><code class="language-java">@Entity
public class User {
    ...
    private Date birthday;
}
</code></pre>

<p>UserDao.java</p>

<pre><code class="language-java">@Dao
public interface UserDao {
    ...
    @Query(&quot;SELECT * FROM user WHERE birthday BETWEEN :from AND :to&quot;)
    List&lt;User&gt; findUsersBornBetweenDates(Date from, Date to);
}
</code></pre>

<p>还可以给 @Typeconverters 限制不同的作用域，包括单个 Entity，DAO 和 DAO 方法，更多详细信息，请参阅 @TypeConverters 注解的参考文档。</p>

<h3 id="toc_21">数据库迁移</h3>

<p>当给应用程序添加或修改功能时，需要修改 Entity 类来反映这些修改。当用户更新到应用程序的最新版本时，你不希望他们丢失现有数据，特别是如果无法从远程服务端恢复数据时。</p>

<p>Room 允许以编写 Migration 类的方式保留用户数据。每个 Migration 类都指定一个 startVersion 和 endVersion。在运行时，Room 允许每个 Migration 的 migrate()) 方法，使用正确的顺序将数据库迁移到最新版本。</p>

<blockquote>
<p>警告：如果没有提供必要的迁移，则会重建数据库，这意味着将会失去数据库中所有的数据。</p>
</blockquote>

<pre><code class="language-java">Room.databaseBuilder(getApplicationContext(), MyDb.class, &quot;database-name&quot;)
        .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();

static final Migration MIGRATION_1_2 = new Migration(1, 2) {
    @Override
    public void migrate(SupportSQLiteDatabase database) {
        database.execSQL(&quot;CREATE TABLE `Fruit` (`id` INTEGER, &quot;
                + &quot;`name` TEXT, PRIMARY KEY(`id`))&quot;);
    }
};

static final Migration MIGRATION_2_3 = new Migration(2, 3) {
    @Override
    public void migrate(SupportSQLiteDatabase database) {
        database.execSQL(&quot;ALTER TABLE Book &quot;
                + &quot; ADD COLUMN pub_year INTEGER&quot;);
    }
};
</code></pre>

<p>迁移过程结束后，Room验证数据库架构以确保迁移执行正确。如果 Room 发现问题，将会抛出含有不匹配信息的异常。</p>

<h4 id="toc_22">测试迁移</h4>

<p>迁移不是简单的写入，并且无法正确写入它们可能会导致应用程序崩溃。为了保持应用的稳定性，应该实现测试迁移。Room 提供了一个测试 Maven 组件来帮助进行该测试过程。然而，为了使该组件正常工作，需要导出数据库的结构</p>

<h4 id="toc_23">导出架构</h4>

<p>汇编后，Room 将数据库的架构信息导出为 JSON 文件。要导出架构，需要在 build.gradle 文件中设置 room.schemaLocation 注解数据处理属性，如以下代码片段所示：</p>

<p>build.gradle</p>

<pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [&quot;room.schemaLocation&quot;:
                             &quot;$projectDir/schemas&quot;.toString()]
            }
        }
    }
}
</code></pre>

<p>应该将导出的 JSON 文件（其表示数据库架构的历史记录）存储在版本控制系统中，因为它允许 Room 创建旧版本的数据库以进行测试。</p>

<p>要测试这些迁移，请将来自 Room 的 android.arch.persistence.room:testing Maven 组件添加到测试依赖中，并将架构文件的位置添加为资产文件，如以下代码片段所示：</p>

<p>build.gradle</p>

<pre><code class="language-java">android {
    ...
    sourceSets {
        androidTest.assets.srcDirs += files(&quot;$projectDir/schemas&quot;.toString())
    }
}
</code></pre>

<p>测试包提供了一个 MigrationTestHelper 类，可以读取这些架构文件。它也是一个 Junit4 的 TestRule 类，所以它可以管理创建的数据库。</p>

<p>以下代码片段显示了迁移测试的例子：</p>

<pre><code class="language-java">@RunWith(AndroidJUnit4.class)
public class MigrationTest {
    private static final String TEST_DB = &quot;migration-test&quot;;

    @Rule
    public MigrationTestHelper helper;

    public MigrationTest() {
        helper = new MigrationTestHelper(InstrumentationRegistry.getContext(),
                MigrationDb.class.getCanonicalName(),
                new FrameworkSQLiteOpenHelperFactory());
    }

    @Test
    public void migrate1To2() throws IOException {
        SupportSQLiteDatabase db = helper.createDatabase(TEST_DB, 1);

        // db 的架构版本是 1. 使用 SQL 查询插入一些数据。
        // You cannot use DAO classes because they expect the latest schema.
        db.execSQL(...);

        // 准备下一个版本。
        db.close();

        // 使用 version2 重新打开数据库
        // 并且提供 MIGRATION_1_2 作为迁移过程。
        db = helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2);

        // MigrationTestHelper 自动验证架构的更改，
        // 但是需要验证数据是否迁移正确。
    }
}
</code></pre>

<h3 id="toc_24">测试数据库</h3>

<p>当应用程序运行测试时，如果不测试数据库本身则没有必要创建完整的数据库。Room 允许在测试中轻松的模拟数据访问层。这个过程是可能的，因为 DAO 不会泄漏数据库的任何细节。当测试应用程序的其余部分时，应该创建 DAO 类的模拟或假的实例。</p>

<p>有两种方式可以测试数据库：</p>

<ul>
<li>在开发主机上。</li>
<li>在 Android 设备上。</li>
</ul>

<h4 id="toc_25">在主机上测试</h4>

<p>Room 使用 SQLite 支持库，它提供与 Android Framework 类中一致的接口。该支持库允许传递支持库的自定义实现来测试数据库查询。</p>

<p>即使此设置可以让测试快速运行，但是不推荐使用，因为你的设备上（和用户设备上）运行的 SQLite 版本和你主机上运行的版本不一致。</p>

<h4 id="toc_26">在 Android 设备上测试</h4>

<p>用于测试数据库实现的推荐方式是编写在 Android 设备上运行的 Junit 测试。因为这些测试不需要创建 activity，所以它们应该比 UI 测试执行的更快。</p>

<p>设置测试时，应该创建数据库的内存版本，使测试更加封闭，如以下示例所示：</p>

<pre><code class="language-java">@RunWith(AndroidJUnit4.class)
public class SimpleEntityReadWriteTest {
    private UserDao mUserDao;
    private TestDatabase mDb;

    @Before
    public void createDb() {
        Context context = InstrumentationRegistry.getTargetContext();
        mDb = Room.inMemoryDatabaseBuilder(context, TestDatabase.class).build();
        mUserDao = mDb.getUserDao();
    }

    @After
    public void closeDb() throws IOException {
        mDb.close();
    }

    @Test
    public void writeUserAndReadInList() throws Exception {
        User user = TestUtil.createUser(3);
        user.setName(&quot;george&quot;);
        mUserDao.insert(user);
        List&lt;User&gt; byName = mUserDao.findUsersByName(&quot;george&quot;);
        assertThat(byName.get(0), equalTo(user));
    }
}

</code></pre>

<h2 id="toc_27">附录：Entity 之间无对象引用</h2>

<p>将数据库中的关系映射到相应的对象模型是一种常见的做法，并且在服务端可以很好的运行，因为在访问时惰性加载文件是高效的。</p>

<p>然而，在客户端，惰性加载是不可能的，因为有可能发生在 UI 线程上，并且在 UI 线程中查询磁盘上的信息会产生显著的性能问题。 UI 线程大约有 16ms 来计算和绘制 activity 的布局更新，所以，即使一个查询任务只需要 5ms，应用程序仍然可能没有时间绘制帧，造成显著的破坏。更糟糕的时，如果并行运行单独的事务或设备忙于其它磁盘繁重的任务，则查询可能需要更多的时间完成。但是，如果不使用惰性加载，应用程序将会获取比所需更多的数据，造成内存消耗问题。</p>

<p>ORM 通常将此决定留给开发者，以便他们可以根据应用程序的情况做最好的处理。不幸的是，开发者通常的处理结果是在应用程序和 UI 之间共享模型。如果 UI 更新超时，会产生难以预料和调试的问题。</p>

<p>例如：让 UI Book 对象的列表，并且没本书都有一个 Author 对象。最初可能设计使用惰性加载查询，如 Book 实例使用 getAuthor() 方法返回作者。getAuthor() 的第一次调用会调用查询数据库。一段时间后，还需要在应用程序的 UI 显示作者名字。可以轻松的添加方法调用，如以下代码片段所示：</p>

<p>authorNameTextView.setText(user.getAuthor().getName());<br/>
然而，这个看似无辜的变化造成在主线程上查询 Author 表。</p>

<p>如果急需查询作者信息，当不在需要数据时，很难改变数据的加载方式，例如，应用程序的 UI 不再需要显示有关特定作者的信息。因此，当数据不在显示时应用程序必须继续加载数据。如果 Author 类引用其它的表（如，有 getBooks() 方法）情况会更糟。</p>

<p>基于这些原因，Room 禁止 Entity 之间的对象引用。相反，必须明确的请求应用程序需要的数据。</p>

<blockquote>
<p>转自 <a href="https://juejin.im/post/593df980ac502e006c049607">https://juejin.im/post/593df980ac502e006c049607</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture Components -- Guide to App Architecture]]></title>
    <link href="xuyushi.github.io/15299133102446.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133102446.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">应用程序架构指南</h1>

<p>本指南使用于具有构建应用程序基础并且想了解构建强大、优质的应用程序的最佳实践和推荐架构的开发人员。</p>

<blockquote>
<p>注：本指南假定读者熟悉 Android Framework。如果你是一个应用程序开发的新手，请参阅入门指南系列培训，其中包含了本指南先决条件的相关主题。</p>
</blockquote>

<h2 id="toc_1">应用开发者面临的常见问题</h2>

<p>在大多数情况下，桌面应用程序在启动器快捷方式中有一个单一的入口并且作为单独的独立进程运行，与桌面应用程序不同，Android 应用具有更复杂的结构。一个典型的 Android 应用是由多个应用程序组件构成的，包括 activity，fragment，service，content provider 和 broadcast receiver。</p>

<p>这些应用程序组件中的大部分声明在由 Android OS 使用的应用程序清单中，用来决定如何将应用融入到用户设备的整体体验中。尽管如前所述，传统的桌面应用程序作为独立进程运行，但是正确的编写 Android 应用程序需要更加灵活，因为用户会同过设备上不同的应用程序组织成自己的方式不断切换流程和任务。<br/>
<span id="more"></span><!-- more --></p>

<p>例如，考虑下在你喜欢的社交网络应用中分享照片时会发生什么。该应用会触发一个启动相机的 intent，从该 intent 中 Android OS 会启动一个相机应用来处理这个请求。在此刻，用户离开社交网络应用但是用户的体验是无缝的。相机应用转而可能会触发其它的 intent，例如启动文件选择器，这可能会启动另一个应用。最终用户回到社交网络应用并且分享照片。此外，在这个过程中的任何时刻用户都有可能会被一个电话打断，并且在结束通话后再回来继续分享照片。</p>

<p>在 Android 中，这种应用切换行为很常见，所以你的应用程序必须正确处理这些流程。记住，移动设备的资源是有限的，所以在任何时候，操作系统都可能会杀死一些应用为新的应用腾出空间。</p>

<p>其中的重点是应用程序组件可能会被单独和无序的启动，并且可能会被用户或系统在任何时候销毁。因为应用程序组件是短暂的，并且其声明周期（什么时候被创建和销毁）不受你控制，<strong>所以不应该在应用程序组件中存储任何应用数据或状态，同时应用程序组件不应该相互依赖</strong>。</p>

<h2 id="toc_2">常见的架构原则</h2>

<p>如果不能在应用程序组件中存储应用数据和状态，那么应该如何构建应用？</p>

<p>最重要的是在应用中要专注于关注点分离。一个常见的错误是在 Activity 或 Fragment 中编写所有的代码。任何不是处理 UI 或 操作系统交互的代码都不应该在这些类中。保持它们尽可能的精简可以避免许多与生命周期有关的问题。不要忘记你不拥有这些类，它们只是体现了 OS 和 应用之间协议的粘合类。Android OS 可能会因为用户交互或其他因素（如低内存）的原因在任何时候销毁它们。最好尽量减少对它们的依赖以提供一个稳固的用户体验。</p>

<p>第二个重要的原则是应该<strong>用 Model 驱动 UI，最好是持久化的 Model</strong>。持久化是最佳的原因有两个：一是如果 OS 销毁应用释放资源，用户不用担心丢失数据；二是即使网络连接不可靠或者是断开的，应用仍将继续运行。Model 是负责处理应用数据的组件。Modle 独立于应用中的 View 和应用程序组件，因此 Model 和这些组件的生命周期问题隔离开了。保持 UI 代码精简并且摒除应用的逻辑使其更易于管理。<strong>基于 Model 类构建的应用程序其管理数据的职责明确，使应用程序可测试并且稳定</strong>。</p>

<h2 id="toc_3">推荐的应用程序架构</h2>

<p>在本节中，我们将通过一个用例来演示如何使用 Architecture Components 构建应用程序。</p>

<blockquote>
<p>注：不可能有一种应用程序的编写方式对于每种情况都是最好的。话虽如此，这个推荐的架构应该是大多数用例的良好起点。如果你已经有一种很好的应用程序编写方式则不需要改变。</p>
</blockquote>

<p>假设我们正在构建一个显示用户个人信息的 UI。用户的个人信息将使用 REST API 从我们自己的私有后端获取。</p>

<h3 id="toc_4">构建用户界面</h3>

<p>UI 包含一个 fragment 文件 UserProfileFragment.java 和其布局文件 user_profile_layout.xml。</p>

<p>为了驱动 UI，数据模型需要持有两个数据元素。</p>

<ul>
<li>用户 ID ：用户的标识符。最好使用 fragment 的参数将用户 ID 传到 fragment 中。如果 Android OS 销毁进程，该 ID 将会被保存，以便下次应用重启时该 ID 可用。</li>
<li>用户对象：保存用户数据的普通 Java 对象（POJO）。</li>
</ul>

<p>我们将会基于 ViewModel 来创建一个 UserProfileViewModel 来保存这些信息。</p>

<p>ViewModel 为指定的 UI 组件（如：fragment 或 activity）提供数据，并且负责与数据处理的业务部分的交互，例如：调用其它组件获取数据或转发用户的操作。ViewModel 对于 View 并不了解并且不受配置改变（如：由于旋转导致 activity 的重新创建）的影响</p>

<p>现在有 3 个文件</p>

<ul>
<li>user_profile.xml：屏幕上的 UI 定义。</li>
<li>UserProfileViewModel.java：为 UI 准备数据的类。</li>
<li>UserProfileFragment.java：用于在 ViewModel 中显示数据并对用户交互做出反应的 UI 控制器。</li>
</ul>

<p>下面是我们的初始实现（简单起见省略布局文件）：</p>

<pre><code class="language-java">public class UserProfileViewModel extends ViewModel {
    private String userId;
    private User user;

    public void init(String userId) {
        this.userId = userId;
    }
    public User getUser() {
        return user;
    }
}
</code></pre>

<pre><code class="language-java">public class UserProfileFragment extends LifecycleFragment {
    private static final String UID_KEY = &quot;uid&quot;;
    private UserProfileViewModel viewModel;

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        String userId = getArguments().getString(UID_KEY);
        viewModel = ViewModelProviders.of(this).get(UserProfileViewModel.class);
        viewModel.init(userId);
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.user_profile, container, false);
    }
}
</code></pre>

<blockquote>
<p>注：上面的例子继承了 LifecycleFragment 而不是 Fragment 类。在 Architecture Components 中的生命周期 API 稳定后， Android 支持包中的 Fragment 类将会实现 LifecycleOwner 接口。</p>
</blockquote>

<p>现在我们有了 3 个代码模块，怎样连接它们？最后，当 ViewModel 的用户字段被设置时，需要一种方式来通知 UI。这正是 LiveData 的用武之地。</p>

<blockquote>
<p>LiveData 是一个可观察的数据持有者。它允许应用程序中的组件观察 LiveData 进行改变，而不会在组件之间创建显示的，固定的依赖。另外，LiveData 还遵守应用程序组件（如：activity，fragment，service）的生命周期状态，并且防止对象泄漏使应用不会消耗更多的内存。</p>

<p>注：如果你已经再使用像 RxJava 或 Agera 的库，你可以继续使用它们而不用换成 LiveData。但是当使用它们或其它的方式时，请确保正确处理生命周期，如：当相关 LifecycleOwner 停止时暂停数据流或在 LifecycleOwner 被销毁时销毁数据流。可以添加 android.arch.lifecycle:reactivestreams 工具，和其它的响应流库（如：RxJava2）一起使用 LiveData。</p>
</blockquote>

<p>将 UserProfileViewModel 中的 User 字段替换为 LiveData ，以便在更新数据时可以通知 fragment。 LiveData 的好处在于它是生命周期感知的，并且可以在不再被需要的时候自动清除引用。</p>

<pre><code class="language-java">public class UserProfileViewModel extends ViewModel {
    ...
    // private User user;
    private LiveData&lt;User&gt; user;
    public LiveData&lt;User&gt; getUser() {
        return user;
    }
}
</code></pre>

<p>修改 UserprofileFragment 来观察数据并更新 UI。</p>

<pre><code class="language-java">@Override
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    viewModel.getUser().observe(this, user -&gt; {
      // 更新 UI
    });
}
</code></pre>

<p>每次更新用户数据时，将会调用 onChange) 回调并且更新 UI。</p>

<p>如果你熟悉其它库的可观察回调的使用，可能已经意识到我们没有重写 fragment 的 onStop() 方法来停止观察数据。这对于 LiveData 来说是不必要的，因为 LiveData 是证明周期感知的，这意味着除非 fragment 处于活动状态（收到了 onStart() 但还没有收到 onStop()），否则它不会调用回调。当 fragment 收到 onDestroy() 时 LiveData 会自动移除观察者。</p>

<p>我们没有做任何事情来特别是处理配置的变化（如：用户旋转屏幕）。当配置发生变化时 ViewModel 将会自动恢复，所以，只要新的 fragment 启动，它将会收到属于 ViewModel 的相同实例，并且使用最新的数据立即调用回调。这就是为什么 ViewModel 不应该直接引用 View，ViewModel 可能存活的比 View 的生命周期长。请参阅 ViewModel 的生命周期。</p>

<h3 id="toc_5">获取数据</h3>

<p>我们已经将 ViewModel 链接到了 fragment，但是 ViewModel 怎样获取数据呢？这个例子中，假设我们的后端提供了一个 REST API。我们将会使用 Retrofit 库来访问后端，你也可以自由的使用其它库来达到同样的目的。</p>

<p>这是 retrofit 的 Webservice 类，用于和后端通讯：</p>

<pre><code class="language-java">public interface Webservice {
    /**
     * @GET declares an HTTP GET request
     * @Path(&quot;user&quot;) annotation on the userId parameter marks it as a
     * replacement for the {user} placeholder in the @GET path
     */
    @GET(&quot;/users/{user}&quot;)
    Call&lt;User&gt; getUser(@Path(&quot;user&quot;) String userId);
}
</code></pre>

<p>一个简单的 ViewModel 实现可以直接调用 Webservice 获取数据并将其分配给用户对象。即使这样可以使用，但是应用程序将会随着增长而难以维护。将太多的职责交给 ViewModel 这违反了我们前面提到的关注点分离的原则。此外，ViewModel 的作用域依赖于 Activity 或 Fragment 的生命周期，因此在 Activity 或 Fragment 的生命周期结束时丢失所有的数据是一种不好的用户体验。故而，我们的 ViewModel 将把这项工作委托给一个新的 Repository 模块。</p>

<p>Repository 模块负责处理数据操作。它们为应用程序的其它部分提供了一个干净的 API。它们知道在数据更新时从哪里获取数据和调用哪些 API。可以将其视为不同数据源（持久化模型，Web 服务，缓存等）之间的中间层。</p>

<p>下面的 UserRepository 类使用 WebService 来获取用户数据。</p>

<pre><code class="language-java">public class UserRepository {
    private Webservice webservice;
    // ...
    public LiveData&lt;User&gt; getUser(int userId) {
        // 这是最佳的实现，下面会有解释
        final MutableLiveData&lt;User&gt; data = new MutableLiveData&lt;&gt;();
        webservice.getUser(userId).enqueue(new Callback&lt;User&gt;() {
            @Override
            public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) {
                // 为了简单起见省略错误的情况
                data.setValue(response.body());
            }
        });
        return data;
    }
}
</code></pre>

<p>虽然 Repository 模块看起来是不必要的，但是它起着一个重要的作用；它抽象了应用程序其它部分的数据源。现在 ViewModel 不知道数据是由 Webservice 获取的，这意味着可以根据需求将其切换为其它实现。</p>

<blockquote>
<p>注：为了简单起见，我们忽略了网络错误的情况。有关于暴露错误和加载状态的可选实现方式，请参阅附录：。<a href="https://developer.android.com/topic/libraries/architecture/guide.html#addendum">暴露网络状态</a></p>
</blockquote>

<h4 id="toc_6">管理组件之间的依赖</h4>

<p>上面的 UserRepository 类需要一个 Webservice 的实例来完成其工作。可以简单的创建 Webservice，但是这需要知道 Webservice 的依赖来构造它。这将会显著的使代码复杂和重复（例如：需要 Webservice 实例的每个类都需要知道如何使用它的依赖来构造它）。另外，UserRepostory 可能不是唯一需要 Webservice 的类。如果每个类都创建一个新的 Webservice，这将会造成非常大的资源负担。</p>

<p>有两种模式可以解决这个问题：</p>

<ul>
<li>依赖注入：依赖注入允许类定义其依赖而不构造它们。在运行时，另一个类负责提供这些依赖。推荐使用 Google 的 Dagger 2 库在 Android 应用中实现依赖注入。Dagger 2 通过遍历依赖关系树自动构建对象并为依赖提供编译时保障。</li>
<li>服务定位：服务定位提供了一个注册表，类可以从中获取它们的依赖关系，而不是构造它们。与依赖注入（DI）相比，服务定位实现起来相对容易，所以如果不熟悉 DI，请使用服务定位代替。</li>
</ul>

<p>这些模式允许你扩展代码，因为它们提供清晰的模式来管理依赖关系，而不会重复代码或增加复杂性。两者都允许替换实现进行测试；这是使用它们的主要好处之一。</p>

<p>在这个例子中，我们将使用 Dagger 2 来管理依赖。</p>

<h3 id="toc_7">连接 ViewModel 和 Repository</h3>

<p>修改 UserProfileViewModel 以使用 Repository。</p>

<pre><code class="language-java">public class UserProfileViewModel extends ViewModel {
    private LiveData&lt;User&gt; user;
    private UserRepository userRepo;

    @Inject // UserRepository 参数由 Dagger 2 提供
    public UserProfileViewModel(UserRepository userRepo) {
        this.userRepo = userRepo;
    }

    public void init(String userId) {
        if (this.user != null) {
            // ViewModel 是由 Fragment 创建的
            // 所以我们知道 userId 不会改变
            return;
        }
        user = userRepo.getUser(userId);
    }

    public LiveData&lt;User&gt; getUser() {
        return this.user;
    }
}
</code></pre>

<h3 id="toc_8">缓存数据</h3>

<p>上述 Repository 的实现对于抽象调用 Web 服务是很好的，但是因为它仅依赖于一个数据源所以不是很实用。</p>

<p>上述 UserRepository 的实现的问题是在获取到数据之后没有把数据保存下来。如果用户离开 UserProfileFragment 然后返回回来，应用将会重新获取数据。这样是很不好的，原因有两个：一是浪费了宝贵的网络带宽；二是迫使用户等待新的查询完成。为了解决这个问题，我们将在 UserRepository 中添加一个新的数据源，用以在内存中缓存 User 对象。</p>

<pre><code class="language-java">@Singleton  // 告诉 Dagger 这个类只应该构造一次
public class UserRepository {
    private Webservice webservice;
    // 简单的内存缓存，为了简单忽略相关细节
    private UserCache userCache;
    public LiveData&lt;User&gt; getUser(String userId) {
        LiveData&lt;User&gt; cached = userCache.get(userId);
        if (cached != null) {
            return cached;
        }

        final MutableLiveData&lt;User&gt; data = new MutableLiveData&lt;&gt;();
        userCache.put(userId, data);
        // 这还不是最好的但比以前的好。
        // 一个完整的实现必须处理错误的情况。
        webservice.getUser(userId).enqueue(new Callback&lt;User&gt;() {
            @Override
            public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) {
                data.setValue(response.body());
            }
        });
        return data;
    }
}
</code></pre>

<h3 id="toc_9">持久化数据</h3>

<p>在当前的实现中，如果用户旋转屏幕或离开并返回应用，已存在的 UI 将会立即可见，因为 Repository 从内存缓存中取回数据。但是，如果用户离开应用并在几个小时后（Android OS 已经杀死进程后）返回又会发生什么？</p>

<p>如果是目前的实现，将会需要再次从网络获取数据。这不仅是一个不好的用户体验，并且也是浪费，因为这将会使用移动数据重新获取同样的数据。可以通过缓存 Web 请求来简单的解决这个问题，但是这会导致新的问题。如果相同的用户数据来自另一种请求并显示（例如：获取朋友列表）将会怎样？这时应用会显示不一致的数据，这是最令人困惑的用户体验。例如：相同用户的数据可能会显示的不同，因为朋友列表的请求和用户个人信息的请求可能会在不同的时间执行。应用程序需要合并它们以避免显示不一致的数据。</p>

<p>解决这个问题的正确方法是使用持久化模型。这就是持久化库 Room 的用武之地了。</p>

<p>Room 是一个以最少的样板代码提供本地数据持久化的对象映射库。在编译时，它会根据模式验证每个查询，所以损坏的 SQL 查询只会导致编译时错误，而不是运行时崩溃。Room 抽象出一些使用原始 SQL 表查询的底层实现细节。它还允许观察数据库数据（包括集合和连接查询）的变化，并通过 LiveData 对象暴露这些变化。另外，它明确定义了线程约束以解决常见问题（如在主线程访问存储）。</p>

<p>使用 Room，需要定义我们的局部模式。首先，用 @Entity 注释 User 类，将其标记为数据库中的一个表。</p>

<pre><code class="language-java">@Entity
class User {
  @PrimaryKey
  private int id;
  private String name;
  private String lastName;
  // 字段的 get 和 set 方法
}
</code></pre>

<p>然后，通过继承 RoomDatabase 为应用创建一个数据库。</p>

<pre><code class="language-java">@Database(entities = {User.class}, version = 1)
public abstract class MyDatabase extends RoomDatabase {
}
</code></pre>

<p>请注意，MyDatabase 是抽象类，Room 会自动提供其实现类。详细信息请参阅 Room 的文档。</p>

<p>现在需要一种方法来将用户数据插入数据库。为此，我们将创建一个数据库访问对象（ DAO ）。</p>

<pre><code class="language-java">@Dao
public interface UserDao {
    @Insert(onConflict = REPLACE)
    void save(User user);
    @Query(&quot;SELECT * FROM user WHERE id = :userId&quot;)
    LiveData&lt;User&gt; load(String userId);
}
</code></pre>

<p>然后，在数据库类中引用 DAO。</p>

<pre><code class="language-java">@Database(entities = {User.class}, version = 1)
public abstract class MyDatabase extends RoomDatabase {
    public abstract UserDao userDao();
}
</code></pre>

<p>请注意，load 方法的返回值是 LiveData。Room 知道数据库何时被修改，当数据发生变化时，它会通知所有处于活动状态的观察者。使用 LiveData 是高效的是因为它只有在至少有一个处于活动状态的观察者时才会更新数据。</p>

<p>现在修改 UserRepository 来整合 Room 的数据源。</p>

<pre><code class="language-java">@Singleton
public class UserRepository {
    private final Webservice webservice;
    private final UserDao userDao;
    private final Executor executor;

    @Inject
    public UserRepository(Webservice webservice, UserDao userDao, Executor executor) {
        this.webservice = webservice;
        this.userDao = userDao;
        this.executor = executor;
    }

    public LiveData&lt;User&gt; getUser(String userId) {
        refreshUser(userId);
        // 直接从数据库返回一个 LiveData。
        return userDao.load(userId);
    }

    private void refreshUser(final String userId) {
        executor.execute(() -&gt; {
            // 在后台线程中运行
            // 检查最近是否获取过 user
            boolean userExists = userDao.hasUser(FRESH_TIMEOUT);
            if (!userExists) {
                // 刷新数据
                Response response = webservice.getUser(userId).execute();
                // TODO 检查错误等。
                // 更新数据库。LiveData 将会自动刷新
                // 所以除了更新数据库外不需要任何操作。
                userDao.save(response.body());
            }
        });
    }
}
</code></pre>

<p>请注意，即使我们更改了 UserRepository 中的数据来源，我们也不需要更改 UserProfileViewModel 或 UserProfileFragment。这是抽象带来的灵活性。这样也非常易于测试，因为在测试 UserProfileViewModel 可以提供一个假的 UserRepository。</p>

<p>现在我们的代码是完整的，如果用户日后再回到相同的 UI，他们会立即看到用户信息，因为我们已经将其持久化了。同时，如果数据过期，Repository 将会在后台更新数据。当然，根据你的用例，如果持久化的数据太旧你可能不希望显示它们。</p>

<p>在一些用例中，如下拉刷新，在进行网络操作时显示用户数据对于 UI 来说非常重要。将 UI 操作从实际数据中分离是一个很好的做法，因为其可能由于各种原因而被更新（例如：如果获取一个朋友列表，用户可能会再次获取到相同数据并触发 LiveData 更新）。从 UI 的角度来看，动态请求实际上只是另一个数据点，类似其它任何数据片段（如：User 对象）</p>

<p>这种用例有两种常见的解决方案：</p>

<ul>
<li>更改 getUser 以返回包含网络操作状态的 LiveData。在附录：暴露网络状态部分提供了一个实现例子。</li>
<li>在 Repository 类中提供一个可以返回 User 刷新状态的公共方法。如果只是为了响应明确的用户操作而在 UI 中显示网络状态（如：下拉刷新），则这种方式是更好的选择。</li>
</ul>

<h4 id="toc_10">单一数据源</h4>

<p>不同的 REST API 接口返回相同的数据是很常见的。例如，如果后端有另一个返回朋友列表的接口，相同的用户对象（也许是不同的粒度）可能来自两个不同的 API 接口。如果 UserRepository 把从 Webservice 请求获取到的响应原样返回，码么 UI 可能会显示不一致的数据，因为在这些请求之间数据可能在服务端发生了改变。这就是为什么在 UserRepository 的实现中 Web 服务的回调只是将数据保存到了数据库。然后，对数据库的更改将会触发处于活动状态的 LiveData 对象上的回调。</p>

<p>在这个模型中，数据库服务作为单一数据源，应用程序的其它部分通过 Repository 来访问它。无论是否是否磁盘缓存，建议 Repository 指定一个数据源作为应用程序其它部分的单一数据源。</p>

<h3 id="toc_11">测试</h3>

<p>我们已经提到分离的好处之一是可测试性。让我们看看如何测试每个代码模块。</p>

<ul>
<li><p>用户界面或用户交互：这将是唯一一次需要 Android UI Instrumentation test。测试 UI 代码的最佳方式是创建一个 Espresso 测试。可以创建一个 fragment 并为其提供一个模拟的 ViewModel。因为 fragment 只和 ViewModel 交互，随意模拟 ViewModel 足以完全测是 UI。</p></li>
<li><p>ViewModel：可以使用 JUnit test 来测试 ViewModel。只需要模拟 UserRepository 来测试它。</p></li>
<li><p>UserRepository：也可以使用 JUnit test 来测试 UserRepository。需要模拟 Webservice 和 DAO。可以测试 UserRepository 是否进行了正确的 Web 服务调用，将结构保存到数据库，如果数据被缓存且是最新的，则不会发起任何不必要的请求。因为 WebService 和 UserDao 都是接口，所以可以模拟它们或者为更复杂的测试用例创建假的实现。</p></li>
<li><p>UserDao：推荐使用 Instrumentation 测试的方式测试 DAO 类。因为 Instrumentation 测试不需要任何 UI，它们会运行的很快。对于每个测试，可以创建一个内存数据库以确保测试没有任何副作用（例如：改变磁盘上的数据库文件）。</p></li>
</ul>

<p>Room 还允许指定数据库实现，所以可以通过向其提供 SupportSQLiteOpenHelper 的 JUnit 实现来测试它。通常不推荐这种方式，因为设备上运行的 SQLite 版本可能和主机上的 SQLite 版本不同。</p>

<ul>
<li><p>Webservice：重点是使测试相对于外部独立，所以 Webservice 的测试要避免通过网络调用后端。有许多库可以帮助完成该测试。例如：MockWebServer 是一个很好的库，可以帮助为测试创建一个假的本地服务。</p></li>
<li><p>测试工件架构组件提供了一个 maven 工件来控制其后台线程。在 android.arch.core:core-testing 工件中，有两个 JUnit 规则：</p>
<ul>
<li><p>InstantTaskExecutorRule：该规则可用于强制架构组件立即执行调用线程上的任何后台操作。</p></li>
<li><p>CountingTaskExecutorRule：该规则可用于 Instrumentation 测试，以等待架构组件的后台操作，或将其连接到 Espresso 作为闲置资源。</p></li>
</ul></li>
</ul>

<h3 id="toc_12">最终的架构</h3>

<p>下图显示了推荐架构中的所有模块以及它们如何互相交互：</p>

<p><img src="media/15299133102446/14985551550676.png" alt=""/></p>

<h2 id="toc_13">指导原则</h2>

<p>编程是一个创作领域，构建 Android 应用也不例外。有许多方法来解决问题，无论是在多个 activity 或 fragment 之间传递数据，是获取远程数据并为了离线模式将其持久化到本地，还是特殊应用遭遇的其它常见情况。</p>

<p>虽然一下建议不是强制性的，但是以我们的经验，从长远来看，遵循这些建议将会使代码库更健壮，易测试和易维护。</p>

<ul>
<li><p>在 manifest 中定义的入口点，如：acitivy，fragment，broadcast receiver 等，不是数据源。相反，它们应该只是协调与该入口点相关的数据子集。由于每个应用程序组件的存活时间很短，这取决于用户与其设备的交互以及运行时的总体状况，所以任何入口点都不应该成为数据源。</p></li>
<li><p>严格的在应用程序的各个模块之间创建明确的责任界限。例如：不在代码库中的多个类或包中扩散从网络加载数据的代码。同样，不要将无关的责任（如：数据缓存和数据绑定）放到同一个类中。</p></li>
<li><p>每个模块尽可能少的暴露出来。不要视图创建暴露模块内部实现细节的“只一个”的快捷方式。你可能会在短期内节省一些时间，但是随着代码库的发展，你将会多次偿还更多的基数债务。</p></li>
<li><p>当定义模块间的交互时，请考虑如何让每个模块可以独立的测试。例如，拥有一个用于从网络获取数据且定义良好的 API 的模块，将会使其更易于测试在本地数据库中持久化数据。相反，如果将两个模块的逻辑放在一个地方，或者将网络代码扩散到整个代码库，测试将会变的非常困难（并非不可能）。</p></li>
<li><p>应用程序的核心是使其脱颖而出。不要花费时间重复造轮子或一次又一次的编写相同的样板代码。相反，将精力集中在使应用程序独一无二上，让 Android Architecture Components 和其它的优秀的库来处理重复的样板代码。</p></li>
<li><p>持久化尽可能多的相关最新数据，以便应用程序在设备处于离线模式时还可以使用。即使你可以享用稳定高速的网络连接，但是你的用户可能无法享用。</p></li>
<li><p>Repository 应该指定一个数据源作为单一数据源。每当应用程序需要访问数据时，数据应该始终来源于单一数据源。有关更多信息，请参阅单一数据源</p></li>
</ul>

<h2 id="toc_14">附录：暴露网络状态</h2>

<p>在上面推荐的应用程序架构部分，为了保持示例简单我们故意忽略网络错误和加载状态。在本节中，我们演示一种通过 Resource 类暴露网络状态来封装数据和其状态。</p>

<p>以下是一个实现的例子：</p>

<pre><code class="language-java">// 描述数据和其状态的类
public class Resource&lt;T&gt; {
    @NonNull public final Status status;
    @Nullable public final T data;
    @Nullable public final String message;
    private Resource(@NonNull Status status, @Nullable T data, @Nullable String message) {
        this.status = status;
        this.data = data;
        this.message = message;
    }

    public static &lt;T&gt; Resource&lt;T&gt; success(@NonNull T data) {
        return new Resource&lt;&gt;(SUCCESS, data, null);
    }

    public static &lt;T&gt; Resource&lt;T&gt; error(String msg, @Nullable T data) {
        return new Resource&lt;&gt;(ERROR, data, msg);
    }

    public static &lt;T&gt; Resource&lt;T&gt; loading(@Nullable T data) {
        return new Resource&lt;&gt;(LOADING, data, null);
    }
}
</code></pre>

<p>因为从磁盘中获取并显示数据同时再从网络获取数据是一种常见的用例。我们将创建一个可以在多个地方使用的帮助类 NetworkBoundResource。下面是 NetworkBoundResource 的决策树。</p>

<p><img src="media/15299133102446/14985554809848.png" alt=""/></p>

<p>它通过观察资源的数据库。当首次从数据库加载条目时，NetworkBoundResource 检查返回结果是否足够好可以被发送和（或）应该从网络获取数据。请注意，他们可能同时发生，因为你可能会希望在显示缓存数据的同时从网络更新数据。</p>

<p>如果网络调用成功，则将返回数据保存到数据库中并重新初始化数据流。如果网络请求失败，直接发送一个错误。</p>

<blockquote>
<p>注：将新的数据保存到磁盘后，要从数据库重新初始化数据流，但是通常不需要这样做，因为数据库将会发送变更。另一方面，依赖数据库发送变更会有一些不好的副作用，因为在数据没有变化时如果数据库会避免发送更改将会使其中断。我们也不希望发送从网络返回的结果，因为这违背的单一数据源原则（即使在数据库中有触发器会改变保存值）。我们也不希望在没有新数据的时候发送 SUCCESS，因为这会给客户端发送错误信息。</p>
</blockquote>

<p>以下是 NetworkBoundResource 类为其子类提供的公共 API：</p>

<pre><code class="language-java">// ResultType: Resource 数据的类型
// RequestType: API 响应的类型
public abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; {
    // 调用该方法将 API 响应的结果保存到数据库中。
    @WorkerThread
    protected abstract void saveCallResult(@NonNull RequestType item);

    // 调用该方法判断数据库中的数据是否应该从网络获取并更新。
    @MainThread
    protected abstract boolean shouldFetch(@Nullable ResultType data);

    // 调用该方法从数据库中获取缓存数据。
    @NonNull @MainThread
    protected abstract LiveData&lt;ResultType&gt; loadFromDb();

    // 调用该方法创建 API 请求。
    @NonNull @MainThread
    protected abstract LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; createCall();

    // 获取失败时调用。
    // 子类可能需要充值组件（如：速率限制器）。
    @MainThread
    protected void onFetchFailed() {
    }

    // 返回一个代表 Resource 的 LiveData。
    public final LiveData&lt;Resource&lt;ResultType&gt;&gt; getAsLiveData() {
        return result;
    }
}
</code></pre>

<p>请注意，上述类定义了两个类型参数（ResultType，RequestType），因为从 API 返回的数据类型可能和本地使用的数据类型不同。</p>

<p>还要注意，上述代码使用 ApiResponse 作为网络请求，ApiResponse 是对于 Retrofit2.Call 类的简单封装，用以将其响应转换为 LiveData。</p>

<p>以下是 NetworkBoundResource 类的其余实现部分。</p>

<pre><code class="language-java">public abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; {
    private final MediatorLiveData&lt;Resource&lt;ResultType&gt;&gt; result = new MediatorLiveData&lt;&gt;();

    @MainThread
    NetworkBoundResource() {
        result.setValue(Resource.loading(null));
        LiveData&lt;ResultType&gt; dbSource = loadFromDb();
        result.addSource(dbSource, data -&gt; {
            result.removeSource(dbSource);
            if (shouldFetch(data)) {
                fetchFromNetwork(dbSource);
            } else {
                result.addSource(dbSource,
                        newData -&gt; result.setValue(Resource.success(newData)));
            }
        });
    }

    private void fetchFromNetwork(final LiveData&lt;ResultType&gt; dbSource) {
        LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; apiResponse = createCall();
        // 重新附加 dbSource 作为新的来源,
        // 它将会迅速发送最新的值。
        result.addSource(dbSource,
                newData -&gt; result.setValue(Resource.loading(newData)));
        result.addSource(apiResponse, response -&gt; {
            result.removeSource(apiResponse);
            result.removeSource(dbSource);
            //noinspection ConstantConditions
            if (response.isSuccessful()) {
                saveResultAndReInit(response);
            } else {
                onFetchFailed();
                result.addSource(dbSource,
                        newData -&gt; result.setValue(
                                Resource.error(response.errorMessage, newData)));
            }
        });
    }

    @MainThread
    private void saveResultAndReInit(ApiResponse&lt;RequestType&gt; response) {
        new AsyncTask&lt;Void, Void, Void&gt;() {

            @Override
            protected Void doInBackground(Void... voids) {
                saveCallResult(response.body);
                return null;
            }

            @Override
            protected void onPostExecute(Void aVoid) {
                // 指定请求一个最新的实时数据。
                // 否则，会得到最新的缓存数据，并且可能不会由从网络获取的最新数据更新。
                result.addSource(loadFromDb(),
                        newData -&gt; result.setValue(Resource.success(newData)));
            }
        }.execute();
    }
}
</code></pre>

<p>现在，可以使用 NetworkBoundResource 在 Repository 中编写磁盘和网络绑定 User 的实现。</p>

<pre><code class="language-java">class UserRepository {
    Webservice webservice;
    UserDao userDao;

    public LiveData&lt;Resource&lt;User&gt;&gt; loadUser(final String userId) {
        return new NetworkBoundResource&lt;User,User&gt;() {
            @Override
            protected void saveCallResult(@NonNull User item) {
                userDao.insert(item);
            }

            @Override
            protected boolean shouldFetch(@Nullable User data) {
                return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data));
            }

            @NonNull @Override
            protected LiveData&lt;User&gt; loadFromDb() {
                return userDao.load(userId);
            }

            @NonNull @Override
            protected LiveData&lt;ApiResponse&lt;User&gt;&gt; createCall() {
                return webservice.getUser(userId);
            }
        }.getAsLiveData();
    }
}
</code></pre>

<blockquote>
<p>转自 <a href="https://juejin.im/post/5937b1d7a22b9d005810b877">https://juejin.im/post/5937b1d7a22b9d005810b877</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture Components--ViewModel]]></title>
    <link href="xuyushi.github.io/15299133101129.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133101129.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">ViewModel</h1>

<p>ViewModel 类是被设计用来存储和管理 UI 相关的数据，以便在配置更改（如：屏幕旋转）时数据可以保留下来。</p>

<p>应用程序组件（如：activity 和 fragment）具有一个由 Android Framework 管理的生命周期。Framework 可能会完全不受控制的根据某些用户操作或设备事件来决定销毁或重新创建它们。</p>

<p>由于这些对象有可能被操作系统销毁或重新创建，所以保存在它们中的任何数据都会丢失。例如：如果 activity 中有一个用户列表，当 activity 因为配置更改而重新创建时，新的 activity 必须重新获取用户列表。对于简单的数据，activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的 bundle 里恢复数据，但是这种方式只适用于少量数据（如：UI 状态），不适用于大量数据（如：用户列表）。</p>

<p>另一个问题是，这些 UI 控制器（activity，fragment 等）经常需要发起一些需要一定时间才能返回的异步调用。UI 控制器需要管理这些调用并且在其被销毁时清理它们避免潜在的内存泄漏。这需要大量的维护工作，并且在由于配置更改导致对象被重新创建的情况下十分浪费资源，因为需要重新发起相同的请求。<br/>
<span id="more"></span><!-- more --></p>

<p>这些 UI 控制器已经需要完成响应用户操作和处理操作系统通信的工作了。当它们还需要手动处理其资源时，将会使类变的臃肿，创造“万能 activity”（或“万能 fragment”）；也就是说，一个单独的类视图自己处理应用程序的所有工作，而不是将工作委派给其它类。这将会使测试非常困难。</p>

<p>将视图数据的所有权从 UI 控制器的逻辑中分离出来是简单高效的。Lifecycle 提供了一个叫 ViewModel 的新类，一个 UI 控制器的帮助类，用来为 UI 准备数据。在配置更改期间，ViewModel 会自动保留，以便其保存的数据能够立即提供给下一个 activity 或 fragment 实例。在我们上面提到的例子中，获取并持有数据是 ViewModel 的责任，而不是 activity 或 fragment 的。</p>

<pre><code class="language-java">public class MyViewModel extends ViewModel {
    private MutableLiveData&lt;List&lt;User&gt;&gt; users;
    public LiveData&lt;List&lt;User&gt;&gt; getUsers() {
        if (users == null) {
            users = new MutableLiveData&lt;List&lt;Users&gt;&gt;();
            loadUsers();
        }
        return users;
    }

    private void loadUsers() {
        // 执行异步操作获取用户
    }
}
</code></pre>

<p>现在 activity 可以像下面这样访问列表：</p>

<pre><code class="language-java">public class MyActivity extends AppCompatActivity {
    public void onCreate(Bundle savedInstanceState) {
        MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);
        model.getUsers().observe(this, users -&gt; {
            // 更新 UI
        });
    }
}
</code></pre>

<p>如果 activity 被重新创建，它将会收到由之前 activity 创建的同一个 MyViewModel 实例。当所有者 activity 结束后，Framework 会调用 ViewModel 的 onCleared() 方法来清理资源。</p>

<blockquote>
<p>注：由于 ViewModel 存活的比个别的 activity 和 fragment 实例，所以它决不能引用 View，或任何持有 activity context 的引用的类。如果 ViewModel 需要 Application 的 context（如：调用系统服务），可以继承 AndroidViewModel 类，可以在构造函数中接受 Application（因为 Application 继承了 Context）。</p>
</blockquote>

<h2 id="toc_1">在 Fragment 之间共享数据</h2>

<p>activity 中的两个或多个 fragment 需要相互通信是很常见的。这不是个简单的事情，所有的 fragment 都需要定义一些接口描述，并且拥有它们的 activity 必须将两者绑定在一起。另外，所有的 fragment 必须处理其它的 fragment 没有被创建或不可见的情况。</p>

<p>使用 ViewModel 可以解决这个常见的痛点。假设一个主从式 fragment 的常见情况，用户从一个 fragment 的列表里选中一项，另一个 fragment 显示所选项的内容。</p>

<p>这些 fragment 可以使用其 activity 限定的 ViewModel 来处理该通讯</p>

<pre><code class="language-java">public class SharedViewModel extends ViewModel {
    private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;();

    public void select(Item item) {
        selected.setValue(item);
    }

    public LiveData&lt;Item&gt; getSelected() {
        return selected;
    }
}

public class MasterFragment extends Fragment {
    private SharedViewModel model;
    public void onActivityCreated() {
        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        itemSelector.setOnClickListener(item -&gt; {
            model.select(item);
        });
    }
}

public class DetailFragment extends LifecycleFragment {
    public void onActivityCreated() {
        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        model.getSelected().observe(this, { item -&gt;
           // 更新 UI
        });
    }
}
</code></pre>

<p>请注意，在获取 ViewModelProvider 时两个 fragment 都使用 getActivity() 方法。这意味着它们都将会收到被 activity 限定的同一个 SharedViewModel 实例。</p>

<p>这种方式的优点有：</p>

<p>activity 不需要做或知道关于该通讯的任何事情。</p>

<ul>
<li>除了 SharedViewModel 协议之外 fragment 不需要了解彼此。如果其中一个消失，另一个会照常工作。</li>
<li>每个 fragment 有自己的生命周期，并且不受其它 fragment 的生命周期影响。实际上，在 UI 中一个 fragment 替换另一个 fragment，UI 的运行没有任何问题。</li>
</ul>

<h2 id="toc_2">ViewModel 的生命周期</h2>

<p>在获取 ViewModel 时，ViewModel 对象被传递给 ViewModelProvider 的 Lifecycle 限定。ViewModel 保留在内存中，直到限定它的 Lifecycle 永久消失（当 activity 结束或 fragment 被分离）。<br/>
<img src="media/15299133101129/14983677008413.png" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture Components--LiveData]]></title>
    <link href="xuyushi.github.io/15299133101795.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133101795.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">LiveData</h1>

<p><code>LiveData</code> 是一个 data holder  类，持有一个可被观察的值。与普通的observable不同的是，<code>LiveData</code>遵循app 组件的生命周期。它能决定在某个生命周期是否被观察</p>

<p><code>LiveData</code> 在观察者生命周期的 STARTED 和 RESUMED 状态是可被激活的</p>

<pre><code class="language-java">public class LocationLiveData extends LiveData&lt;Location&gt; {
    private LocationManager locationManager;

    private SimpleLocationListener listener = new SimpleLocationListener() {
        @Override
        public void onLocationChanged(Location location) {
            setValue(location);
        }
    };

    public LocationLiveData(Context context) {
        locationManager = (LocationManager) context.getSystemService(
                Context.LOCATION_SERVICE);
    }

    @Override
    protected void onActive() {
        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);
    }

    @Override
    protected void onInactive() {
        locationManager.removeUpdates(listener);
    }
}
</code></pre>

<span id="more"></span><!-- more -->

<ul>
<li><code>onActive()</code>：当<code>LiveData</code>增加了一个observer 时被调用。这表示开始监听设备的location </li>
<li>onInactive()：当<code>LiveData</code>没有一个observer 时被调用。没有observer监听所以没必要去连接LocationManager service.</li>
<li>setValue()：更新<code>LiveData</code>中value，并通知激活状态下的observers</li>
</ul>

<pre><code class="language-java">public class MyFragment extends LifecycleFragment {
    public void onActivityCreated (Bundle savedInstanceState) {
        LiveData&lt;Location&gt; myLocationListener = ...;
        Util.checkUserStatus(result -&gt; {
            if (result) {
                myLocationListener.addObserver(this, location -&gt; {
                    // update UI
                });
            }
        });
    }
}
</code></pre>

<p><code>addObserver()</code> 方法第一个参数是 <code>LifecycleOwner</code>，这以为着这个 LiveData 被绑定到 LifeCycle 上</p>

<ul>
<li>如果Lifecycle 不在 STARTED or RESUMED 状态，当value 变化是 observer 不会被通知</li>
<li>如果 Lifecycle 销毁了，observer 会自动移除</li>
</ul>

<p>我们可以通过 LiveData  在 Activity 和 fragment 直接共享数据，比如</p>

<pre><code class="language-java">public class LocationLiveData extends LiveData&lt;Location&gt; {
    // 单例模式
    private static LocationLiveData sInstance;
    private LocationManager locationManager;

    @MainThread
    public static LocationLiveData get(Context context) {
        if (sInstance == null) {
            sInstance = new LocationLiveData(context.getApplicationContext());
        }
        return sInstance;
    }

    private SimpleLocationListener listener = new SimpleLocationListener() {
        @Override
        public void onLocationChanged(Location location) {
            setValue(location);
        }
    };

    private LocationLiveData(Context context) {
        locationManager = (LocationManager) context.getSystemService(
                Context.LOCATION_SERVICE);
    }

    @Override
    protected void onActive() {
        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);
    }

    @Override
    protected void onInactive() {
        locationManager.removeUpdates(listener);
    }
}
</code></pre>

<p>fragment 如下</p>

<pre><code class="language-java">public class MyFragment extends LifecycleFragment {
    public void onActivityCreated (Bundle savedInstanceState) {
        Util.checkUserStatus(result -&gt; {
            if (result) {
                LocationLiveData.get(getActivity()).observe(this, location -&gt; {
                   // update UI
                });
            }
        });
  }
}
</code></pre>

<p>这样就可以多个 fragment Activity 观察<code>MyLocationListener实例</code>，LiveData 可以比较优雅的管理这些 obverser</p>

<p>LiveData 还有以下几个优势</p>

<ul>
<li><strong>没有内存泄露</strong>：因为<code>Observer</code>被关联在了 <code>Lifecycle</code>对象中，所以他们能在生命周期 destory 的时候自动解除关联</li>
<li><strong>没有因为 Activity stop 而产生的 crash</strong> ：如果<code>Observer</code> 的<code>Lifecycle</code>不在激活的生命周期内。</li>
<li><strong>始终保持最新的数据</strong>：如果 <code>Lifecycle</code>重新启动（比如 Activity 重新start），会重新收到数据</li>
<li><strong>正确的config更改</strong>：如果由于配置更改（如设备旋转）而重新创建Activity或fragment，则会立即接收最后一个可用位置数据。</li>
<li><strong>共享资源</strong>：可以只保留一个<code>MyLocationListener</code>的实例只需连接系统服务一次，就可以支持应用内所有的observers</li>
<li><strong>不需要手动处理生命周期</strong>：fragment 只在需要的时候观察数据，不用担心被stop或在stop后开始观察。因为fragment 在观察时提供了其生命周期，LiveData自动管理所有这一切</li>
</ul>

<h2 id="toc_1">Transformations of LiveData</h2>

<p>有时候，您可能需要在将其分配给观察者之前对LiveData值进行更改，否则可能需要根据另一个LiveData实例返回不同的LiveData实例</p>

<p>Lifecycle包提供了一个Transformations类，其中包含这些操作的帮助方法（类似于 Rxjava map）。</p>

<h3 id="toc_2">Transformations.map()</h3>

<p>应用一个函数作用在LiveData上，并将结果传播到下游。</p>

<pre><code class="language-java">LiveData&lt;User&gt; userLiveData = ...;
LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; {
    user.name + &quot; &quot; + user.lastName
});
</code></pre>

<h3 id="toc_3">Transformations.switchMap()</h3>

<p>与map（）类似，将一个函数应用于该值并展开并将结果分派到下游。传递给switchMap（）的函数必须返回一个<code>Lifecycle</code></p>

<pre><code class="language-java">private LiveData&lt;User&gt; getUser(String id) {
  ...;
}

LiveData&lt;String&gt; userId = ...;
LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );
</code></pre>

<p>map 是把一个数据类型变换为另外一个数据类型。<br/>
switchMap 是把一个数据变化为另外一个 LiveData </p>

<p>使用这些转换允许在整个调用链中携带观察者的 Lifecycle 信息，以便只有在观察者观察到 LiveData 的返回时才运算这些转换。转换的这种惰性运算性质允许隐式的传递生命周期相关行为，而不必添加显式的调用或依赖。<br/>
<!--todo 没太理解--></p>

<p>每当您认为在ViewModel中需要一个Lifecycle对象时，转换可能就是解决方案。</p>

<p>例如：假设有一个 UI，用户输入一个地址然后会收到该地址的邮政编码。该 UI 简单的 ViewModel 可能像这样：</p>

<pre><code class="language-java">class MyViewModel extends ViewModel {
    private final PostalCodeRepository repository;
    public MyViewModel(PostalCodeRepository repository) {
       this.repository = repository;
    }

    private LiveData&lt;String&gt; getPostalCode(String address) {
       // DON&#39;T DO THIS
       return repository.getPostCode(address);
    }
}
</code></pre>

<p>如果这是实现，UI将需要从先前的LiveData注销，并在每次调用getPostalCode（）时重新注册到新的实例。此外，如果UI被重新创建，它会触发对repository.getPostCode（）的另一个调用，而不是使用以前的调用结果。</p>

<p>而不是使用这种方法，您可以实现邮政编码信息作为地址输入的转换：</p>

<pre><code class="language-java">class MyViewModel extends ViewModel {
    private final PostalCodeRepository repository;
    private final MutableLiveData&lt;String&gt; addressInput = new MutableLiveData();
    public final LiveData&lt;String&gt; postalCode =
            Transformations.switchMap(addressInput, (address) -&gt; {
                return repository.getPostCode(address);
             });

  public MyViewModel(PostalCodeRepository repository) {
      this.repository = repository
  }

  private void setInput(String address) {
      addressInput.setValue(address);
  }
}
</code></pre>

<p>我们甚至使邮政编码字段为public final，因为它永远不会更改。postalCode 被定义为addressInput的转换，所以当addressInput更改时，如果存在活动的观察者，则会调用repository.getPostCode（）。如果在调用时没有处于活动状态的观察者，在添加观察者之前不会进行任何运算。</p>

<p>该机制允许以较少的资源根据需要惰性运算来创建 LiveData。ViewModel 可以轻松获取到 LiveData 并在它们上面定义转换规则。</p>

<p>创建新的转换</p>

<p>在应用程序中可能会用到十几种不同的特定转换，但是默认是不提供的。可以使用 MediatorLiveData 实现自己的转换，MediatorLiveData 是为了用来正确的监听其它 LiveData 实例并处理它们发出的事件而特别创建的。MediatorLiveData 需要特别注意正确的向源 LiveData 传递其处于活动/闲置状态。有关详细信息，请参阅 Transformations 类。</p>

<h1 id="toc_4">参考</h1>

<blockquote>
<p><a href="https://juejin.im/post/5937e402a0bb9f005808d00e">https://juejin.im/post/5937e402a0bb9f005808d00e</a><br/>
<a href="https://developer.android.com/topic/libraries/architecture/livedata.html#transformations_of_livedata">https://developer.android.com/topic/libraries/architecture/livedata.html#transformations_of_livedata</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture Components--Lifecycle]]></title>
    <link href="xuyushi.github.io/15299133102342.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133102342.html</id>
    <content type="html"><![CDATA[
<p>通过 <code>android.arch.lifecycle</code> 包提供的接口和类，我们可以构建出能感知到生命周期的组件。这些组件可以根据当前的Fragment 或者 Activity 的生命周期做出相应的调整</p>

<p>大部分有生命周期的 app 组件都定义在了Android 的Framework 层。操作系统和Framework 维护着这些组件的生命周期。这些都是 Android 运行的核心。</p>

<p>如果想要在一个Activity 中显示设备的地理位置。通常代码是这样的<br/>
<span id="more"></span><!-- more --></p>

<pre><code class="language-java">class MyLocationListener {
    public MyLocationListener(Context context, Callback callback) {
        // ...
    }

    void start() {
        // connect to system location service
    }

    void stop() {
        // disconnect from system location service
    }
}

class MyActivity extends AppCompatActivity {
    private MyLocationListener myLocationListener;

    public void onCreate(...) {
        myLocationListener = new MyLocationListener(this, (location) -&gt; {
            // update UI
        });
  }

    public void onStart() {
        super.onStart();
        myLocationListener.start();
    }

    public void onStop() {
        super.onStop();
        myLocationListener.stop();
    }
}
</code></pre>

<p>目前看起来还不错，但是在实际的工程项目中。生命周期的这些回调方法，比如<code>onStart()</code>  <code>onStop()</code> 会变得非常大</p>

<p>而且有些组件还不是简单在<code>onStart()</code>方法中启动。还需要在启动前检查一些设置。比如检查 Activity 是否已经被 stop 或者 finish 掉。</p>

<p>代码可能会是这样</p>

<pre><code class="language-java">class MyActivity extends AppCompatActivity {
    private MyLocationListener myLocationListener;

    public void onCreate(...) {
        myLocationListener = new MyLocationListener(this, location -&gt; {
            // update UI
        });
    }

    public void onStart() {
        super.onStart();
        Util.checkUserStatus(result -&gt; {
            // what if this callback is invoked AFTER activity is stopped?
            if (result) {
                myLocationListener.start();
            }
        });
    }

    public void onStop() {
        super.onStop();
        myLocationListener.stop();
    }
}
</code></pre>

<p><code>android.arch.lifecycle</code> 包会提供有弹性和解耦的解决方法</p>

<h2 id="toc_0">Lifecycle</h2>

<p><code>Lifecycle</code> 类持有组件（例如 fragment Activity）的生命周期状态信息，允许其他类 observe 这个状态</p>

<p><code>Lifecycle</code> 使用两个主要枚举来跟踪其关联组件的生命周期状态</p>

<h3 id="toc_1">Event</h3>

<p>framework 和 Lifecycle class. 发出 lifecycle events 。这些event 被映射到 fragment 和 Activity 的的回调中</p>

<h3 id="toc_2">State</h3>

<p>当面组件的生命周期状态</p>

<p><img src="media/15299133102342/14982024870658.jpg" alt=""/></p>

<p>可以吧这些state视为节点。而 event 是这些节点的连线</p>

<p>类可以通过向其方法添加注解来监视组件的生命周期状态。</p>

<pre><code class="language-java">public class MyObserver implements LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
    }
}
aLifecycleOwner.getLifecycle().addObserver(new MyObserver());

</code></pre>

<h2 id="toc_3">LifecycleOwner</h2>

<p><code>LifecycleOwner</code> 是一个接口，只有一个方法——<code>getLifecycle(),</code> ，返回<code>Lifecycle</code> 。这个接口表示这个类具有一个<code>Lifecycle</code>。</p>

<p>这个类从每个拥有生命周期的独立类（比如fragment Activity ）中抽象出<code>Lifecycle</code>的所有权。这样组件就可以通用的使用<code>Lifecycle</code></p>

<blockquote>
<p>注意<br/>
Architecture Components 仍在测试阶段，所以 <code>Fragment</code> and <code>AppCompatActivity</code>没有实现这个接口。<br/>
<code>LifecycleActivity</code> and <code>LifecycleFragment</code> 实现了这个接口。等到<code>Lifecycles</code> 到了正式拜。support library 中的 fragment 和 Activity 会实现这个接口。 LifecycleActivity and LifecycleFragment会deprecated。</p>
</blockquote>

<p>我们可以把<code>MyLocationListener</code> 实现 <code>LifecycleObserver</code> 接口，并在<code>Lifecycle</code> onCreate 时初始化。这样就可以<code>MyLocationListener</code>自给自足自己做初始化 clean 等</p>

<pre><code class="language-java">public class LifeCycleTestActivity extends LifecycleActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_life_cycle_test);
        MyLocationListener listener = new MyLocationListener(this, getLifecycle());
        listener.enable();
        getLifecycle().addObserver(listener);

    }
}    


public class MyLocationListener implements LifecycleObserver {
    private static final String TAG = &quot;MyLocationListener&quot;;
    private boolean enabled = false;
    private Context mContext;
    private Lifecycle mLifecycle;

    public MyLocationListener(Context context, Lifecycle lifecycle) {
        mLifecycle = lifecycle;
        mContext = context;
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    void start() {
        if (enabled) {
            // connect
            Log.d(TAG, &quot;Lifecycle.Event.ON_START&quot;);
        }
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    void resume() {
        if (enabled) {
            // connect
            Log.d(TAG, &quot;Lifecycle.Event.ON_RESUME&quot;);
        }
    }

    public void enable() {
        enabled = true;
        if ( mLifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) {
            // connect if not connected
        }
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    void stop() {
        // disconnect if connected
        Log.d(TAG, &quot;Lifecycle.Event.ON_STOP&quot;);
    }
}
</code></pre>

<p>当 addObserver 之后，MyLocationListener能接受到 Activity 的生命周期的回调。它能在自己的类做初始化和 清理，解耦了与 Activity 的关系， 从而保持 Activity 代码的整洁</p>

<p>这些能和<code>Lifecycle</code>关联的组件被称为<code>lifecycle-aware components</code>。我们鼓励库提供这类组件。这样客户可以不用手动管理这些组件的生命周期</p>

<p>LiveData是生命周期感知组件的示例。与ViewModel一起使用LiveData可以在遵循Android生命周期的情况下，更容易地使用数据填充UI。</p>

<h2 id="toc_4">Best practices for Lifecycles</h2>

<ul>
<li>保持UI controllers(activities and fragments)  尽可能简洁。他们不应该去获取数据，应该使用<code>ViewModel</code>获取。然后通过观察 <code>ViewModel</code> 的变化，映射到 views 中</li>
<li>尽可能使数据来驱动 UI，UI controller 的责任是当数据变化时去更新,或者将用户事件传递给<code>ViewModel</code></li>
<li>把数据的逻辑放入<code>ViewModel</code>类中。<code>ViewModel</code>是连接 UI controller 和其他部分。<strong>注意 <code>ViewModel</code>的责任不是去获取数据，他的责任是调用合适的组件来做。然后吧结果返回给 UI controller</strong></li>
<li>使用<code>Data Binding</code> 解耦 view 和 UI controller</li>
<li>如果 UI 太复杂可以考虑加一个 Presenter 来处理 UI 变化</li>
<li>不用在 <code>ViewModel</code> 中持有 <code>View</code> 或者<code>Activity</code>。如果 ViewModel 的生命周期比 Activity 长 有可能会导致内存泄露</li>
</ul>

<h2 id="toc_5">Addendum</h2>

<h3 id="toc_6">自定义 fragment Activity 实现LifecycleOwner</h3>

<p>自定义 fragment Activity 可以通过构造 <code>LifecycleRegistryOwner</code> 实现<code>LifecycleOwner</code></p>

<pre><code class="language-java">public class MyFragment extends Fragment implements LifecycleRegistryOwner {
    LifecycleRegistry lifecycleRegistry = new LifecycleRegistry(this);

    @Override
    public LifecycleRegistry getLifecycle() {
        return lifecycleRegistry;
    }
}
</code></pre>

<h1 id="toc_7">参考</h1>

<blockquote>
<p><a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html#lco">https://developer.android.com/topic/libraries/architecture/lifecycle.html#lco</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven 仓库的使用和搭建]]></title>
    <link href="xuyushi.github.io/15299133101591.html"/>
    <updated>2018-06-25T15:55:10+08:00</updated>
    <id>xuyushi.github.io/15299133101591.html</id>
    <content type="html"><![CDATA[
<p>Maven项目使用项目对象模型（Project Object Model，POM）来配置。Maven 是一种构建工具，Maven 包是由所谓 POM（Project Object Model）所定义的文件<br/>
项目对象模型存储在名为 pom.xml 的文件中。<br/>
<span id="more"></span><!-- more --><br/>
以下是一个简单的示例：</p>

<pre><code class="language-markup">&lt;project&gt;
  &lt;!-- model version is always 4.0.0 for Maven 2.x POMs --&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  
  &lt;!-- project coordinates, i.e. a group of values which
       uniquely identify this project --&gt;
  
&lt;!--包组 id，通常是发布者拥有的域名的反向，以免跟别人的重复--&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;

  &lt;!-- library dependencies --&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
    
      &lt;!-- coordinates of the required library --&gt;
      
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      
      &lt;!-- this dependency is only used for running and compiling tests --&gt;
      &lt;!--比如常用的还有 compile --&gt;
      &lt;scope&gt;test&lt;/scope&gt;
      
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

<p>对于一个合符规范的 Maven Package，pom 文件、aar（或者 jar） 文件是必须的。</p>

<h2 id="toc_0">设置 maven 仓库</h2>

<p>在Android 项目中通常是是在根目录的 build.gradle 中设置 maven 仓库的地址</p>

<pre><code class="language-gradle">buildscript {
    repositories {
        maven {
            url &#39;https://xxxxxxxx/nexus/content/repositories/ss_app_android&#39;
        }

        maven {
            url &#39;https://xxxxxxx/nexus/content/repositories/central&#39;
        }
        
        // 这两个是 maven 的中央仓库
        jcenter()
        mavenCentral()
    }
}

</code></pre>

<p><code>maven { url }</code> 除了可以添加远程仓库，还能添加本地的 maven 仓库</p>

<pre><code class="language-gradle">maven {
    url &#39;file:///xxxxAndroid/repo/&#39;
}
</code></pre>

<h2 id="toc_1">发布 Maven 包</h2>

<p>可以通过 gradle 插件 快速发布 maven 仓库</p>

<h3 id="toc_2">lolcalmaven 发布</h3>

<ul>
<li>新建lolcalmaven module</li>
<li>修改gradle.properties </li>
</ul>

<pre><code class="language-gradle">PROJ_NAME=localrepo
PROJ_ARTIFACTID=localrepo
PROJ_POM_NAME=Local Repository
LOCAL_REPO_URL=file:///Users/your-user-name/Documents/Android/repo/
#以上是 Mac 的本地路径，如果是 Windows，则是类似：
#LOCAL_REPO_URL=file:///C:/Users/cadmanager/Documents/repo/

</code></pre>

<ul>
<li>在lolcalmaven 的 build.gradle 中增加和配置 maven plugin</li>
</ul>

<pre><code class="language-gradle">apply plugin: &#39;maven&#39;

uploadArchives {
    repositories.mavenDeployer {
        repository(url: LOCAL_REPO_URL)
        pom.groupId = PROJ_GROUP
        pom.artifactId = PROJ_ARTIFACTID
        pom.version = PROJ_VERSION      }
}
</code></pre>

<ul>
<li>控制台运行 </li>
</ul>

<pre><code class="language-bash">./gradlew -p localrepo clean build uploadArchives --info
</code></pre>

<p>生成的文件</p>

<pre><code class="language-bash">.
├── localrepo-1.0.0.aar
├── localrepo-1.0.0.aar.md5
├── localrepo-1.0.0.aar.sha1
├── localrepo-1.0.0.pom
├── localrepo-1.0.0.pom.md5
└── localrepo-1.0.0.pom.sha1

</code></pre>

<p>生成的 pom 文件</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;io.github.xuyushi&lt;/groupId&gt;
  &lt;artifactId&gt;localrepo&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;packaging&gt;aar&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.android.support&lt;/groupId&gt;
      &lt;artifactId&gt;appcompat-v7&lt;/artifactId&gt;
      &lt;version&gt;25.3.0&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

<ul>
<li>在新的项目工程中使用，在根目录的 gradle 中添加本地仓库</li>
</ul>

<pre><code class="language-java">allprojects {
    repositories {
        jcenter()
        maven {
            url &#39;file:///Users/xuyushi/Documents/Android/repo/&#39;
        }
    }
}
</code></pre>

<ul>
<li>在 app moudle的 build.gradle 中增加依赖
<code>compile &#39;io.github.xuyushi:localrepo:1.0.0&#39;</code></li>
</ul>

<p>这样就可以在项目中使用 本地仓库中的库了</p>

<h3 id="toc_3">发布 jcenter 远程仓库</h3>

<h4 id="toc_4">注册账号</h4>

<p><a href="https://bintray.com/">Jcenter</a> 注册账号<br/>
 Bintray是jcenter的托管商，因此你必须注册一个Bintray账号，注册完账号后记下你的用户名以及API Key。</p>

<p>登陆后在首页右上角点击用户名进入个人主页，然后点击用户名下面的Edit进入个人信息编辑页面，接下来点击页面左边列表的最后一项API Key</p>

<h4 id="toc_5">配置插件</h4>

<p>在项目的根目录 build.gradle 中添加 dependencies</p>

<pre><code class="language-gradle">    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.2.2&#39;
        classpath &#39;com.github.dcendents:android-maven-gradle-plugin:1.5&#39;
        classpath &#39;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.2&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
</code></pre>

<h3 id="toc_6">配置 local.properties</h3>

<p>配置在本地文件中 ，不计入版本管理</p>

<pre><code class="language-bash">bintray.user=xxxx
bintray.apikey=your keys
</code></pre>

<h3 id="toc_7">修改需要上传的 module 的 gradle 文件</h3>

<p>apply 插件 </p>

<pre><code class="language-gradle">apply plugin: &#39;com.github.dcendents.android-maven&#39;
apply plugin: &#39;com.jfrog.bintray&#39;
</code></pre>

<pre><code class="language-gradle">// This is the library version used when deploying the artifact
version = &quot;1.0.0&quot;

def siteUrl = &#39;http://xuyushi.github.io&#39;      // 项目的主页
def gitUrl = &#39;http://xuyushi.github.io&#39;   // Git仓库的url
group = &quot;io.github.xuyushi&quot;                                        // Maven Group ID for the artifact，一般填你唯一的包名

install {
    repositories.mavenInstaller {
        // This generates POM.xml with proper parameters
        pom {
            project {
                packaging &#39;aar&#39;
                // Add your description here
                name &#39;multi-format 1D/2D barcode image processing use zxing.&#39;
                url siteUrl
                // Set your license
                licenses {
                    license {
                        name &#39;The Apache Software License, Version 2.0&#39;
                        url &#39;http://www.apache.org/licenses/LICENSE-2.0.txt&#39;
                    }
                }
                developers {
                    developer {
                        id &#39;xuyushi&#39;        //填写的一些基本信息
                        name &#39;xuyushi&#39;
                        email &#39;xmy166@gmail.com&#39;
                    }
                }
                scm {
                    connection gitUrl
                    developerConnection gitUrl
                    url siteUrl
                }
            }
        }
    }
}
task sourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier = &#39;sources&#39;
}
task javadoc(type: Javadoc) {
    source = android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
}
task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = &#39;javadoc&#39;
    from javadoc.destinationDir
}
artifacts {
    archives javadocJar
    archives sourcesJar
}
Properties properties = new Properties()
properties.load(project.rootProject.file(&#39;local.properties&#39;).newDataInputStream())
bintray {
    user = properties.getProperty(&quot;bintray.user&quot;)
    key = properties.getProperty(&quot;bintray.apikey&quot;)
    configurations = [&#39;archives&#39;]
    pkg {
        repo = &quot;maven&quot;
        name = &quot;maventest&quot;    //发布到JCenter上的项目名字
        websiteUrl = siteUrl
        vcsUrl = gitUrl
        licenses = [&quot;Apache-2.0&quot;]
        publish = true
    }
}
javadoc { //jav doc采用utf-8编码否则会报“GBK的不可映射字符”错误
    options{
        encoding &quot;UTF-8&quot;
        charSet &#39;UTF-8&#39;
    }
}
</code></pre>

<h3 id="toc_8">在 jcenter 中新建 maven 仓库</h3>

<h3 id="toc_9">上传命令</h3>

<pre><code class="language-bash">./gradlew jcentermaven:bintrayUpload
</code></pre>

<h3 id="toc_10">将提交到Bintray的项目发布到JCenter</h3>

<p>完成上述的步骤只是将项目提交到bintray，还无法使用该项目库，因为还没有发布到JCenter。<br/>
登入Bintray网站，进入个人中心，在右侧的Owned Repositories区域点击Maven的图标，进入你的Maven项目列表。</p>

<p>如果已经上传成功了，在这里就能看到你的项目，进入项目详情，在右下角的Linked To区域点击Add to JCenter，然后在Comments输入框里随便填写下信息，最后点Send提交请求即可。一般情况下当天就会审核，审核通过后会给你发邮件通知你，并且以后更新项目就不需要再审核了。<br/>
审核成功后就可以使用你发布到JCenter上的项目了。<br/>
使用你发布到JCenter上的项目<br/>
在Bintray的搜索输入框中输入你的项目：</p>

<h3 id="toc_11">总结</h3>

<ul>
<li>既然要上传到Jcenter上，自然要去<a href="https://bintray.com">https://bintray.com</a> 中注册账号</li>
<li>根据自己的需求创建maven的Repository</li>
<li>把项目分离成Module</li>
<li>在项目根目录的build.gradle中添加bintray插件</li>
<li>在local.properties中添加bintray认证</li>
<li>修改Module中的build.gradle中的配置</li>
<li>在Android Studio终端使用./gradlew xxx上传</li>
<li>最后在JFrog Bintray中同步到Jcenter中</li>
</ul>

<h2 id="toc_12">本地 maven 仓库搭建</h2>

<p>todo</p>

<blockquote>
<p><a href="http://www.jianshu.com/p/9740778b154f">http://www.jianshu.com/p/9740778b154f</a></p>
</blockquote>

<h1 id="toc_13">参考</h1>

<blockquote>
<p><a href="http://kvh.io/cn/embrace-android-studio-maven-deploy.html">http://kvh.io/cn/embrace-android-studio-maven-deploy.html</a><br/>
<a href="https://zh.wikipedia.org/wiki/Apache_Maven">https://zh.wikipedia.org/wiki/Apache_Maven</a></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
